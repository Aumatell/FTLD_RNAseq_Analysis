---
title: "Gene modules"
---

# **High-Dimensional Weighted Gene Co-Expression Network Analysis (hdWGCNA): Rationale, Construction, and Analytical Goals**

## **Rationale**

While differential expression identifies gene-level changes associated with FTLD, it does not capture the higher-order organization of transcriptional programs or the coordinated dysregulation of functional gene networks. Neurodegenerative diseases‚Äîincluding FTLD-C9 and FTLD-TDP‚Äîare characterized by complex regulatory alterations affecting synaptic systems, glial and immune reactivity, metabolic rewiring, and RNA-processing machinery. These processes are best understood at the **module** (network) level rather than through isolated transcripts.

To resolve network-level biology at **cell-state resolution**, we applied **hdWGCNA** [@morabito2023_hdwgcna], a scalable adaptation of weighted gene co-expression network analysis (WGCNA) optimized for single-cell and pseudobulk data. By applying hdWGCNA to BayesPrism-derived expression matrices, we reconstructed **cell-state‚Äìspecific co-expression networks**, enabling detection of modules associated with disease status, neuropathological markers, and lineage-specific vulnerability.

## **Analytical Strategy**

### **1. Input Data: Cell-State Pseudobulk Matrices**

For each cohort (Sant Pau FTLD-C9, Sant Pau FTLD-TDP, Menden et al., Pottier et al.), hdWGCNA was performed **independently for every cell state** inferred by BayesPrism.

The input matrices consisted of:

-   log2-transformed counts per million (logCPM),

-   gene expression estimates for each sample within each cell state,

-   only genes expressed in at least **5% of samples** in that state (to reduce network noise and ensure connectivity).

Each cell state was stored as a **pseudobulk Seurat object**, enabling hdWGCNA‚Äôs native functions for network construction and visualization.

### **2. Network Construction and Soft-Thresholding**

Following standard WGCNA principles, hdWGCNA constructs networks that approximate scale-free topology. For each cell state:

1.  **Soft-thresholding power (Œ≤)** was selected using the scale-free topology criterion (pickSoftThreshold), ensuring:

```         
-   high scale-free fit index,

-   sufficient mean connectivity,

-   biologically interpretable network structure.
```

2.  An **unsigned network** was used for all analyses, allowing detection of both positively and negatively co-expressed gene relationships.

### **3. Module Eigengenes and Association With Disease**

A **module eigengene (ME)**‚Äîthe first principal component summarizing module expression‚Äîwas computed for each module.

For each cell state and each module:

-   MEs were compared between **FTLD-C9** or **FTLD-TDP** and controls to identify **disease-associated modules** using linear models.

```         
MEs were correlated (Spearman) with:

-   **neuropathological markers** (ACSL3, lncRNAs, RNA foci sense/antisense, polyGA, polyGP, polyGR, pTDP-43, STMN2)

-   **diagnostic group**

-   **cell-state proportions**.
```

This yielded **marker-associated modules**, capturing functional programs linked to pathological burden.

Modules were ranked by:

-   correlation magnitude,

-   p-value,

-   biological coherence,

-   number of hub genes.

### **4. Hub Gene Identification**

Hub genes for each module were identified using:

-   **kME (module membership)**,

-   correlation of each gene with the corresponding eigengene.

Genes with **kME ‚â• 0.90** were classified as high-confidence hub genes.\
These anchors define the regulatory core of each transcriptional module.

### **5. Functional Enrichment Analysis**

For each significantly disease-associated module:

-   Gene Ontology enrichment was performed using **Metascape**, restricted to:

```         
-   Biological Process

-   Molecular Function

-    Cellular Component
```

Background sets were defined as:

-   All genes expressed in that cell state (from Pineda et al. reference).

This ensured biologically appropriate enrichment interpretations.

Enrichment pinpointed:

-   synaptic processes,

-   immune and inflammatory pathways,

-   RNA metabolism,

-   apoptotic signaling,

-   vascular remodeling,

-   glial activation states.

### **6. Cross-Cohort Module Validation**

For module validation:

-   Gene lists from modules identified in Sant Pau cohorts were compared with those obtained from **Menden et al.** (for FTLD-C9) or **Pottier et al.** (for FTLD-TDP).

    Overlap statistics were computed using:

    -   **GeneOverlap tests**,

    -   **Jaccard indices**,

    -   directionality of eigengene changes.

A module was considered **validated** if:

-   it showed significant gene overlap (p \< 0.05), and

-   the eigengene change direction matched between cohorts.

## **Analytical Goals of the hdWGCNA Component**

The hdWGCNA pipeline was designed to:

1.  **Identify cell-state‚Äìspecific transcriptional modules** that distinguish FTLD-C9, FTLD-TDP, and healthy cortex.

2.  **Reveal convergent and divergent network-level changes** between genetic and sporadic FTLD subtypes.

3.  **Map disease-associated pathways** (synaptic signaling, immune activation, metabolic programs) to their cellular origins.

4.  **Integrate pathology burden** (e.g., pTDP-43, STMN2 loss, DPR accumulation, RNA foci density) with module activities.

5.  **Detect hub genes** representing potential mechanistic drivers or biomarkers.

6.  **Validate transcriptional networks** across independent external datasets.

7.  Provide a **systems-level framework** for interpreting FTLD pathophysiology beyond individual DEGs.

```{r code_7_hdwgcna_hdwgcna_generate_modules_r, eval=FALSE}
# single-cell analysis package
library(Seurat)

# plotting and data science packages
library(tidyverse)
library(cowplot)
library(patchwork)

# co-expression network analysis packages:
library(WGCNA)
library(hdWGCNA)

# paralel processing
library(fs)
library(future.apply)

# Configurar sessio
plan(multisession, workers = parallel::detectCores() - 1)
theme_set(theme_cowplot())
set.seed(12345)
enableWGCNAThreads(nThreads = 8)

# Directori d'entrada i sortida
input_dir <- "/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/25_09/FC/Rimod_C9/CELL STATE/"
output_dir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS/"

if (!dir_exists(output_dir)) dir_create(output_dir)
csv_files <- dir_ls(input_dir, glob = "*.csv")

WGCNA_pseudobulk <- function(file) {
  tryCatch({
    
    # Obtenir el nom base de l'arxiu sense extensi√≥
    sample_name <- path_ext_remove(path_file(file))
    sample_output_dir <- file.path(output_dir, sample_name)
    
    if (!dir_exists(sample_output_dir)) dir_create(sample_output_dir)
    
    message("Processing sample: ", sample_name)
    
    # Carregar dades en format CSV
    sc_data <- read.csv(file, row.names = 1)
    
    # Convertir a objecte Seurat
    seurat_obj <- CreateSeuratObject(counts = t(sc_data))
    seurat_obj <- SeuratObject::UpdateSeuratObject(seurat_obj)
    
    seurat_obj@meta.data$Sample <- rownames(sc_data)
    seurat_obj@meta.data$cell_type <- sample_name
    
    seurat_obj <- SetupForWGCNA(
      seurat_obj,
      gene_select = "fraction",
      fraction = 0.05,
      wgcna_name = "pseudobulk"
    )
    
    message("Selected genes: ", length(GetWGCNAGenes(seurat_obj)))
    
    # log2CPM normalization
    cpm <- t(apply(sc_data, 1, function(x) {
      y <- x / sum(x) * 1e6
      log2(y + 1)
    }))
    
    seurat_obj <- SetDatExpr(seurat_obj, mat = cpm)
    seurat_obj@assays$RNA$data <- t(cpm)
    
    # Soft thresholding
    seurat_obj <- TestSoftPowers(seurat_obj)
    
    # Save power plot
    png(file.path(sample_output_dir, "soft_power.png"), width = 1000, height = 800)
    PlotSoftPowers(seurat_obj)
    dev.off()
    
    # Construct network
    seurat_obj <- ConstructNetwork(
      seurat_obj,
      tom_name = "pseudobulk",
      overwrite_tom = TRUE,
      mergeCutHeight = 0.25
    )
    
    # Dendrogram
    png(file.path(sample_output_dir, "dendrogram.png"), width = 1000, height = 800)
    PlotDendrogram(seurat_obj, main = "pseudobulk dendrogram")
    dev.off()
    
    # Eigengenes and connectivity
    seurat_obj <- ModuleEigengenes(seurat_obj, npcs = 2)
    seurat_obj <- ModuleConnectivity(seurat_obj)
    
    # DotPlot of MEs
    MEs <- GetMEs(seurat_obj)
    mods <- setdiff(colnames(MEs), "grey")
    meta <- seurat_obj@meta.data
    seurat_obj@meta.data <- cbind(meta, MEs)
    
    p_dot <- DotPlot(seurat_obj, features = mods, group.by = "cell_type") +
      RotatedAxis() +
      scale_color_gradient(high = "red", low = "grey95") +
      xlab("") + ylab("")
    
    png(file.path(sample_output_dir, "dotplot_MEs.png"), width = 1000, height = 800)
    print(p_dot)
    dev.off()
    
    # Reset metadata
    seurat_obj@meta.data <- meta
    
    # UMAP
    seurat_obj <- RunModuleUMAP(
      seurat_obj,
      n_hubs = 5,
      n_neighbors = 10,
      min_dist = 0.4,
      spread = 3,
      supervised = TRUE,
      target_weight = 0.3
    )
    
    umap_df <- GetModuleUMAP(seurat_obj)
    centroid_df <- umap_df %>%
      dplyr::group_by(module) %>%
      dplyr::summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))
    
    p_umap <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2)) +
      geom_point(color = umap_df$color, size = umap_df$kME * 2) +
      geom_label(data = centroid_df, label = as.character(centroid_df$module),
                 fontface = "bold", size = 2) +
      umap_theme() +
      theme(panel.background = element_rect(fill = "black"))
    
    png(file.path(sample_output_dir, "umap_modules.png"), width = 1000, height = 800)
    print(p_umap)
    dev.off()
    
    # Save the final Seurat object
    saveRDS(seurat_obj, file = file.path(sample_output_dir, paste0(sample_name, "_seurat.rds")))
    
    message("Finished processing: ", sample_name)
    
  }, error = function(e) {
    message("‚ö†Ô∏è Error in sample: ", file)
    message("Details: ", e$message)
  })
}




#future_lapply(csv_files, WGCNA_pseudobulk, future.seed = TRUE)
for (file in csv_files){
  WGCNA_pseudobulk(file)
}


library(dplyr)
library(hdWGCNA)
library(xlsx)

# Loop over directories
for (CS in list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/", full.names = FALSE, recursive = FALSE)) {
  try({
    
    # Load Seurat object
    A <- readRDS(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/", CS, "/", CS, "_seurat.rds"))
    
    # Load and prepare metadata
    metadata <- xlsx::read.xlsx("/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx", 
                                row.names = 1, sheetIndex = 1)
    metadata_df <- as.data.frame(metadata)
    metadata_df$Sample_clean <- rownames(metadata_df)
    
    # Harmonize and merge metadata
    A$Sample_clean <- gsub("^X", "", A@meta.data$Sample)
    meta_joined <- A@meta.data %>%
      mutate(Sample_clean = gsub("^X", "", Sample)) %>%
      left_join(metadata_df, by = "Sample_clean")
    
    A@meta.data <- meta_joined
    
    # Get Module Eigengenes
    MEs <- hdWGCNA::GetMEs(A)
    
    # Correlation of MEs with group.ID
    cor_results <- apply(MEs, 2, function(module) {
      cor.test(module, as.numeric(as.factor(A@meta.data$group.ID)), 
               method = "spearman", exact = TRUE)
    })
    
    cor_df <- data.frame(
      module = names(cor_results),
      cor = sapply(cor_results, function(x) x$estimate),
      p.value = sapply(cor_results, function(x) x$p.value)
    )
    
    cor_df_sorted <- cor_df[order(cor_df$p.value), ]
    
    # Create output directory if not exists
    outdir <- paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/", CS, "/MODULES/")
    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
    
    # Write gene lists for significant modules
    module_colors <- A@misc$pseudobulk$wgcna_degrees
    
    sig_modules <- cor_df_sorted$module[cor_df_sorted$p.value < 0.05]
    
    for (mod in sig_modules) {
      genes <- module_colors$gene_name[module_colors$module == mod]
      write.csv(genes, file = paste0(outdir, mod, ".csv"), row.names = FALSE)
    }
    write.csv(cor_df_sorted, file = paste0(outdir, "/cor_summary.csv"), row.names = FALSE)
    print(paste0("Finished: ", CS))
    
  }) # end try
}



```

```{r eval=FALSE}
library(dplyr)
library(hdWGCNA)
library(xlsx)

for (CS in list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", full.names = FALSE, recursive = FALSE)) {
  try({
    
    # Load Seurat object
    A <- readRDS(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", CS, "/", CS, "_seurat.rds"))
    
    # Load metadata
    metadata <- xlsx::read.xlsx("/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx", 
                                row.names = 1, sheetIndex = 1)
    metadata_df <- as.data.frame(metadata)
    metadata_df$Sample_clean <- rownames(metadata_df)
    
    # Harmonize sample names
    A$Sample_clean <- gsub("^X", "", A@meta.data$Sample)
    meta_joined <- A@meta.data %>%
      mutate(Sample_clean = gsub("^X", "", Sample)) %>%
      left_join(metadata_df, by = "Sample_clean")
    A@meta.data <- meta_joined
    
    # Get Module Eigengenes
    MEs <- hdWGCNA::GetMEs(A)
    
    # Ensure sample order matches between MEs and metadata
    sample_order <- rownames(MEs)
    # Ensure consistent factor order: Healthy (control), TDP (case)
    group_vector <- factor(
      A@meta.data[match(sample_order, A@meta.data$Sample), "group.ID"],
      levels = c("Healthy", "TDP")
    )
    
    # Apply Wilcoxon test and calculate fold change
    test_results <- lapply(1:ncol(MEs), function(i) {
      vec <- MEs[, i]
      group1 <- vec[group_vector == "Healthy"]
      group2 <- vec[group_vector == "TDP"]
      fc <- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy
      test <- wilcox.test(group1, group2)
      
      list(
        module = colnames(MEs)[i],
        fold_change = fc,
        p.value = test$p.value
      )
    })
    
    cor_df <- do.call(rbind, lapply(test_results, as.data.frame))
    cor_df_sorted <- cor_df[order(cor_df$p.value), ]
    
    # Create output directory
    outdir <- paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", CS, "/MODULES/")
    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
    
    # Write gene lists for significant modules
    module_colors <- A@misc$pseudobulk$wgcna_degrees
    sig_modules <- cor_df_sorted$module[!is.na(cor_df_sorted$module)]
    
    for (mod in sig_modules) {
      genes <- module_colors$gene_name[module_colors$module == mod]
      write.csv(genes, file = paste0(outdir,mod, ".csv"), row.names = FALSE)
    }
    
    # Write summary and hub genes
    Hubs <- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)
    write.csv(cor_df_sorted, file = paste0(outdir, "/cor_summary.csv"), row.names = FALSE)
    write.csv(as.data.frame(Hubs), file = paste0(outdir, "/hubs.csv"), row.names = FALSE)
    
    print(paste0("Finished: ", CS))
  })
}


library(Seurat)
library(dplyr)
library(hdWGCNA)

# Loop over directories
for (CS in list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/", full.names = FALSE, recursive = FALSE)) {
  try({
    
    # Load Seurat object
    A <- readRDS(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/", CS, "/", CS, "_seurat.rds"))
    
    # Load metadata
    metadata <- read.delim("/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt", 
                           row.names = 1, sep = "\t")
    metadata_df <- as.data.frame(metadata)
    metadata_df$Sample_clean <- gsub("-", "\\.",rownames(metadata_df))
    rownames(metadata_df) <- metadata_df$Sample_clean 
    # Filter out FTLD-TDP-C and recode group labels
    metadata_df <- metadata_df[metadata_df$GROUP != "FTLD-TDP-C", ]
    metadata_df$GROUP <- ifelse(metadata_df$GROUP == "Control", "Healthy", "TDP")
    
    samples_to_keep <- intersect(rownames(A@meta.data), metadata_df$Sample_clean)
    A <- subset(A,cells= samples_to_keep)
                
    # Harmonize and merge metadata
    A@meta.data <- metadata_df
    
    # Get Module Eigengenes
    MEs <- hdWGCNA::GetMEs(A)
    samples_in_A <- rownames(A@meta.data)
    MEs <- MEs[rownames(MEs) %in% samples_in_A, ]
    sample_order <- rownames(MEs)
    
    # Ensure correct group assignment order
    group_vector <- factor(
      A@meta.data[match(sample_order, rownames(A@meta.data)), "GROUP"],
      levels = c("Healthy", "TDP")
    )
    
    # Apply Wilcoxon test and compute fold change
    test_results <- lapply(1:ncol(MEs), function(i) {
      vec <- MEs[, i]
      group1 <- vec[group_vector == "Healthy"]
      group2 <- vec[group_vector == "TDP"]
      fc <- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy
      test <- wilcox.test(group1, group2)
      
      list(
        module = colnames(MEs)[i],
        fold_change = fc,
        p.value = test$p.value
      )
    })
    
    # Compile and sort results
    cor_df <- do.call(rbind, lapply(test_results, as.data.frame))
    cor_df_sorted <- cor_df[order(cor_df$p.value), ]
    
    # Create output directory
    outdir <- paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/", CS, "/MODULES/")
    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
    
    # Write gene lists for significant modules
    module_colors <- A@misc$pseudobulk$wgcna_degrees
    sig_modules <- cor_df_sorted$module[!is.na(cor_df_sorted$module)]
    
    for (mod in sig_modules) {
      genes <- module_colors$gene_name[module_colors$module == mod]
      write.csv(genes, file = paste0(outdir, mod, ".csv"), row.names = FALSE)
    }
    
    # Write summary and hub genes
    Hubs <- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)
    write.csv(cor_df_sorted, file = paste0(outdir, "/cor_summary.csv"), row.names = FALSE)
    write.csv(as.data.frame(Hubs), file = paste0(outdir, "/hubs.csv"), row.names = FALSE)
    
    print(paste0("Finished: ", CS))
  })
}
```

```{r eval=FALSE}

############################## Correlation MEs VS Covariables ###############################
library(hdWGCNA)
library(dplyr)
library(Seurat)
library(xlsx)

CS <- list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", full.names = FALSE, recursive = FALSE)[1]

for (CS in list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", 
                     full.names = FALSE, recursive = FALSE)) {
  if (file.exists(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", CS, "/", CS, "_seurat.rds"))) {
    
    tryCatch({
      
      message("Processing CS: ", CS)
#      sink(log_file, append = TRUE); cat(Sys.time(), " - Processing: ", CS, "\n"); sink()
      
      # Load Seurat object
      A <- readRDS(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/", CS, "/", CS, "_seurat.rds"))
      
      # Load metadata
      metadata <- xlsx::read.xlsx("/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx", 
                                  row.names = 1, sheetIndex = 1)
      covariables <- read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM")
      
      # Merge metadata
      covariables$X <- gsub("long", "", covariables$X)
      A$Sample_clean <- gsub("^X", "", A@meta.data$Sample)
      metadata_df <- as.data.frame(metadata)
      metadata_df$Sample_clean <- rownames(metadata_df)
      
      meta_joined <- A@meta.data %>%
        mutate(Sample_clean = gsub("^X", "", Sample)) %>%
        left_join(metadata_df, by = "Sample_clean") %>%
        left_join(covariables, by = c("Sample_clean" = "X"))
      
      rownames(meta_joined) <- colnames(A)
      A@meta.data <- meta_joined

      # Align rownames
      if (!all(rownames(A@meta.data) == colnames(A))) {
        rownames(A@meta.data) <- colnames(A)
      }
      
      # Ensure WGCNA results are present
      if (!"pseudobulk" %in% names(A@misc)) stop("WGCNA results not found in @misc$pseudobulk for ", CS)
      
      # Remove outlier
      outlier <- "7BLACK"
      if (outlier %in% colnames(A)) {
        A <- subset(A, cells = setdiff(colnames(A), outlier))
        rownames(A@meta.data) <- colnames(A)
      }
      
      # Ensure numeric trait
      A@meta.data$TDP43b <- as.numeric(as.character(A@meta.data$TDP43b))
      if (all(is.na(A@meta.data$TDP43b))) stop("TDP43b column is all NA for ", CS)
      
      # Calculate module eigengenes inside Seurat object
      MEs <- hdWGCNA::GetMEs(A, wgcna_name = "pseudobulk")
      A@misc$pseudobulk$MEs <- MEs
      
      # Check MEs exist
      if (is.null(A@misc$pseudobulk$MEs)) stop("No MEs found in object for ", CS)
      
      # Run Module-Trait correlation
      cor_results <- hdWGCNA::ModuleTraitCorrelation(
        seurat_obj = A,
        traits = "TDP43b",
        wgcna_name = "pseudobulk"
      )
      
      # Extract correlation dataframe safely
      cor_df <- GetModuleTraitCorrelation(cor_results)
      
      # Sort correlations
      # Extract correlations for 'all_cells'
      cor_vec <- cor_df$cor$all_cells
      pval_vec <- cor_df$pval$all_cells
      fdr_vec <- cor_df$fdr$all_cells
      
      # Convert to data frame
      cor_df_clean <- data.frame(
        module = names(cor_vec),
        cor = as.numeric(cor_vec),
        p.value = as.numeric(pval_vec),
        fdr = as.numeric(fdr_vec)
      )
      
      # Sort by absolute correlation and then p-value
      library(dplyr)
      cor_df_sorted <- cor_df_clean %>%
        arrange(desc(abs(cor)), p.value)
      
      # Save results
      outdir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS_asin_moduletraitcorrelation_tdp43b_tdp/"
      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)
      write.csv(cor_df_sorted, file = paste0(outdir, CS, ".csv"), row.names = FALSE)      
      # Cleanup
      rm(A, metadata, covariables, 
         cor_vec, pval_vec, fdr_vec,
         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()
      message("Finished processing CS: ", CS)
      
#      sink(log_file, append = TRUE); cat(Sys.time(), " - Finished: ", CS, "\n"); sink()
      
    }, error = function(e) {
#      sink(log_file, append = TRUE)
      cat(Sys.time(), "ERROR in ", CS, ": ", conditionMessage(e), "\n")
#      sink()
      message("Error in CS: ", CS, " ‚Üí ", conditionMessage(e))
    })
  }
}



############################## Correlation MEs VS Covariables ###############################

# C9 

# Must change the covariable name for each case.

library(hdWGCNA)
library(dplyr)
library(Seurat)
library(xlsx)

CS <- list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/", full.names = FALSE, recursive = FALSE)[1]

for (CS in list.dirs("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/", 
                     full.names = FALSE, recursive = FALSE)) {
  if (file.exists(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/", CS, "/", CS, "_seurat.rds"))) {
    
    tryCatch({
      
      message("Processing CS: ", CS)
      #      sink(log_file, append = TRUE); cat(Sys.time(), " - Processing: ", CS, "\n"); sink()
      
      # Load Seurat object
      A <- readRDS(paste0("/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/", CS, "/", CS, "_seurat.rds"))
      
      # Load metadata
      metadata <- xlsx::read.xlsx("/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx", 
                                  row.names = 1, sheetIndex = 1)
      covariables <- read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv")
      
      # Merge metadata
      covariables$X <- gsub("X", "", covariables$X)
      A$Sample_clean <- gsub("^X", "", A@meta.data$Sample)
      metadata_df <- as.data.frame(metadata)
      metadata_df$Sample_clean <- rownames(metadata_df)
      
      meta_joined <- A@meta.data %>%
        mutate(Sample_clean = gsub("^X", "", Sample)) %>%
        left_join(metadata_df, by = "Sample_clean") %>%
        left_join(covariables, by = c("Sample_clean" = "X"))
      
      rownames(meta_joined) <- colnames(A)
      A@meta.data <- meta_joined
      
      # Align rownames
      if (!all(rownames(A@meta.data) == colnames(A))) {
        rownames(A@meta.data) <- colnames(A)
      }
      
      # Ensure WGCNA results are present
      if (!"pseudobulk" %in% names(A@misc)) stop("WGCNA results not found in @misc$pseudobulk for ", CS)
      
      # Remove outlier
      outlier <- ""
      if (outlier %in% colnames(A)) {
        A <- subset(A, cells = setdiff(colnames(A), outlier))
        rownames(A@meta.data) <- colnames(A)
      }
      
      # Ensure numeric trait
      # A@meta.data$TDP43b <- as.numeric(as.character(A@meta.data$TDP43b))
      # if (all(is.na(A@meta.data$TDP43b))) stop("TDP43b column is all NA for ", CS)
      
      # Calculate module eigengenes inside Seurat object
      MEs <- hdWGCNA::GetMEs(A, wgcna_name = "pseudobulk")
      A@misc$pseudobulk$MEs <- MEs
      
      # Check MEs exist
      if (is.null(A@misc$pseudobulk$MEs)) stop("No MEs found in object for ", CS)
      
      # Run Module-Trait correlation
      cor_results <- hdWGCNA::ModuleTraitCorrelation(
        seurat_obj = A,
        traits = "pTDP43",
        wgcna_name = "pseudobulk"
      )
      
      # Extract correlation dataframe safely
      cor_df <- GetModuleTraitCorrelation(cor_results)
      
      # Sort correlations
      # Extract correlations for 'all_cells'
      cor_vec <- cor_df$cor$all_cells
      pval_vec <- cor_df$pval$all_cells
      fdr_vec <- cor_df$fdr$all_cells
      
      # Convert to data frame
      cor_df_clean <- data.frame(
        module = names(cor_vec),
        cor = as.numeric(cor_vec),
        p.value = as.numeric(pval_vec),
        fdr = as.numeric(fdr_vec)
      )
      
      # Sort by absolute correlation and then p-value
      library(dplyr)
      cor_df_sorted <- cor_df_clean %>%
        arrange(desc(abs(cor)), p.value)
      
      # Save results
      outdir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/C9/CS_Moduletraitcorrelations_Asin_pTDP43/"
      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)
      write.csv(cor_df_sorted, file = paste0(outdir, CS, ".csv"), row.names = FALSE)      
      # Cleanup
      rm(A, metadata, covariables, 
         cor_vec, pval_vec, fdr_vec,
         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()
      message("Finished processing CS: ", CS)
      
      #      sink(log_file, append = TRUE); cat(Sys.time(), " - Finished: ", CS, "\n"); sink()
      
    }, error = function(e) {
      #      sink(log_file, append = TRUE)
      cat(Sys.time(), "ERROR in ", CS, ": ", conditionMessage(e), "\n")
      #      sink()
      message("Error in CS: ", CS, " ‚Üí ", conditionMessage(e))
    })
  }
}
```

```{r fig_7_hdwgcna_1, echo=FALSE, eval=FALSE}
library(plotly)
library(tidyverse)

# ---- Base directory ----
base_dir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/7. HDWGCNA/FTLD/c9/CS_0.25_npcs2"

# ---- Detect cell states with MODULES folders ----
cell_states <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
cell_states <- as.character(cell_states)
cell_states <- cell_states[file.info(cell_states)$isdir]

# Flexible search for any folder named like "modules" (case insensitive)
is_valid <- sapply(cell_states, function(cs_path) {
  modules_path <- list.dirs(cs_path, full.names = TRUE, recursive = FALSE)
  modules_path <- modules_path[grepl("modules", basename(modules_path), ignore.case = TRUE)]
  if (length(modules_path) == 0) return(FALSE)
  csvs <- list.files(modules_path[1], pattern = "\\.csv$|\\.CSV$", full.names = TRUE)
  valid_csvs <- csvs[!grepl("cor_summary|hubs", csvs, ignore.case = TRUE)]
  length(valid_csvs) > 0
})

valid_states <- cell_states[is_valid]
names(valid_states) <- basename(valid_states)
message("‚úÖ Found ", length(valid_states), " valid cell states with MODULES: ",
        paste(names(valid_states), collapse = ", "))

# ---- Read module gene counts ----
module_summary <- list()

for (cs in names(valid_states)) {
  # Find the correct MODULES folder (case-insensitive)
  modules_path <- list.dirs(valid_states[cs], full.names = TRUE, recursive = FALSE)
  modules_path <- modules_path[grepl("modules", basename(modules_path), ignore.case = TRUE)][1]
  if (is.na(modules_path)) next
  
  module_files <- list.files(modules_path, pattern = "\\.csv$|\\.CSV$", full.names = TRUE)
  module_files <- module_files[!grepl("cor_summary|hubs", module_files, ignore.case = TRUE)]
  if (length(module_files) == 0) {
    message("‚ö†Ô∏è  No module CSVs in ", cs)
    next
  }
  
  # Count genes per module
  module_counts <- map_dfr(module_files, function(f) {
    df <- tryCatch(read.csv(f), error = function(e) NULL)
    if (is.null(df)) return(NULL)
    col_gene <- grep("^x$|gene", tolower(colnames(df)), value = TRUE)[1]
    if (is.na(col_gene)) return(NULL)
    tibble(
      Module = tools::file_path_sans_ext(basename(f)),
      GeneCount = nrow(df)
    )
  })
  
  if (nrow(module_counts) > 0) {
    module_summary[[cs]] <- module_counts
    message("üì¶ ", cs, " ‚Äî ", nrow(module_counts), " modules loaded.")
  } else {
    message("‚ö†Ô∏è  ", cs, " ‚Äî no valid modules found.")
  }
}

if (length(module_summary) == 0) stop("No valid MODULES folders found with readable modules.")

# ---- Create interactive pies ----
fig <- NULL
trace_counter <- 0

for (i in seq_along(module_summary)) {
  cs <- names(module_summary)[i]
  df <- module_summary[[i]]
  
  if (is.null(fig)) {
    fig <- plot_ly(
      data = df,
      labels = ~Module,
      values = ~GeneCount,
      type = "pie",
      textinfo = "label+percent",
      hoverinfo = "label+value+percent",
      name = cs,
      visible = TRUE
    )
  } else {
    fig <- fig %>%
      add_trace(
        data = df,
        labels = ~Module,
        values = ~GeneCount,
        type = "pie",
        textinfo = "label+percent",
        hoverinfo = "label+value+percent",
        name = cs,
        visible = FALSE
      )
  }
  trace_counter <- trace_counter + 1
}

# ---- Dropdown ----
buttons <- lapply(seq_along(module_summary), function(i) {
  vis <- rep(FALSE, trace_counter)
  vis[i] <- TRUE
  list(
    method = "update",
    args = list(
      list(visible = vis),
      list(title = paste0("Modules ‚Äî ", names(module_summary)[i]))
    ),
    label = names(module_summary)[i]
  )
})

fig <- fig %>%
  layout(
    title = paste0("Modules ‚Äî ", names(module_summary)[1]),
    updatemenus = list(list(
      y = 1.1,
      buttons = buttons,
      direction = "down",
      showactive = TRUE
    )),
    showlegend = TRUE
  )

fig


```

```{r fig_7_hdwgcna_2, echo=FALSE, eval=FALSE}
library(plotly)
library(tidyverse)

# ---- Base directory ----
base_dir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/7. HDWGCNA/Rimod/CS/"

# ---- Detect cell states with MODULES folders ----
cell_states <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
cell_states <- as.character(cell_states)
cell_states <- cell_states[file.info(cell_states)$isdir]

# Flexible search for any folder named like "modules" (case insensitive)
is_valid <- sapply(cell_states, function(cs_path) {
  modules_path <- list.dirs(cs_path, full.names = TRUE, recursive = FALSE)
  modules_path <- modules_path[grepl("modules", basename(modules_path), ignore.case = TRUE)]
  if (length(modules_path) == 0) return(FALSE)
  csvs <- list.files(modules_path[1], pattern = "\\.csv$|\\.CSV$", full.names = TRUE)
  valid_csvs <- csvs[!grepl("cor_summary|hubs", csvs, ignore.case = TRUE)]
  length(valid_csvs) > 0
})

valid_states <- cell_states[is_valid]
names(valid_states) <- basename(valid_states)
message("‚úÖ Found ", length(valid_states), " valid cell states with MODULES: ",
        paste(names(valid_states), collapse = ", "))

# ---- Read module gene counts ----
module_summary <- list()

for (cs in names(valid_states)) {
  # Find the correct MODULES folder (case-insensitive)
  modules_path <- list.dirs(valid_states[cs], full.names = TRUE, recursive = FALSE)
  modules_path <- modules_path[grepl("modules", basename(modules_path), ignore.case = TRUE)][1]
  if (is.na(modules_path)) next
  
  module_files <- list.files(modules_path, pattern = "\\.csv$|\\.CSV$", full.names = TRUE)
  module_files <- module_files[!grepl("cor_summary|hubs", module_files, ignore.case = TRUE)]
  if (length(module_files) == 0) {
    message("‚ö†Ô∏è  No module CSVs in ", cs)
    next
  }
  
  # Count genes per module
  module_counts <- map_dfr(module_files, function(f) {
    df <- tryCatch(read.csv(f), error = function(e) NULL)
    if (is.null(df)) return(NULL)
    col_gene <- grep("^x$|gene", tolower(colnames(df)), value = TRUE)[1]
    if (is.na(col_gene)) return(NULL)
    tibble(
      Module = tools::file_path_sans_ext(basename(f)),
      GeneCount = nrow(df)
    )
  })
  
  if (nrow(module_counts) > 0) {
    module_summary[[cs]] <- module_counts
    message("üì¶ ", cs, " ‚Äî ", nrow(module_counts), " modules loaded.")
  } else {
    message("‚ö†Ô∏è  ", cs, " ‚Äî no valid modules found.")
  }
}

if (length(module_summary) == 0) stop("No valid MODULES folders found with readable modules.")

# ---- Create interactive pies ----
fig <- NULL
trace_counter <- 0

for (i in seq_along(module_summary)) {
  cs <- names(module_summary)[i]
  df <- module_summary[[i]]
  
  if (is.null(fig)) {
    fig <- plot_ly(
      data = df,
      labels = ~Module,
      values = ~GeneCount,
      type = "pie",
      textinfo = "label+percent",
      hoverinfo = "label+value+percent",
      name = cs,
      visible = TRUE
    )
  } else {
    fig <- fig %>%
      add_trace(
        data = df,
        labels = ~Module,
        values = ~GeneCount,
        type = "pie",
        textinfo = "label+percent",
        hoverinfo = "label+value+percent",
        name = cs,
        visible = FALSE
      )
  }
  trace_counter <- trace_counter + 1
}

# ---- Dropdown ----
buttons <- lapply(seq_along(module_summary), function(i) {
  vis <- rep(FALSE, trace_counter)
  vis[i] <- TRUE
  list(
    method = "update",
    args = list(
      list(visible = vis),
      list(title = paste0("Modules ‚Äî ", names(module_summary)[i]))
    ),
    label = names(module_summary)[i]
  )
})

fig <- fig %>%
  layout(
    title = paste0("Modules ‚Äî ", names(module_summary)[1]),
    updatemenus = list(list(
      y = 1.1,
      buttons = buttons,
      direction = "down",
      showactive = TRUE
    )),
    showlegend = TRUE
  )

fig

```

```{r fig_7_hdwgcna_3, echo=FALSE, eval=FALSE}
library(plotly)
library(tidyverse)

# ============================================================
# LOAD MODULE SUMMARY (same as your script up to module_df)
# ============================================================

base_dir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/7. HDWGCNA/FTLD/TDP/CS_bo_ambhubs"

cell_states <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
cell_states <- cell_states[file.info(cell_states)$isdir]
names(cell_states) <- basename(cell_states)

module_summary <- list()

for (cs in names(cell_states)) {
  cs_path <- cell_states[cs]
  modules_dirs <- list.dirs(cs_path, full.names = TRUE, recursive = TRUE)
  modules_dirs <- modules_dirs[grepl("module", basename(modules_dirs), ignore.case = TRUE)]
  if (length(modules_dirs) == 0) next
  
  modules_path <- modules_dirs[1]
  module_files <- list.files(modules_path, pattern = "\\.csv$", full.names = TRUE, ignore.case = TRUE)
  module_files <- module_files[!grepl("cor_summary|hubs", basename(module_files), ignore.case = TRUE)]
  if (length(module_files) == 0) next
  
  module_counts <- purrr::map_dfr(module_files, function(f) {
    df <- tryCatch(read.csv(f), error = function(e) NULL)
    if (is.null(df)) return(NULL)
    col_gene <- grep("^x$|gene", tolower(colnames(df)), value = TRUE)[1]
    if (is.na(col_gene)) return(NULL)
    tibble(Module = tools::file_path_sans_ext(basename(f)),
           GeneCount = nrow(df))
  })
  
  if (nrow(module_counts) > 0)
    module_summary[[cs]] <- module_counts %>% mutate(CellState = cs)
}

if (length(module_summary) == 0)
  stop("‚ùå No valid MODULES folders with readable module CSVs were found.")

module_df <- bind_rows(module_summary)

# ============================================================
# PLOTLY PIE WITH DROPDOWN
# ============================================================

cell_states <- unique(module_df$CellState)

# 1Ô∏è‚É£ Create traces (each one is a visible/invisible pie)
traces <- lapply(seq_along(cell_states), function(i) {
  cs <- cell_states[i]
  df <- module_df %>% filter(CellState == cs)
  
  plot_ly(
    data = df,
    type = "pie",
    labels = ~Module,
    values = ~GeneCount,
    textinfo = "label+percent",
    hoverinfo = "label+value+percent",
    name = cs,
    title = paste("Modules in", cs),
    visible = ifelse(i == 1, TRUE, FALSE)  # show first only
  )
})

# Combine all traces into one figure
fig <- traces[[1]]
if (length(traces) > 1) {
  for (i in 2:length(traces)) {
    fig <- fig %>% add_trace(
      type = "pie",
      labels = traces[[i]]$x$attrs[[1]]$labels,
      values = traces[[i]]$x$attrs[[1]]$values,
      textinfo = "label+percent",
      hoverinfo = "label+value+percent",
      name = cell_states[i],
      visible = FALSE
    )
  }
}

# 2Ô∏è‚É£ Build dropdown buttons
buttons <- lapply(seq_along(cell_states), function(i) {
  list(
    method = "update",
    args = list(list(visible = sapply(seq_along(cell_states), function(j) j == i))),
    label = cell_states[i]
  )
})

# 3Ô∏è‚É£ Layout
fig <- fig %>%
  layout(
    title = list(text = "Module composition per cell state", x = 0.5),
    showlegend = TRUE,
    updatemenus = list(list(
      type = "dropdown",
      y = 1.15, x = 0.1,
      buttons = buttons,
      direction = "down",
      showactive = TRUE,
      xanchor = "left", yanchor = "top",
      title = list(text = "Select Cell State")
    )),
    # üü¢ Ensure the pie is drawn properly
    grid = list(rows = 1, columns = 1)
  )

fig


```

```{r fig_7_hdwgcna_4, echo=FALSE, eval=FALSE}
library(plotly)
library(tidyverse)

# ---- Base directory ----
base_dir <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/7. HDWGCNA/NEW/CS_bo"

# ---- Detect cell states with MODULES folders ----
cell_states <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
cell_states <- as.character(cell_states)
cell_states <- cell_states[file.info(cell_states)$isdir]

# Flexible search for any folder named like "modules" (case insensitive)
is_valid <- sapply(cell_states, function(cs_path) {
  modules_path <- list.dirs(cs_path, full.names = TRUE, recursive = FALSE)
  modules_path <- modules_path[grepl("modules", basename(modules_path), ignore.case = TRUE)]
  if (length(modules_path) == 0) return(FALSE)
  csvs <- list.files(modules_path[1], pattern = "\\.csv$|\\.CSV$", full.names = TRUE)
  valid_csvs <- csvs[!grepl("cor_summary|hubs", csvs, ignore.case = TRUE)]
  length(valid_csvs) > 0
})

valid_states <- cell_states[is_valid]
names(valid_states) <- basename(valid_states)
message("‚úÖ Found ", length(valid_states), " valid cell states with MODULES: ",
        paste(names(valid_states), collapse = ", "))

# ---- Read module gene counts ----
module_summary <- list()

for (cs in names(valid_states)) {
  # Find the correct MODULES folder (case-insensitive)
  modules_path <- list.dirs(valid_states[cs], full.names = TRUE, recursive = FALSE)
  modules_path <- modules_path[grepl("modules", basename(modules_path), ignore.case = TRUE)][1]
  if (is.na(modules_path)) next
  
  module_files <- list.files(modules_path, pattern = "\\.csv$|\\.CSV$", full.names = TRUE)
  module_files <- module_files[!grepl("cor_summary|hubs", module_files, ignore.case = TRUE)]
  if (length(module_files) == 0) {
    message("‚ö†Ô∏è  No module CSVs in ", cs)
    next
  }
  
  # Count genes per module
  module_counts <- map_dfr(module_files, function(f) {
    df <- tryCatch(read.csv(f), error = function(e) NULL)
    if (is.null(df)) return(NULL)
    col_gene <- grep("^x$|gene", tolower(colnames(df)), value = TRUE)[1]
    if (is.na(col_gene)) return(NULL)
    tibble(
      Module = tools::file_path_sans_ext(basename(f)),
      GeneCount = nrow(df)
    )
  })
  
  if (nrow(module_counts) > 0) {
    module_summary[[cs]] <- module_counts
    message("üì¶ ", cs, " ‚Äî ", nrow(module_counts), " modules loaded.")
  } else {
    message("‚ö†Ô∏è  ", cs, " ‚Äî no valid modules found.")
  }
}

if (length(module_summary) == 0) stop("No valid MODULES folders found with readable modules.")

# ---- Create interactive pies ----
fig <- NULL
trace_counter <- 0

for (i in seq_along(module_summary)) {
  cs <- names(module_summary)[i]
  df <- module_summary[[i]]
  
  if (is.null(fig)) {
    fig <- plot_ly(
      data = df,
      labels = ~Module,
      values = ~GeneCount,
      type = "pie",
      textinfo = "label+percent",
      hoverinfo = "label+value+percent",
      name = cs,
      visible = TRUE
    )
  } else {
    fig <- fig %>%
      add_trace(
        data = df,
        labels = ~Module,
        values = ~GeneCount,
        type = "pie",
        textinfo = "label+percent",
        hoverinfo = "label+value+percent",
        name = cs,
        visible = FALSE
      )
  }
  trace_counter <- trace_counter + 1
}

# ---- Dropdown ----
buttons <- lapply(seq_along(module_summary), function(i) {
  vis <- rep(FALSE, trace_counter)
  vis[i] <- TRUE
  list(
    method = "update",
    args = list(
      list(visible = vis),
      list(title = paste0("Modules ‚Äî ", names(module_summary)[i]))
    ),
    label = names(module_summary)[i]
  )
})

fig <- fig %>%
  layout(
    title = paste0("Modules ‚Äî ", names(module_summary)[1]),
    updatemenus = list(list(
      y = 1.1,
      buttons = buttons,
      direction = "down",
      showactive = TRUE
    )),
    showlegend = TRUE
  )

fig
```
