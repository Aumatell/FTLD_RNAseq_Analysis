---
title: "Bayesprism"
---

# **Bayesian Deconvolution Framework (BayesPrism): Rationale, Approach, and Analytical Objectives**

## **Rationale**

Bulk RNA-sequencing provides a high-throughput snapshot of gene expression in brain tissue but masks the substantial cellular heterogeneity of the human cortex. FTLD pathology affects specific neuronal populations—particularly RORB-expressing excitatory neurons—as well as diverse non-neuronal cell classes including astrocytes, microglia, oligodendrocytes, vascular cells, and infiltrating immune cells. As a result, interpreting bulk transcriptomic changes requires methods capable of **deconvolving mixed-cell signals into cell-type–specific expression profiles and cell-state proportions**.

Bayesian deconvolution methods, such as **BayesPrism**, offer major advantages over traditional regression or matrix factorization approaches by explicitly modeling biological variability and uncertainty. Using a high-resolution single-nucleus RNA-seq reference—such as the dataset from **Pineda et al. (Synapse ID: syn51105515)**—BayesPrism integrates single-cell information with bulk counts to infer, for each sample:

1.   **Cell-type and cell-state fractions**, representing the estimated proportion of each transcriptional state in the tissue.

2.   **Cell-type–specific expression estimates**, reconstructing a matrix of gene expression for each cell state within each patient.

This dual output allows downstream **cell-state–resolved differential expression, co-expression network analysis (hdWGCNA), and correlations with neuropathological markers**.

## **Analytical Strategy**

The Bayesian deconvolution approach consisted of the following steps:

### **1. Construction of the Single-Cell Reference**

The reference atlas from Pineda et al. contained **19 major cell classes and 44 transcriptionally distinct cell states** derived from human frontal cortex single-nucleus RNA-seq. The reference was preprocessed to:

-    exclude genes with low expression,

-   remove mitochondrial, ribosomal, and sex-chromosome transcripts,

-    retain only protein-coding genes expressed in ≥5 nuclei.

This produced a biologically curated transcriptional reference ideal for Bayesian modeling of cortical cell populations.

### **2. Alignment of Bulk and Single-Cell Data**

Bulk RNA-seq counts from all four cohorts (two Sant Pau, Menden et al., Pottier et al.) were matched to the gene identifiers in the reference.\
Counts were log-transformed where appropriate, and samples were retained only if sequencing quality and pathological classification were robust.

### **3. BayesPrism Initialization and Inference**

A **BayesPrism object** was created using the filtered single-cell matrix as the reference component and the raw bulk count matrix as the mixture component. The algorithm:

-   identifies **outlier genes** (cutoff = 0.01),

-   performs **Gibbs sampling** to estimate posterior distributions for each sample,

-   infers **cell-type fractions** (θ) and **cell-type–specific expression matrices** (φ) simultaneously.

Posterior estimates were extracted after convergence diagnostics ensured stable sampling across chains.

### **4. Extraction of Cell-State Proportions and Expression Matrices**

For each sample, BayesPrism returned:

-   **Posterior-estimated cell-state proportions**, enabling comparisons between FTLD-C9, FTLD-TDP, and controls.

-   **Cell-state–specific expression matrices**, which served as the basis for:

    -   edgeR-based cell-state differential expression.

    -   construction of pseudobulk Seurat objects,

    -   hdWGCNA module detection,

    -   correlation analysis with neuropathology (ACSL3, lncRNAs, RNA foci, DPRs, pTDP-43, STMN2).

### **5. Standardized Processing Across the Four Cohorts**

All steps—from reference alignment, through BayesPrism modeling, to extraction of posterior values—were performed identically in:

-   **Sant Pau FTLD-C9**

-   **Sant Pau FTLD-TDP**

-    **Menden et al. FTLD-C9**

-   **Pottier et al. FTLD-TDP**

This standardized pipeline enabled robust **cross-cohort comparison** of:

-    cell-state proportions,

-   cell-type–specific differential expression.

-   co-expression networks,

-   pathological-marker correlations.

## **Objectives of Applying BayesPrism**

BayesPrism was employed to achieve the following methodological goals:

1.   **Resolve bulk RNA-seq into cell-type and cell-state contributions** to uncover FTLD-associated alterations hidden in tissue-level averages.

2.   **Enable differential expression analysis at single-cell resolution**, identifying the precise neuronal and glial subtypes driving FTLD-C9 and FTLD-TDP transcriptional changes.

3.   **Quantify disease-related changes in cell-state composition**, including excitatory/inhibitory neuron loss and reactive glial expansion.

4.   **Map neuropathological burden (RNA foci, DPRs, pTDP-43, STMN2)** to transcriptional changes within specific cell states.

5.   **Generate high-dimensional transcriptional networks (hdWGCNA)** to identify disease-relevant modules that would otherwise be unresolvable in bulk data.

6.   **Validate findings across independent datasets** using a unified Bayesian framework to ensure reproducibility and generalizability.

```{r code_2_bayesprism_2_baysprism_ftld_c9_r, eval=FALSE}
library("ggplot2")
library("openxlsx")
library("dplyr")
library("coin")
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")
library("edgeR")
library("GO.db")
library("xlsx")
suppressWarnings(library("BayesPrism"))
suppressWarnings(library(org.Hs.eg.db))
library(dplyr) 
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")



################################################################################
# Single cell data
load("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData")
# Bulk data
bk.dat <-  read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv")
###############################################################################
#Set colnames and rownames
rownames(bk.dat)<-bk.dat[,1]
bk.dat <- bk.dat[,-1]
bk.dat <- t(bk.dat)

sc.dat <- t(merged@assays$Assay_name$counts)

A <- read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv")
A[44,"SubType" ] <- "T_Cell"
A[20,"SubType" ] <- "OPC"
A[19,"SubType" ] <- "Oligo"
A[18,"SubType" ] <- "Micro"

# Update metadata to take into account DGE groups.
merged@meta.data <- merged@meta.data %>%
  left_join(A, by = c("cellstate" = "SubType"))

# Cell type and state
cell.state.labels <- merged@meta.data$cellstate
cell.type.labels <- merged@meta.data$CellType
rm(merged)
gc()

# Pre-processing
plot.cor.phi (input=sc.dat, 
              input.labels=as.factor(cell.state.labels),
              title="cell state correlation",
              pdf.prefix="gbm.cor.cs",
              cexRow=0.2, 
              cexCol=0.2,
              margins=c(2,2)
)

plot.cor.phi (input=sc.dat,
              input.labels=as.factor(cell.type.labels),
              title="cell type correlation",
              pdf.prefix="gbm.cor.ct",
              cexRow=0.5, 
              cexCol=0.5,
)

sc.stat <- plot.scRNA.outlier(
  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID
  cell.type.labels=as.factor(cell.type.labels),
  species="hs", #currently only human(hs) and mouse(mm) annotations are supported
  return.raw=TRUE, #return the data used for plotting.
  pdf.prefix="SC_stats"
)
write.csv(sc.stat, "sc.stat.csv")

print("bk.stat")
bk.stat <- plot.bulk.outlier(
  bulk.input = bk.dat,
  sc.input = sc.dat,
  cell.type.labels = cell.type.labels,
  species = "hs",
  return.raw = TRUE,
  pdf.prefix = "BK_stats"
)
write.csv(bk.dat, "bk.stat.csv")


print("sc.stat.filtered")
sc.dat.filtered <- cleanup.genes (input=sc.dat,
                                  input.type="count.matrix",
                                  species="hs",
                                  gene.group=c( "Rb","Mrp","other_Rb","chrM","MALAT1","chrX","chrY") ,
                                  exp.cells=5
)
rm(sc.dat)
gc()
write.csv(sc.dat.filtered, "sc.dat.filtered.csv")

print("bk.stat.filtered")
plot.bulk.vs.sc (sc.input = sc.dat.filtered,
                 bulk.input = bk.dat,
                 pdf.prefix="Bulk_vs_Sc"
)

print("sc.dat.filtered.pc")
sc.dat.filtered.pc <- select.gene.type (sc.dat.filtered,
                                        gene.type = "protein_coding")
rm(sc.dat.filtered)
gc()
write.csv(sc.dat.filtered.pc, "sc.dat.filtered.pc.csv")

# SORT bk.dat so the colnames are sorted equaly in both tables. 
common_columns <- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))
bk.dat <- bk.dat[, common_columns]
sc.dat.filtered.pc <- sc.dat.filtered.pc[, common_columns]

rm(sc.dat)
rm(sc.dat.filtered)
rm(bk.stat)
rm(sc.stat)

myPrism <- new.prism(
  reference=sc.dat.filtered.pc,
  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),
  input.type="count.matrix",
  cell.type.labels = cell.type.labels,
  cell.state.labels = cell.state.labels,
  key=NULL,
  outlier.cut=0.01,
  outlier.fraction=0.1,
)
save(myPrism, file = "myPrism.RData")

bp.res <- run.prism(prism = myPrism, n.cores=50)
save(bp.res, file = "bp.res.RData")

theta <- get.fraction (bp=bp.res,
                       which.theta="final",
                       state.or.type="type")
write.csv(theta, "theta.csv")

theta.cv <- bp.res@posterior.theta_f@theta.cv
write.csv(theta.cv, "theta.cv.csv")

bp.res.initial <- run.prism(prism = myPrism, 
                            n.cores=50, 
                            update.gibbs=FALSE)
save(bp.res.initial, file = "bp.res.initial.RData")
#bp.res.update <- update.theta (bp = bp.res.initial)
#save(bp.res.update, file = "bp.res.update.RData")

theta.state <- get.fraction (bp=bp.res.initial,
                             which.theta="first",
                             state.or.type="state")
write.csv(theta.state, "theta.state_cellstate.csv")

# Make new directories
new_dir_name <- "CELL TYPE"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

new_dir_name <- "CELL STATE ORIGINAL"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

for (cell_type in levels(as.factor(cell.type.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "type", 
                      cell.name = cell_type)
  write.csv(exp_type, paste0("CELL TYPE/", cell_type, ".csv"))
}


for (cell_state in levels(as.factor(cell.state.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "state", 
                      cell.name = cell_state)
  write.csv(exp_type, paste0("CELL STATE ORIGINAL/", cell_state, ".csv"))
}
```

```{r code_2_bayesprism_2_baysprism_ftld_tdp_r, eval=FALSE}
library("ggplot2")
library("openxlsx")
library("dplyr")
library("coin")
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")
library("edgeR")
library("GO.db")
library("xlsx")
suppressWarnings(library("BayesPrism"))
suppressWarnings(library(org.Hs.eg.db))
library(dplyr) 
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")


################################################################################
# Single cell data
load("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData")
# Bulk data
bk.dat <-  read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv")
###############################################################################
#Set colnames and rownames
rownames(bk.dat)<-bk.dat[,1]
bk.dat <- bk.dat[,-1]
bk.dat <- t(bk.dat)

sc.dat <- t(merged@assays$Assay_name$counts)

A <- read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv")
A[44,"SubType" ] <- "T_Cell"
A[20,"SubType" ] <- "OPC"
A[19,"SubType" ] <- "Oligo"
A[18,"SubType" ] <- "Micro"

# Update metadata to take into account DGE groups.
merged@meta.data <- merged@meta.data %>%
  left_join(A, by = c("cellstate" = "SubType"))

# Cell type and state
cell.state.labels <- merged@meta.data$cellstate
cell.type.labels <- merged@meta.data$CellType
rm(merged)

# Pre-processing
plot.cor.phi (input=sc.dat, 
              input.labels=as.factor(cell.state.labels),
              title="cell state correlation",
              pdf.prefix="gbm.cor.cs",
              cexRow=0.2, 
              cexCol=0.2,
              margins=c(2,2)
)

plot.cor.phi (input=sc.dat,
              input.labels=as.factor(cell.type.labels),
              title="cell type correlation",
              pdf.prefix="gbm.cor.ct",
              cexRow=0.5, 
              cexCol=0.5,
)

sc.stat <- plot.scRNA.outlier(
  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID
  cell.type.labels=as.factor(cell.type.labels),
  species="hs", #currently only human(hs) and mouse(mm) annotations are supported
  return.raw=TRUE, #return the data used for plotting.
  pdf.prefix="SC_stats"
)
write.csv(sc.stat, "sc.stat.csv")

print("bk.stat")
bk.stat <- plot.bulk.outlier(
  bulk.input = bk.dat,
  sc.input = sc.dat,
  cell.type.labels = cell.type.labels,
  species = "hs",
  return.raw = TRUE,
  pdf.prefix = "BK_stats"
)
write.csv(bk.dat, "bk.stat.csv")


print("sc.stat.filtered")
sc.dat.filtered <- cleanup.genes (input=sc.dat,
                                  input.type="count.matrix",
                                  species="hs",
                                  gene.group=c( "Rb","Mrp","other_Rb","chrM","MALAT1","chrX","chrY") ,
                                  exp.cells=5
)
write.csv(sc.dat.filtered, "sc.dat.filtered.csv")

print("bk.stat.filtered")
plot.bulk.vs.sc (sc.input = sc.dat.filtered,
                 bulk.input = bk.dat,
                 pdf.prefix="Bulk_vs_Sc"
)

print("sc.dat.filtered.pc")
sc.dat.filtered.pc <- select.gene.type (sc.dat.filtered,
                                        gene.type = "protein_coding")
write.csv(sc.dat.filtered.pc, "sc.dat.filtered.pc.csv")

# SORT bk.dat so the colnames are sorted equaly in both tables. 
common_columns <- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))
bk.dat <- bk.dat[, common_columns]
sc.dat.filtered.pc <- sc.dat.filtered.pc[, common_columns]

rm(sc.dat)
rm(sc.dat.filtered)
rm(bk.stat)
rm(sc.stat)

myPrism <- new.prism(
  reference=sc.dat.filtered.pc,
  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),
  input.type="count.matrix",
  cell.type.labels = cell.type.labels,
  cell.state.labels = cell.state.labels,
  key=NULL,
  outlier.cut=0.01,
  outlier.fraction=0.1,
)
save(myPrism, file = "myPrism.RData")

bp.res <- run.prism(prism = myPrism, n.cores=50)
save(bp.res, file = "bp.res.RData")

theta <- get.fraction (bp=bp.res,
                       which.theta="final",
                       state.or.type="type")
write.csv(theta, "theta.csv")

theta.cv <- bp.res@posterior.theta_f@theta.cv
write.csv(theta.cv, "theta.cv.csv")

bp.res.initial <- run.prism(prism = myPrism, 
                            n.cores=50, 
                            update.gibbs=FALSE)
#save(bp.res.initial, file = "bp.res.initial.RData")
#bp.res.update <- update.theta (bp = bp.res.initial)
#save(bp.res.update, file = "bp.res.update.RData")

theta.state <- get.fraction (bp=bp.res.initial,
                             which.theta="first",
                             state.or.type="state")
write.csv(theta.state, "theta.state_original.csv")

# Make new directories
new_dir_name <- "CELL TYPE"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

new_dir_name <- "CELL STATE ORIGINAL"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

for (cell_type in levels(as.factor(cell.type.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "type", 
                      cell.name = cell_type)
  write.csv(exp_type, paste0("CELL TYPE/", cell_type, ".csv"))
}


for (cell_state in levels(as.factor(cell.state.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "state", 
                      cell.name = cell_state)
  write.csv(exp_type, paste0("CELL STATE ORIGINAL/", cell_state, ".csv"))
}
```

```{r code_2_bayesprism_2_baysprism_pottier_r, eval=FALSE}
library("ggplot2")
library("openxlsx")
library("dplyr")
library("coin")
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")
library("edgeR")
library("GO.db")
library("xlsx")
suppressWarnings(library("BayesPrism"))
suppressWarnings(library(org.Hs.eg.db))
library(dplyr) 
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")

################################################################################
# Single cell data
load("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData")
# Bulk data
bk.dat <-  read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv")
###############################################################################
#Set colnames and rownames
bk.dat<-bk.dat[, -c(1,2,3,4,5,7)]
bk.dat <- aggregate(. ~ GeneName, data = bk.dat, FUN = sum) # Aggregate rows with same gene
rownames(bk.dat)<-bk.dat[,1]
bk.dat <- bk.dat[,-1]
bk.dat <- t(bk.dat)


sc.dat <- t(merged@assays$Assay_name$counts)
# El matrix es el que dona problemes!!!!!!
#sc.dat <- t(as.matrix(merged@assays$Assay_name$counts))
A <- read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv")
A[44,"SubType" ] <- "T_Cell"
A[20,"SubType" ] <- "OPC"
A[19,"SubType" ] <- "Oligo"
A[18,"SubType" ] <- "Micro"


# Update metadata to take into account DGE groups.

merged@meta.data <- merged@meta.data %>%
  left_join(A, by = c("cellstate" = "SubType"))


# Cell type and state
cell.state.labels <- merged@meta.data$cellstate
cell.type.labels <- merged@meta.data$CellType
rm(merged)

# Pre-processing
plot.cor.phi (input=sc.dat, 
              input.labels=as.factor(cell.state.labels),
              title="cell state correlation",
              pdf.prefix="gbm.cor.cs",
              cexRow=0.2, 
              cexCol=0.2,
              margins=c(2,2)
)

plot.cor.phi (input=sc.dat,
              input.labels=as.factor(cell.type.labels),
              title="cell type correlation",
              pdf.prefix="gbm.cor.ct",
              cexRow=0.5, 
              cexCol=0.5,
)

sc.stat <- plot.scRNA.outlier(
  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID
  cell.type.labels=as.factor(cell.type.labels),
  species="hs", #currently only human(hs) and mouse(mm) annotations are supported
  return.raw=TRUE, #return the data used for plotting.
  pdf.prefix="SC_stats"
)
write.csv(sc.stat, "sc.stat.csv")

print("bk.stat")
bk.stat <- plot.bulk.outlier(
  bulk.input = bk.dat,
  sc.input = sc.dat,
  cell.type.labels = cell.type.labels,
  species = "hs",
  return.raw = TRUE,
  pdf.prefix = "BK_stats"
)
write.csv(bk.dat, "bk.stat.csv")


print("sc.stat.filtered")
sc.dat.filtered <- cleanup.genes (input=sc.dat,
                                  input.type="count.matrix",
                                  species="hs",
                                  gene.group=c( "Rb","Mrp","other_Rb","chrM","MALAT1","chrX","chrY") ,
                                  exp.cells=5
)
write.csv(sc.dat.filtered, "sc.dat.filtered.csv")

print("bk.stat.filtered")
plot.bulk.vs.sc (sc.input = sc.dat.filtered,
                 bulk.input = bk.dat,
                 pdf.prefix="Bulk_vs_Sc"
)

print("sc.dat.filtered.pc")
sc.dat.filtered.pc <- select.gene.type (sc.dat.filtered,
                                        gene.type = "protein_coding")
write.csv(sc.dat.filtered.pc, "sc.dat.filtered.pc.csv")

# SORT bk.dat so the colnames are sorted equaly in both tables. 
common_columns <- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))
bk.dat <- bk.dat[, common_columns]
sc.dat.filtered.pc <- sc.dat.filtered.pc[, common_columns]

rm(sc.dat)
rm(sc.dat.filtered)
rm(bk.stat)
rm(sc.stat)

myPrism <- new.prism(
  reference=sc.dat.filtered.pc,
  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),
  input.type="count.matrix",
  cell.type.labels = cell.type.labels,
  cell.state.labels = cell.state.labels,
  key=NULL,
  outlier.cut=0.01,
  outlier.fraction=0.1,
)
save(myPrism, file = "myPrism.RData")

bp.res <- run.prism(prism = myPrism, n.cores=50,)
save(bp.res, file = "bp.res.RData")

theta <- get.fraction (bp=bp.res,
                       which.theta="final",
                       state.or.type="type")
write.csv(theta, "theta.csv")

theta.cv <- bp.res@posterior.theta_f@theta.cv
write.csv(theta.cv, "theta.cv.csv")

bp.res.initial <- run.prism(prism = myPrism, 
                            n.cores=50, 
                            update.gibbs=FALSE)
save(bp.res.initial, file = "bp.res.initial.RData")
bp.res.update <- update.theta (bp = bp.res.initial)
save(bp.res.update, file = "bp.res.update.RData")

theta.state <- get.fraction (bp=bp.res.initial,
                             which.theta="first",
                             state.or.type="state")
write.csv(theta.state, "theta.state_cellstate.csv")

# Make new directories
new_dir_name <- "CELL TYPE"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

new_dir_name <- "CELL STATE ORIGINAL"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

for (cell_type in levels(as.factor(cell.type.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "type", 
                      cell.name = cell_type)
  write.csv(exp_type, paste0("CELL TYPE/", cell_type, ".csv"))
}


for (cell_state in levels(as.factor(cell.state.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "state", 
                      cell.name = cell_state)
  write.csv(exp_type, paste0("CELL STATE ORIGINAL/", cell_state, ".csv"))
}
```

```{r code_2_bayesprism_2_baysprism_rimod_r, eval=FALSE}
library("ggplot2")
library("openxlsx")
library("dplyr")
library("coin")
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")
library("edgeR")
library("GO.db")
library("xlsx")
suppressWarnings(library("BayesPrism"))
suppressWarnings(library(org.Hs.eg.db))
library(dplyr) 
library("AnnotationDbi")
library("org.Hs.eg.db")
library('EnsDb.Hsapiens.v86')
library("Seurat")




################################################################################
# Single cell data
load("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData")
# Bulk data
bk.dat <-  read.csv("/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv")
###############################################################################
#Set colnames and rownames
rownames(bk.dat)<-bk.dat[,1]
bk.dat <- bk.dat[,-1]
bk.dat <- t(bk.dat)

sc.dat <- t(merged@assays$Assay_name$counts)

A <- read.csv("/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv")
A[44,"SubType" ] <- "T_Cell"
A[20,"SubType" ] <- "OPC"
A[19,"SubType" ] <- "Oligo"
A[18,"SubType" ] <- "Micro"

# Update metadata to take into account DGE groups.
merged@meta.data <- merged@meta.data %>%
  left_join(A, by = c("cellstate" = "SubType"))

# Cell type and state
cell.state.labels <- merged@meta.data$cellstate
cell.type.labels <- merged@meta.data$CellType
rm(merged)

# Pre-processing
plot.cor.phi (input=sc.dat, 
              input.labels=as.factor(cell.state.labels),
              title="cell state correlation",
              pdf.prefix="gbm.cor.cs",
              cexRow=0.2, 
              cexCol=0.2,
              margins=c(2,2)
)

plot.cor.phi (input=sc.dat,
              input.labels=as.factor(cell.type.labels),
              title="cell type correlation",
              pdf.prefix="gbm.cor.ct",
              cexRow=0.5, 
              cexCol=0.5,
)

sc.stat <- plot.scRNA.outlier(
  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID
  cell.type.labels=as.factor(cell.type.labels),
  species="hs", #currently only human(hs) and mouse(mm) annotations are supported
  return.raw=TRUE, #return the data used for plotting.
  pdf.prefix="SC_stats"
)
write.csv(sc.stat, "sc.stat.csv")

print("bk.stat")
bk.stat <- plot.bulk.outlier(
  bulk.input = bk.dat,
  sc.input = sc.dat,
  cell.type.labels = cell.type.labels,
  species = "hs",
  return.raw = TRUE,
  pdf.prefix = "BK_stats"
)
write.csv(bk.dat, "bk.stat.csv")


print("sc.stat.filtered")
sc.dat.filtered <- cleanup.genes (input=sc.dat,
                                  input.type="count.matrix",
                                  species="hs",
                                  gene.group=c( "Rb","Mrp","other_Rb","chrM","MALAT1","chrX","chrY") ,
                                  exp.cells=5
)
write.csv(sc.dat.filtered, "sc.dat.filtered.csv")

print("bk.stat.filtered")
plot.bulk.vs.sc (sc.input = sc.dat.filtered,
                 bulk.input = bk.dat,
                 pdf.prefix="Bulk_vs_Sc"
)

print("sc.dat.filtered.pc")
sc.dat.filtered.pc <- select.gene.type (sc.dat.filtered,
                                        gene.type = "protein_coding")
write.csv(sc.dat.filtered.pc, "sc.dat.filtered.pc.csv")

# SORT bk.dat so the colnames are sorted equaly in both tables. 
common_columns <- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))
bk.dat <- bk.dat[, common_columns]
sc.dat.filtered.pc <- sc.dat.filtered.pc[, common_columns]

rm(sc.dat)
rm(sc.dat.filtered)
rm(bk.stat)
rm(sc.stat)

myPrism <- new.prism(
  reference=sc.dat.filtered.pc,
  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),
  input.type="count.matrix",
  cell.type.labels = cell.type.labels,
  cell.state.labels = cell.state.labels,
  key=NULL,
  outlier.cut=0.01,
  outlier.fraction=0.1,
)
save(myPrism, file = "myPrism.RData")

bp.res <- run.prism(prism = myPrism, n.cores=50)
save(bp.res, file = "bp.res.RData")

theta <- get.fraction (bp=bp.res,
                       which.theta="final",
                       state.or.type="type")
write.csv(theta, "theta.csv")

theta.cv <- bp.res@posterior.theta_f@theta.cv
write.csv(theta.cv, "theta.cv.csv")

bp.res.initial <- run.prism(prism = myPrism, 
                            n.cores=50, 
                            update.gibbs=FALSE)
save(bp.res.initial, file = "bp.res.initial.RData")
#bp.res.update <- update.theta (bp = bp.res.initial)
#save(bp.res.update, file = "bp.res.update.RData")

theta.state <- get.fraction (bp=bp.res.initial,
                             which.theta="first",
                             state.or.type="state")
write.csv(theta.state, "theta.state_cellstate.csv")

# Make new directories
new_dir_name <- "CELL TYPE"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

new_dir_name <- "CELL STATE ORIGINAL"
if (file.exists(new_dir_name)){
  print("", end = "")
} else {
  dir.create(new_dir_name)
}

for (cell_type in levels(as.factor(cell.type.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "type", 
                      cell.name = cell_type)
  write.csv(exp_type, paste0("CELL TYPE/", cell_type, ".csv"))
}


for (cell_state in levels(as.factor(cell.state.labels))){
  exp_type <- get.exp(bp = bp.res, 
                      state.or.type = "state", 
                      cell.name = cell_state)
  write.csv(exp_type, paste0("CELL STATE ORIGINAL/", cell_state, ".csv"))
}
```
