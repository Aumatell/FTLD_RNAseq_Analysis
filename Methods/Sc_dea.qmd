---
title: "Single cell differencial expression analysis"
---

# **Single-Cell Analysis**

Bulk RNA-seq differential expression identifies tissue-level transcriptional changes but cannot distinguish whether these alterations originate from specific neuronal subclasses, glial populations, or vascular/immune lineages. Because FTLD pathology is known to selectively affect distinct cortical cell populations—such as **RORB-expressing excitatory neurons**, subsets of **inhibitory neurons**, and diverse **astroglial** and **microglial** states—bulk analysis alone provides limited biological resolution.

To overcome this limitation, we leveraged the **cell-state–specific expression matrices** generated by **BayesPrism**, which infer gene-level expression for each of the 44 transcriptional states defined in the Pineda et al. single-nucleus reference. These matrices represent “pseudobulk” expression profiles for each cell state within each sample, enabling differential gene expression analysis at **single-cell resolution using bulk RNA-seq**.

Applying edgeR to these deconvolved matrices allows rigorous detection of transcriptional alterations **within individual cell states**, thereby identifying the precise cellular compartments responsible for disease-associated dysregulation in FTLD-C9 and FTLD-TDP.

## **Analytical Strategy**

### **1. Input Data: BayesPrism-Derived Cell-State Matrices**

For each sample, BayesPrism returned **cell-state–specific gene expression estimates** for all 43–44 states in the Pineda et al. reference. These matrices were:

-   aggregated per cell state across samples,

-   treated as pseudobulk counts,

used as direct input to edgeR differential expression workflows.

Only cell states with **sufficient expression and non-zero counts** across samples were retained for statistical modeling.

```{r}
library("edgeR")
library("dplyr")
library("GO.db")

# c9
CSV_DECONVOLDED_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL"
CASE_LEGEND <- "/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx"
SV_COVARIATE <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv"
OUTPUT_DIRECTORY <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV"

REFERENCE_GROUP <- "Healthy"

covariate_data <- read.csv(SV_COVARIATE)
covariate_data$sample.ID <- sub("^long", "", covariate_data$sample.ID)


csv_files <- list.files(CSV_DECONVOLDED_PATH, pattern = "\\.csv$", full.names = TRUE)

if (endsWith(CASE_LEGEND, ".csv")) {
  case_legend <- read.csv(CASE_LEGEND)
  case_legend$group_ID <- as.factor(case_legend$group.ID)
  case_legend$group.ID <- NULL
} else if (endsWith(CASE_LEGEND, ".xlsx")) {
  case_legend <- readxl::read_xlsx(CASE_LEGEND)
  case_legend$group_ID <- as.factor(case_legend$group.ID)
  case_legend$group2_ID <- as.factor(case_legend$group2.ID)
  case_legend$group2.ID <- NULL
  case_legend$group.ID <- NULL
} else {
  # Handle other cases or file types
  print("File type not recognized.")
}

case_legend$group2_ID <- droplevels(case_legend$group2_ID)
case_legend$group_ID <- as.character(case_legend$group_ID)
case_legend$group_ID <- as.factor(case_legend$group_ID)
case_legend$group_ID <- droplevels(case_legend$group_ID)

conditions <- levels(case_legend$group_ID)
if (REFERENCE_GROUP %in% conditions) {
  conditions <- conditions[conditions != REFERENCE_GROUP]
}
if (!file.exists(OUTPUT_DIRECTORY)) {
  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)
}

matrix_data <- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))

# Create a DataFrame with the matrix data, specifying column and row names
df <- data.frame(matrix_data, row.names = conditions)
colnames(df) <- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))

```

### **2. Preprocessing and Gene Filtering**

For each cell state:

-   Genes with zero or near-zero counts were removed.

-   Only transcripts expressed in ≥1 sample were kept.

-   Mitochondrial, ribosomal, and sex-chromosome genes had already been removed at the BayesPrism stage.

-   average CPM

-   normalization

This ensured that differential expression reflected biologically meaningful changes rather than sparsity-related artifacts.

```{r}
comparison_data <- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]
      comparison_data$group_ID <- factor(comparison_data$group_ID)
      
      comparison_data$SV1 <- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]
      
      comparison_data$group_ID <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data <- comparison_data[order(comparison_data$group_ID), ]
      
      common_ids <- intersect(comparison_data$sample.ID, rownames(data))
      data_subset <- data[rownames(data) %in% common_ids, ]
      data_ordered <- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]
      # CLEAN NA
      data_ordered[!is.finite(as.matrix(data_ordered))] <- 0
      data_ordered <- data_ordered[complete.cases(data_ordered), ]
      comparison_data <- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]
      
      group <- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])
      y <- DGEList(counts=t(data_ordered),group=group)
      y <- y[, colSums(y$counts) > 0]
      # Keep only samples in comparison_data that are in y
      comparison_data <- comparison_data[match(colnames(y), comparison_data$sample.ID), ]
      
      # Average Log CPM histogram
      AveLogCPM <- aveLogCPM(y)
      y <- normLibSizes(y)
  
```

### **3. Modeling Latent Sources of Variation**

To account for unwanted technical and biological variability:

-   **Surrogate variables (SVs)** estimated from the bulk RNA-seq data were included as covariates in the design matrix, controlling for batch-like or hidden confounders.

This approach improves statistical robustness, especially in modest sample sizes typical of post-mortem FTLD cohorts.

```{r}
   group <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data$group_ID <- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)
      design <- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)
      colnames(design) <- c(REFERENCE_GROUP, condition, "SV1")
      nrow(design) == ncol(y)
      
      # DISPERSION ESTIMATION
      y <- estimateDisp(y,design)
      fit <- glmFit(y,design)
  
      
```

### **4. Differential Expression Testing**

For each of the 43–44 cell states:

-   A design matrix modeled diagnostic status (FTLD-C9 or FTLD-TDP) with **Healthy** as the reference level.

-   A single contrast per cell state tested the effect of disease.

-   The **glmLRT()** framework was applied.

Multiple-testing correction within each cell state was performed using **Benjamini–Hochberg FDR**, with significance defined as:

-   **FDR \< 0.05**

For each significant gene, the following metrics were extracted:

-   log2 fold change

-   raw p-value and FDR-adjusted p-value

-   average CPM per condition

```{r}
     # Diferential expression analysis
      B.LvsP <- makeContrasts(paste0(condition, " - ", REFERENCE_GROUP), levels=design)
      res <- glmLRT(fit, contrast=B.LvsP)
      is.de <- decideTests(res, adjust.method = "fdr", p.value = 0.05, lfc= 0)
      results_table <- res$table
      results_table$adj_pval <- p.adjust(results_table$PValue, method = "fdr", n = length(results_table$PValue))
      results_table <- cbind(results_table, data.frame(is.de))
      # SAVING CSV RESULTS
      write.csv(res$table, file = file.path(condition_folder, "res_h.csv"))
      write.csv(results_table, file = file.path(condition_folder, "results_adj_h.csv"))
      
```

### **5. Validation Across Independent Cohorts**

To assess reproducibility:

-   Cell-state DEGs from the Sant Pau FTLD-C9 dataset were compared with those from the **Menden et al.** dataset.

-   Cell-state DEGs from the Sant Pau FTLD-TDP dataset were compared with the **Pottier et al.** cohort.

Overlap significance was quantified using:

-   **GeneOverlap statistics**

-   **Jaccard indices**

This allowed identification of **robust cell-state–specific signatures** conserved across cohorts.

```{r}
# JACCARD 
library("openxlsx")
library("GeneOverlap")
library("VennDiagram")
library("grid")

# Define functions
# Jaccard similarity index
jaccard_similarity <- function(list1, list2) {
  intersection_size <- length(intersect(list1, list2))
  union_size <- length(union(list1, list2))
  return(intersection_size / union_size)
}

# Perform permutation test for p-value
permutation_test <- function(list1, list2, n_permutations = 10000) {
  observed_jaccard <- jaccard_similarity(list1, list2)
  
  permuted_jaccards <- replicate(n_permutations, {
    permuted_list1 <- sample(list1)
    permuted_list2 <- sample(list2)
    jaccard_similarity(permuted_list1, permuted_list2)
  })
  p_value <- mean(permuted_jaccards >= observed_jaccard)
  return(p_value)
}

hypergeometric_test <- function(list1, list2, total_population_size) {
  intersection_size <- length(intersect(list1, list2))
  total_genes <- total_population_size  # Total number of possible genes
  
  # Number of DEGs in list1 and list2
  K1 <- length(list1)
  K2 <- length(list2)
  
  # Hypergeometric test to calculate p-value
  p_value <- phyper(intersection_size - 1, K1, total_genes - K1, K2, lower.tail = FALSE)
  
  return(p_value)
}


# TDP43

# Define variables
CStates <- c(
  "Arterial", "DISC1_RELN", "Pericyte", "SMC", "TLE4_CCBE1",
  "Capillary", "GFAP-neg", "PVALB_CEMIP", "SST_ADAMTS19", "TLE4_MEGF11",
  "CDH4_CCK", "GFAP-pos", "PVALB_MYBPC1", "SST_BRINP3", "TLE4_SEMA3D",
  "CDH4_SCGN", "LAMP5_CA3", "PVALB_PTHLH", "SST_GALNT14", "VAT1L_EYA4",
  "CLMP_KCNMA1", "LAMP5_PMEPA1", "RORB_ADGRL4", "SST_NPY", "Venous",
  "CLMP_PDGFRA", "Micro", "RORB_FOXO1", "VIP_CLSTN2",
  "CUX2_RASGRF2", "Oligo", "RORB_LRRK1", "T_Cell", "VIP_HTR2C",
  "CUX2_RORB", "OPC", "RORB_POU3F2", "THEMIS_NR4A2", "VIP_LAMA3",
  "DISC1_CCK", "PCP4_NXPH2", "SCN4B_NEFH", "THEMIS_TMEM233"
)

FTLD_TDP <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/CS_LRT/"
NOU <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect/"
RESULTS_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/TDP_NEW/CS_Correcte"

# Generate output dataframe
Results <- data.frame(matrix(ncol = length(CStates), nrow = 10))
colnames(Results) <- CStates
rownames(Results) <- c(
  "Upregulated FTLD_TDP", "Upregulated Nou", 
  "Downregulated FTLD_TDP", "Downregulated Nou",
  "CU FTLD – Nou", "CD FTLD – Nou", 
  "JU FTLD – Nou", "JD FTLD – Nou",
  "GU FTLD – Nou", "GD FTLD – Nou")

# Iterate to obtain the results for each case.
for (i in seq_along(CStates)) {
  CS <- CStates[i]
    # Read data
  if (file.exists(paste0(FTLD_TDP, CS ,"/", "TDP/results_adj_h.csv"))){
    ftld_tdp <- read.csv(paste0(FTLD_TDP, CS ,"/", "TDP/results_adj_h.csv"))
  } else {
    ftld_tdp <- c()
  }
  
  if (file.exists(paste0(NOU,CS,"/" ,"TDP/results_adj_h.csv"))){
    nou <- read.csv(paste0(NOU,CS,"/" ,"TDP/results_adj_h.csv"))
  } else {
    nou <- c()
  }
  
  # Extract DEG

  # For U_ftld
  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1])) {
    U_ftld <- character(0)  # Assign an empty vector if NULL
  } else {
    U_ftld <- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1]
  }
  
  # For U_nou
  if (is.null(nou$X[nou$X.1.Control.1.TDP == 1])) {
    U_nou <- character(0)  # Assign an empty vector if NULL
  } else {
    U_nou <- nou$X[nou$X.1.Control.1.TDP == 1]
  }
  
  # For D_ftld
  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1])) {
    D_ftld <-character(0)  # Assign an empty vector if NULL
  } else {
    D_ftld <- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1]
  }
  
  # For D_nou
  if (is.null(nou$X[nou$X.1.Control.1.TDP == -1])) {
    D_nou <-character(0) # Assign an empty vector if NULL
  } else {
    D_nou <- nou$X[nou$X.1.Control.1.TDP == -1]
  }
  
  # OVERLAP GENES
  C_U_ftld_nou <- intersect(U_ftld, U_nou)
  C_D_ftld_nou <- intersect(D_ftld, D_nou)

  # SIMILARITY INDEX
  Ujaccard13 <- jaccard_similarity(U_ftld, U_nou)
  Djaccard13 <- jaccard_similarity(D_ftld, D_nou)

  # HIPERGEOMETRIC TESTS
  total_genes_FN <- length(unique(c(ftld_tdp$X, nou$X)))

  # Gene Overlap
  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval
  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval

  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.
  Results["Upregulated FTLD_TDP", CS] <- length(U_ftld)
  Results["Upregulated Nou", CS] <- length(U_nou)
  Results["Downregulated FTLD_TDP", CS] <- length(D_ftld)
  Results["Downregulated Nou", CS] <- length(D_nou)
  Results["CU FTLD – Nou", CS] <- length(C_U_ftld_nou)
  Results["CD FTLD – Nou", CS] <- length(C_D_ftld_nou)
  Results["JU FTLD – Nou", CS] <- Ujaccard13
  Results["JD FTLD – Nou", CS] <- Djaccard13
  Results["GU FTLD – Nou", CS] <- GU_13
  Results["GD FTLD – Nou", CS] <- GD_13
  
}
Results <- t(Results)
View(Results)
View(Results[rowSums(Results[, 1:4]) > 0, ])

write.csv(Results, file = paste0(RESULTS_PATH, "/TDP43_Validation_results_cs.csv"))

```

```{r}
# C9

FTLD_TDP <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV/"
NOU <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV/"
RESULTS_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/C9_NEW/CS"

# Generate output dataframe
Results <- data.frame(matrix(ncol = length(CStates), nrow = 10))
colnames(Results) <- CStates
rownames(Results) <- c(
  "Upregulated FTLD_TDP", "Upregulated Rimod", 
  "Downregulated FTLD_TDP", "Downregulated Rimod",
  "CU FTLD – Rimod", "CD FTLD – Rimod", 
  "JU FTLD – Rimod", "JD FTLD – Rimod",
  "GU FTLD – Rimod", "GD FTLD – Rimod")

# Iterate to obtain the results for each case.
for (i in seq_along(CStates)) {
  CS <- CStates[i]
  # Read data
  if (file.exists(paste0(FTLD_TDP, CS ,"/", "C9orf72/results_adj_h.csv"))){
    ftld_tdp <- read.csv(paste0(FTLD_TDP, CS ,"/", "C9orf72/results_adj_h.csv"))
  } else {
    ftld_tdp <- c()
  }
  
  if (file.exists(paste0(NOU,CS,"/" ,"C9orf72/results_adj_h.csv"))){
    nou <- read.csv(paste0(NOU,CS,"/" ,"C9orf72/results_adj_h.csv"))
  } else {
    nou <- c()
  }
  
  # Extract DEG
  
  # For U_ftld
  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1])) {
    U_ftld <- character(0)  # Assign an empty vector if NULL
  } else {
    U_ftld <- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1]
  }
  
  # For U_nou
  if (is.null(nou$X[nou$X.1.Healthy.1.C9orf72 == 1])) {
    U_nou <- character(0)  # Assign an empty vector if NULL
  } else {
    U_nou <- nou$X[nou$X.1.Healthy.1.C9orf72 == 1]
  }
  
  # For D_ftld
  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1])) {
    D_ftld <-character(0)  # Assign an empty vector if NULL
  } else {
    D_ftld <- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1]
  }
  
  # For D_nou
  if (is.null(nou$X[nou$X.1.Healthy.1.c9orf72 == -1])) {
    D_nou <-character(0) # Assign an empty vector if NULL
  } else {
    D_nou <- nou$X[nou$X.1.Healthy.1.C9orf72 == -1]
  }
  
  # OVERLAP GENES
  C_U_ftld_nou <- intersect(U_ftld, U_nou)
  C_D_ftld_nou <- intersect(D_ftld, D_nou)
  
  # SIMILARITY INDEX
  Ujaccard13 <- jaccard_similarity(U_ftld, U_nou)
  Djaccard13 <- jaccard_similarity(D_ftld, D_nou)
  
  # HIPERGEOMETRIC TESTS
  total_genes_FN <- length(unique(c(ftld_tdp$X, nou$X)))
  
  # Gene Overlap
  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval
  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval
  
  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.
  Results["Upregulated FTLD_TDP", CS] <- length(U_ftld)
  Results["Upregulated Rimod", CS] <- length(U_nou)
  Results["Downregulated FTLD_TDP", CS] <- length(D_ftld)
  Results["Downregulated Rimod", CS] <- length(D_nou)
  Results["CU FTLD – Rimod", CS] <- length(C_U_ftld_nou)
  Results["CD FTLD – Rimod", CS] <- length(C_D_ftld_nou)
  Results["JU FTLD – Rimod", CS] <- Ujaccard13
  Results["JD FTLD – Rimod", CS] <- Djaccard13
  Results["GU FTLD – Rimod", CS] <- GU_13
  Results["GD FTLD – Rimod", CS] <- GD_13
  
}
Results <- t(Results)
View(Results)
View(Results[rowSums(Results[, 1:4]) > 0, ])
write.csv(Results, file = paste0(RESULTS_PATH, "/C9_Validation_results_cs.csv"))
```

## **Analytical Goals of the Single-Cell–Resolved Differential Expression Analysis**

The single-cell differential expression module was designed to:

1.  **Identify the precise cell states driving disease-specific transcriptional alterations** in FTLD-C9 and FTLD-TDP.

2.  **Distinguish neuronal and glial subtypes with high DEG burden**, pointing to selective cellular vulnerability.

3.  **Characterize lineage-specific pathways**, such as synaptic dysfunction in RORB neurons or inflammatory activation in GFAP+ astrocytes.

4.  **Link transcriptional changes to neuropathological markers**, including STMN2 loss, pTDP-43 burden, and DPR/RNA foci density.

5.  **Enable functional enrichment (GO/Metascape)** for each cell state, revealing discrete biological processes altered in disease.

6.  **Provide a unified cellular framework** for comparing FTLD-C9 and FTLD-TDP, facilitating identification of shared and divergent mechanisms.

7.  **Support robust cross-validation** with independent datasets, increasing confidence in the generalizability of cell-state transcriptional signatures.

```{r code_5_cell_type_dea_5_dea_ftld_c9_r, eval=FALSE}
library("edgeR")
library("dplyr")
library("GO.db")

# c9
CSV_DECONVOLDED_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL"
CASE_LEGEND <- "/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx"
SV_COVARIATE <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv"
OUTPUT_DIRECTORY <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV"

REFERENCE_GROUP <- "Healthy"

covariate_data <- read.csv(SV_COVARIATE)
covariate_data$sample.ID <- sub("^long", "", covariate_data$sample.ID)


csv_files <- list.files(CSV_DECONVOLDED_PATH, pattern = "\\.csv$", full.names = TRUE)

if (endsWith(CASE_LEGEND, ".csv")) {
  case_legend <- read.csv(CASE_LEGEND)
  case_legend$group_ID <- as.factor(case_legend$group.ID)
  case_legend$group.ID <- NULL
} else if (endsWith(CASE_LEGEND, ".xlsx")) {
  case_legend <- readxl::read_xlsx(CASE_LEGEND)
  case_legend$group_ID <- as.factor(case_legend$group.ID)
  case_legend$group2_ID <- as.factor(case_legend$group2.ID)
  case_legend$group2.ID <- NULL
  case_legend$group.ID <- NULL
} else {
  print("File type not recognized.")
}

case_legend$group2_ID <- droplevels(case_legend$group2_ID)
case_legend$group_ID <- as.character(case_legend$group_ID)
case_legend$group_ID <- as.factor(case_legend$group_ID)
case_legend$group_ID <- droplevels(case_legend$group_ID)

conditions <- levels(case_legend$group_ID)
if (REFERENCE_GROUP %in% conditions) {
  conditions <- conditions[conditions != REFERENCE_GROUP]
}
if (!file.exists(OUTPUT_DIRECTORY)) {
  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)
}

matrix_data <- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))

# Create a DataFrame with the matrix data, specifying column and row names
df <- data.frame(matrix_data, row.names = conditions)
colnames(df) <- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))


for (file in csv_files){
  filename <- tools::file_path_sans_ext(basename(file))
  print(filename)
  
  data <- read.csv(file, row.names=1)
  rownames(data) <- sub("^long", "", rownames(data))
  rownames(data) <- sub("X", "", rownames(data))
  celltype_folder <- file.path(OUTPUT_DIRECTORY, filename)

  if (!file.exists(celltype_folder)) {
    dir.create(celltype_folder, recursive = TRUE)
  }
  
  conditions <- "C9orf72"
  for (condition in conditions){
    
    print(condition)
    condition_folder <- file.path(celltype_folder, condition)
    if (!file.exists(condition_folder)) {
      dir.create(condition_folder, recursive = TRUE)
    }
    
    tryCatch({
      results_table <- NULL
      res <- NULL
      comparison_data <- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]
      comparison_data$group_ID <- factor(comparison_data$group_ID)
      
      comparison_data$SV1 <- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]
      
      comparison_data$group_ID <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data <- comparison_data[order(comparison_data$group_ID), ]
      
      common_ids <- intersect(comparison_data$sample.ID, rownames(data))
      data_subset <- data[rownames(data) %in% common_ids, ]
      data_ordered <- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]
      # CLEAN NA
      data_ordered[!is.finite(as.matrix(data_ordered))] <- 0
      data_ordered <- data_ordered[complete.cases(data_ordered), ]
      comparison_data <- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]
      
      group <- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])
      y <- DGEList(counts=t(data_ordered),group=group)
      y <- y[, colSums(y$counts) > 0]
      # Keep only samples in comparison_data that are in y
      comparison_data <- comparison_data[match(colnames(y), comparison_data$sample.ID), ]
      
      # Average Log CPM histogram
      AveLogCPM <- aveLogCPM(y)
      y <- normLibSizes(y)
      
      # MD plot
      plot_filename <- file.path(condition_folder, "MD_plot_h.png")
      png(file = plot_filename)
      MD_plot <- plotMD(y, column=1) +
        abline(h=0, col="red", lty=2, lwd=2)
      dev.off()
      
      # DESIGN MATRIX
      group <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data$group_ID <- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)
      design <- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)
      colnames(design) <- c(REFERENCE_GROUP, condition, "SV1")
      nrow(design) == ncol(y)
      
      # DISPERSION ESTIMATION
      y <- estimateDisp(y,design)
      fit <- glmFit(y,design)
      
      # Diferential expression analysis
      B.LvsP <- makeContrasts(paste0(condition, " - ", REFERENCE_GROUP), levels=design)
      res <- glmLRT(fit, contrast=B.LvsP)
      is.de <- decideTests(res, adjust.method = "fdr", p.value = 0.05, lfc= 0)
      results_table <- res$table
      results_table$adj_pval <- p.adjust(results_table$PValue, method = "fdr", n = length(results_table$PValue))
      results_table <- cbind(results_table, data.frame(is.de))
      # SAVING CSV RESULTS
      write.csv(res$table, file = file.path(condition_folder, "res_h.csv"))
      write.csv(results_table, file = file.path(condition_folder, "results_adj_h.csv"))
      
      ## Visualizations
      # "Volcano like" plot
      plot_filename <- file.path(condition_folder, "MD_res_plot_h.png")
      png(file = plot_filename)
      plotMD(res, status=is.de)
      dev.off()
      
      # Heatmap clustering 
      logCPM <- cpm(y, prior.count=2, log=TRUE)
      rownames(logCPM) <- y$genes$Symbol
      colnames(logCPM) <- paste(y$samples$group, 1:2, sep="-")
      tr <- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))
      o <- order(tr$table$PValue)
      logCPM <- logCPM[o[1:30],]
      
      plot_filename <- file.path(condition_folder, "Heatmap_h.png")
      png(file = plot_filename)
      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))
      dev.off()
      
      df[condition, tools::file_path_sans_ext(basename(file))] <- nrow(results_table[results_table$adj_pval<0.05,])
      
    }, error = function(e){
      df[condition, tools::file_path_sans_ext(basename(file))] <- 0
    })
  }
}

write.csv(df, file = file.path(OUTPUT_DIRECTORY, "summary_h.csv"))
```

```{r code_5_cell_type_dea_5_dea_ftld_tdp_r, eval=FALSE}
library(edgeR, lib.loc = "/home/jaumatell/R/x86_64-pc-linux-gnu-library/4.4/edgeR_4")
library("dplyr")
library("GO.db")
library("xlsx")
################################################################################
# Paths and parameters
CSV_DECONVOLDED_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE/"
CASE_LEGEND <- "/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx"
OUTPUT_DIRECTORY <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/DEG"
REFERENCE_GROUP <- "Healthy"
################################################################################

csv_files <- list.files(CSV_DECONVOLDED_PATH, pattern = "\\.csv$", full.names = TRUE)

# Read case legend and prepare group IDs
case_legend <- read.xlsx(CASE_LEGEND,sheetIndex = 1)
case_legend$group_ID <- factor(case_legend$group.ID)
case_legend$group.ID <- NULL

# Ensure levels are consistent and drop unused levels
conditions <- levels(as.factor(case_legend$group_ID))
conditions <- "TDP"

# Create output directory if it doesn't exist
if (!file.exists(OUTPUT_DIRECTORY)) {
  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)
}

# Initialize summary matrix
matrix_data <- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))
df <- data.frame(matrix_data, row.names = conditions)
colnames(df) <- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))

# Process each CSV file
for (file in csv_files) {
  filename <- tools::file_path_sans_ext(basename(file))
  print(filename)
  
  data <- read.csv(file, row.names = 1)
  rownames(data) <-gsub("X", "", rownames(data))
  celltype_folder <- file.path(OUTPUT_DIRECTORY, filename)
  if (!file.exists(celltype_folder)) {
    dir.create(celltype_folder, recursive = TRUE)
  }
  
  for (condition in conditions) {
    condition_folder <- file.path(celltype_folder, condition)
    if (!file.exists(condition_folder)) {
      dir.create(condition_folder, recursive = TRUE)
    }
    
    tryCatch({
      results_table <- NULL
      res <- NULL
      
      comparison_data <- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]
      comparison_data$group_ID <- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)
      comparison_data <- comparison_data[order(comparison_data$group_ID), ]
      
      common_ids <- intersect(comparison_data$sample.ID, rownames(data))
      data_subset <- data[rownames(data) %in% common_ids, ]
      data_ordered <- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]
      data_ordered[is.na(data_ordered)] <- 10e-8
      
      group <- factor(comparison_data$group_ID)
      y <- DGEList(counts = t(data_ordered), group = group)
      
      # Plot average log CPM
      AveLogCPM <- aveLogCPM(y)
      y <- normLibSizes(y)
      
      plot_filename <- file.path(condition_folder, "MD_plot_h.png")
      png(file = plot_filename)
      plotMD(y, column = 1)
      abline(h = 0, col = "red", lty = 2, lwd = 2)
      dev.off()
      
      # Create design matrix
      design <- model.matrix(~ 0 + group)
      colnames(design) <- levels(group)
      
      # Estimate dispersion
      y <- estimateDisp(y, design)
      fit <- glmFit(y, design)
      
      #Differential expression analysis
      contrast <- makeContrasts(contrasts = paste0(make.names(condition), " - ", make.names(REFERENCE_GROUP)), levels = design)
      res <- glmLRT(fit, contrast = contrast)
      is.de <- decideTests(res, adjust.method = "fdr", p.value = 0.05, lfc = 0)
      results_table <- res$table
      results_table$adj_pval <- p.adjust(results_table$PValue, method = "fdr")
      results_table <- cbind(results_table, data.frame(is.de))
      
      # Save results
      write.csv(res$table, file = file.path(condition_folder, "res_h.csv"))
      write.csv(results_table, file = file.path(condition_folder, "results_adj_h.csv"))
      
      # Histogram
      plot_filename <- file.path(condition_folder, "histogram_plot_h.png")
      png(file = plot_filename)
      hist(AveLogCPM)
      dev.off()
      
      # BCV plot
      plot_filename <- file.path(condition_folder, "BCV_plot_h.png")
      png(file = plot_filename)
      plotBCV(y)
      dev.off()
      
      # "Volcano like" plot
      plot_filename <- file.path(condition_folder, "MD_res_plot_h.png")
      png(file = plot_filename)
      plotMD(res, status = is.de)
      dev.off()
      
      # Heatmap clustering
      logCPM <- cpm(y, prior.count = 2, log = TRUE)
      colnames(logCPM) <- paste(y$samples$group, 1:2, sep = "-")
      tr <- glmTreat(fit, contrast = contrast, lfc = log2(1.5))
      o <- order(tr$table$PValue)
      logCPM <- logCPM[o[1:30], ]
      
      plot_filename <- file.path(condition_folder, "Heatmap_h.png")
      png(file = plot_filename)
      coolmap(logCPM, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))
      dev.off()
      
      # Update summary DataFrame
      df[condition, filename] <- nrow(results_table[results_table$adj_pval < 0.05, ])
      
    }, error = function(e) {
      print(e)
      df[condition, filename] <- 0
    })
  }
}

# Save summary DataFrame
write.csv(df, file = file.path(OUTPUT_DIRECTORY, "summary_h.csv"))
```

```{r code_5_cell_type_dea_5_dea_rimmod_r, eval=FALSE}
library("edgeR")
library("dplyr")
library("GO.db")
library("xlsx")
################################################################################
# Paths and parameters
CSV_DECONVOLDED_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/CELL STATE ORIGINAL/"
CASE_LEGEND <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt"
OUTPUT_DIRECTORY <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV"
SV_COVARIATE <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv"

REFERENCE_GROUP <- "Healthy"
################################################################################

covariate_data <- read.csv(SV_COVARIATE, sep = "\t")
covariate_data$sample.ID <- sub("^long", "", covariate_data$ID)

csv_files <- list.files(CSV_DECONVOLDED_PATH, pattern = "\\.csv$", full.names = TRUE)

# Read case legend and prepare group IDs
case_legend <- read.delim(CASE_LEGEND)
case_legend <- case_legend[case_legend$DiseaseCode %in% c("control", "FTD-C9"), ]

# 2. Renombrar valores dentro de DiseaseCode
case_legend$DiseaseCode[case_legend$DiseaseCode == "control"] <- "Healthy"
case_legend$DiseaseCode[case_legend$DiseaseCode == "FTD-C9"] <- "C9orf72"

case_legend$group_ID <- factor(case_legend$DiseaseCode)
case_legend$group.ID <- NULL

# Ensure levels are consistent and drop unused levels
conditions <- levels(as.factor(case_legend$group_ID))
conditions <- "C9orf72"

# Create output directory if it doesn't exist
if (!file.exists(OUTPUT_DIRECTORY)) {
  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)
}

# Initialize summary matrix
matrix_data <- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))
df <- data.frame(matrix_data, row.names = conditions)
colnames(df) <- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))

# Process each CSV file
for (file in csv_files) {
  filename <- tools::file_path_sans_ext(basename(file))
  print(filename)
  
  data <- read.csv(file, row.names = 1)
  celltype_folder <- file.path(OUTPUT_DIRECTORY, filename)
  if (!file.exists(celltype_folder)) {
    dir.create(celltype_folder, recursive = TRUE)
  }
  
  for (condition in conditions) {
    condition_folder <- file.path(celltype_folder, condition)
    if (!file.exists(condition_folder)) {
      dir.create(condition_folder, recursive = TRUE)
    }
    
    tryCatch({
      results_table <- NULL
      res <- NULL
      comparison_data <- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]
      comparison_data$group_ID <- factor(comparison_data$group_ID)
      
      comparison_data$SV1 <- covariate_data$SV1[match(comparison_data$RimodID, covariate_data$ID)]

      comparison_data$group_ID <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data <- comparison_data[order(comparison_data$group_ID), ]
      common_ids <- intersect(comparison_data$RimodID, rownames(data))
      data_subset <- data[rownames(data) %in% common_ids, ]
      data_ordered <- data_subset[match(comparison_data$RimodID, rownames(data_subset)), ]
      # CLEAN NA
      data_ordered[!is.finite(as.matrix(data_ordered))] <- 0
      data_ordered <- data_ordered[complete.cases(data_ordered), ]
      comparison_data <- comparison_data[match(rownames(data_ordered), comparison_data$RimodID), ]
      
      group <- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])
      y <- DGEList(counts=t(data_ordered),group=group)
      y <- y[, colSums(y$counts) > 0]
      # Keep only samples in comparison_data that are in y
      comparison_data <- comparison_data[match(colnames(y), comparison_data$RimodID), ]
      
      # Average Log CPM histogram
      AveLogCPM <- aveLogCPM(y)
      y <- normLibSizes(y)
      
      # MD plot
      plot_filename <- file.path(condition_folder, "MD_plot_h.png")
      png(file = plot_filename)
      MD_plot <- plotMD(y, column=1) +
        abline(h=0, col="red", lty=2, lwd=2)
      dev.off()
      
      # DESIGN MATRIX
      group <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data$group_ID <- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)
      design <- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)
      colnames(design) <- c(REFERENCE_GROUP, condition, "SV1")
      nrow(design) == ncol(y)
      
      # DISPERSION ESTIMATION
      y <- estimateDisp(y,design)
      fit <- glmFit(y,design)
      
      # Diferential expression analysis
      B.LvsP <- makeContrasts(paste0(condition, " - ", REFERENCE_GROUP), levels=design)
      res <- glmLRT(fit, contrast=B.LvsP)
      is.de <- decideTests(res, adjust.method = "fdr", p.value = 0.05, lfc= 0)
      results_table <- res$table
      results_table$adj_pval <- p.adjust(results_table$PValue, method = "fdr", n = length(results_table$PValue))
      results_table <- cbind(results_table, data.frame(is.de))
      # SAVING CSV RESULTS
      write.csv(res$table, file = file.path(condition_folder, "res_h.csv"))
      write.csv(results_table, file = file.path(condition_folder, "results_adj_h.csv"))
      ## Visualizations
      # "Volcano like" plot
      plot_filename <- file.path(condition_folder, "MD_res_plot_h.png")
      png(file = plot_filename)
      plotMD(res, status=is.de)
      dev.off()
      
      # Heatmap clustering 
      logCPM <- cpm(y, prior.count=2, log=TRUE)
      rownames(logCPM) <- y$genes$Symbol
      colnames(logCPM) <- paste(y$samples$group, 1:2, sep="-")
      tr <- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))
      o <- order(tr$table$PValue)
      logCPM <- logCPM[o[1:30],]
      
      plot_filename <- file.path(condition_folder, "Heatmap_h.png")
      png(file = plot_filename)
      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))
      dev.off()
      
      df[condition, tools::file_path_sans_ext(basename(file))] <- nrow(results_table[results_table$adj_pval<0.05,])
      
    }, error = function(e){
      df[condition, tools::file_path_sans_ext(basename(file))] <- 0
    })
  }
}

# Save summary DataFrame
write.csv(df, file = file.path(OUTPUT_DIRECTORY, "summary_h.csv"))
```

```{r code_5_cell_type_dea_5_edger_sv_pottier_r, eval=FALSE}

library("edgeR")
library("dplyr")
library("GO.db")

# FTD
#CT
CSV_DECONVOLDED_PATH <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/NEW/CELL STATE ORIGINAL"
CASE_LEGEND <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt"
SV_COVARIATE <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv"
OUTPUT_DIRECTORY <- "/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect"

REFERENCE_GROUP <- "Control"

covariate_data <- read.delim(SV_COVARIATE)
covariate_data$sample.ID <- sub("^long", "", covariate_data$ID)


csv_files <- list.files(CSV_DECONVOLDED_PATH, pattern = "\\.csv$", full.names = TRUE)


case_legend <- read.delim(CASE_LEGEND)
case_legend <- case_legend[case_legend$GROUP != "FTLD-TDP-C",]
case_legend$GROUP[case_legend$GROUP != "Control"] <- "TDP"
case_legend$group_ID <- as.factor(case_legend$GROUP)


conditions <- levels(case_legend$group_ID)
if (REFERENCE_GROUP %in% conditions) {
  conditions <- conditions[conditions != REFERENCE_GROUP]
}
if (!file.exists(OUTPUT_DIRECTORY)) {
  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)
}

matrix_data <- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))

# Create a DataFrame with the matrix data, specifying column and row names
df <- data.frame(matrix_data, row.names = conditions)
colnames(df) <- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))


for (file in csv_files){
  filename <- tools::file_path_sans_ext(basename(file))
  print(filename)
  
  data <- read.csv(file, row.names=1)
  rownames(data) <- sub("^long", "", rownames(data))
  rownames(data) <- sub("X", "", rownames(data))
  celltype_folder <- file.path(OUTPUT_DIRECTORY, filename)
  
  if (!file.exists(celltype_folder)) {
    dir.create(celltype_folder, recursive = TRUE)
  }
  
  for (condition in conditions){
    condition <- "TDP"
    print(condition)
    condition_folder <- file.path(celltype_folder, condition)
    if (!file.exists(condition_folder)) {
      dir.create(condition_folder, recursive = TRUE)
    }
    
    tryCatch({
      results_table <- NULL
      res <- NULL
      comparison_data <- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]
      comparison_data$group_ID <- factor(comparison_data$group_ID)
      
      comparison_data$SV1 <- covariate_data$SV1[match(comparison_data$FCX_ID, covariate_data$ID)]
      
      comparison_data$group_ID <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data <- comparison_data[order(comparison_data$group_ID), ]
      comparison_data$FCX_ID <- gsub("-", ".", comparison_data$FCX_ID)
      common_ids <- intersect(comparison_data$FCX_ID, rownames(data))
      data_subset <- data[rownames(data) %in% common_ids, ]
      data_ordered <- data_subset[match(comparison_data$FCX_ID, rownames(data_subset)), ]
      # CLEAN NA
      data_ordered[!is.finite(as.matrix(data_ordered))] <- 0
      data_ordered <- data_ordered[complete.cases(data_ordered), ]
      comparison_data <- comparison_data[match(rownames(data_ordered), comparison_data$FCX_ID), ]
      
      group <- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])
      y <- DGEList(counts=t(data_ordered),group=group)
      y <- y[, colSums(y$counts) > 0]
      # Keep only samples in comparison_data that are in y
      comparison_data <- comparison_data[match(colnames(y), comparison_data$FCX_ID), ]
      
      # Average Log CPM histogram
      AveLogCPM <- aveLogCPM(y)
      y <- normLibSizes(y)
      
      # MD plot
      plot_filename <- file.path(condition_folder, "MD_plot_h.png")
      png(file = plot_filename)
      MD_plot <- plotMD(y, column=1) +
        abline(h=0, col="red", lty=2, lwd=2)
      dev.off()
      
      # DESIGN MATRIX
      group <- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))
      comparison_data$group_ID <- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)
      design <- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)
      colnames(design) <- c(REFERENCE_GROUP, condition, "SV1")
      nrow(design) == ncol(y)
      
      # DISPERSION ESTIMATION
      y <- estimateDisp(y,design)
      fit <- glmFit(y,design)
      
      # Diferential expression analysis
      B.LvsP <- makeContrasts(paste0(condition, " - ", REFERENCE_GROUP), levels=design)
      res <- glmLRT(fit, contrast=B.LvsP)
      is.de <- decideTests(res, adjust.method = "fdr", p.value = 0.05, lfc= 0)
      results_table <- res$table
      results_table$adj_pval <- p.adjust(results_table$PValue, method = "fdr", n = length(results_table$PValue))
      results_table <- cbind(results_table, data.frame(is.de))
      # SAVING CSV RESULTS
      write.csv(res$table, file = file.path(condition_folder, "res_h.csv"))
      write.csv(results_table, file = file.path(condition_folder, "results_adj_h.csv"))
      ## Visualizations
      # "Volcano like" plot
      plot_filename <- file.path(condition_folder, "MD_res_plot_h.png")
      png(file = plot_filename)
      plotMD(res, status=is.de)
      dev.off()
      
      # Heatmap clustering 
      logCPM <- cpm(y, prior.count=2, log=TRUE)
      rownames(logCPM) <- y$genes$Symbol
      colnames(logCPM) <- paste(y$samples$group, 1:2, sep="-")
      tr <- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))
      o <- order(tr$table$PValue)
      logCPM <- logCPM[o[1:30],]
      
      plot_filename <- file.path(condition_folder, "Heatmap_h.png")
      png(file = plot_filename)
      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))
      dev.off()
      
      df[condition, tools::file_path_sans_ext(basename(file))] <- nrow(results_table[results_table$adj_pval<0.05,])
      
    }, error = function(e){
      df[condition, tools::file_path_sans_ext(basename(file))] <- 0
    })
  }
}

write.csv(df, file = file.path(OUTPUT_DIRECTORY, "summary_h.csv"))
```
