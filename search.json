[
  {
    "objectID": "Results/Sc_dea_results_C9.html",
    "href": "Results/Sc_dea_results_C9.html",
    "title": "Single cell difference expression analysis ( C9orf72 )",
    "section": "",
    "text": "From the 43 deconvolved cells, only 28 had sufficient expression levels for EdgeR to perform differential expression analysis. Among these, 15 distinct cell types showed significant differential gene expression. RORB/POU3F2 characterized excitatory neuron exhibited the highest anount of alterations, with 433 differentially expressed genes (DEGs) and RORB/LRRK1 (263 DEGs) was also notably affected. For the inhibitory neurons we found DEG in the cells characterized by CUX2/RASGRF2 123, LAMP5/PMEPA1 22. Smooth muscle cells (SMC) also shown 270 DEG. Vascular cells such as arterial, and capillary subtypes displayed 52 and 63 deregulated genes respectively. T cells contributed with 33 DEGs. Across all cell types, upregulated genes were more frequent than downregulated ones.\n\n\nDifferences in excitatory neuron composition reveal key changes in RORB-characterized subtypes. Differential gene expression analysis at cell state resolution identified downregulation of the disease-associated gene C9orf72 in the CUX2/RASGRF2 (adjusted p= 0,016 FC: 0.75), RORB/LRRK1(adjusted p= 0,026; FC: 0.78), and RORB/POU3F2 (adjusted p= 0,033; FC: 0,79) subtypes (PMCID: PMC3430713). Additionally, inflammatory marker genes were upregulated across excitatory neuron subtypes. For example, CHI3L1 was found upregulated in RORB/POU3F2(adjusted p=: 0,036; FC: 2,69) , consistent with its known elevation in cerebrospinal fluid as a biomarker (PMID: 32344399).\nHemoglobin subunits HBA1 in RORB/LRRK1 (adjusted p= 0,041; FC: 0,22) and RORB/POU3F2 (p= -0.04; FC: 0,22) and HBB in RORB/LRRK1 (adjusted p= 0,036; logFC: 0.23) and RORB/POU3F2 (adjusted p= 0,024; logFC: 0,23) also showed decreased expression that has been previously described in the frontal cortex of patents with neurodegenerative diseases (PMCID: PMC5786544). Functionally, downregulated genes in RORB/LRRK1 and RORB/POU3F2-expressing neurons are enriched in postsynaptic components and synaptic transmission. In the CUX2/RASGRF subtype, affected genes relate to postsynapse and transmission regulation. Upregulated genes in the CUX2/RASGRF subtype indicate enrichment in behavior, presinapse, and neuron apoptotic process, while in RORB/LRRK1 and RORB/POU3F2 subtypes, they relate to synaptic organization, behaviour and amyloid-beta response.\n\n\n\nInhibitory neurons display vulnerable transcriptional signatures in LAMP5/PMEPA1. Alterations in LAMP5/PMEPA1 expression involve genes without a previously established association with FTLD. Biological functions and pathways enriched among deregulated genes were observed exclusively in LAMP5/PMEPA1 neurons. These include enrichment of upregulated genes in axon and learning or memory, and for the downregulated genes synaptic vessicles, membrane and axon.\n\n\n\nAmong non-neuronal cell types—astrocytes (GFAP+ and GFAP-), microglia, and oligodendrocytes—a common reduction in HBB expression was observed in GFAP- (adjusted p= 0,043; FC: 0,23) and oligodendrocytes (adjusted p= 0,017; FC:, 0,22) (PMCID: PMC5786544). Functional enrichment analysis of deregulated genes in these cell types highlighted processes such as humoral immune response, axon guidance , memory, glial cell development and intrinsic apoptotic signaling pathway. Conversely, reductions were found in trans-synaptic signaling, social behavior and dendrites.\n\n\n\nArterial, capillary, smooth muscle cells (SMCs), and T cells were grouped as vascular cells. Differential expression analysis showed reduced expression of HBB in SMC (adjusted p= 0,035; FC: 0,23), HBA1 in arterial (adjusted p= 0,032; FC: 0,23), capillary (adjusted p= 0,032; FC: 0,22) and SMCs (adjusted p= 0,013; FC: 0,21) and HBA2 in arterial (adjusted p= 0,042; FC: 0,23), capillary (adjusted p= 0,017; FC: 0,23 ) and SMCs (adjusted p= 1.26e-81; FC: 0.22 ) in FTLD. An additional notable finding points to an upregulation tendency of CXCL11 in SMC (adjusted p= 0,069; FC: 19,66).\nPathway analysis revealed increased activity in processes such as behaviour , regulation of neuron apoptotic process, neuropeptide signaling pathway. Reductions were observed in regulation of biological processes, synaptic vessicle exocytocis, secretion , presynaptic membrane, oxygen carier activity, postsynapse. Genes of interest DE Nominal p-values\nAnalysis of nominal p-values per gene and cell type in FTLD-C9 revealed a number of genes exhibiting p &lt; 0.05 in specific cell populations, suggesting restricted transcriptional alterations. TUBA4A showed nominal significance in arterial cells (p = 0.011), capillaries (p = 0.006), CUX2/RASGRF2 neurons (p = 0.007), GFAP - astrocytes (p = 0.008), SST/NPY neurons (p = 0.003), T cells (p = 0.005), and THEMIS/TMEM233 cells (p = 0.006), indicating potential alterations in vascular, glial, and neuronal subtypes. FUS displayed significant nominal p-values in arterial cells (p = 0.002), capillaries (p = 0.005), CUX2/RASGRF2 neurons (p = 0.022), GFAP - astrocytes (p = 0.008), LAMP5/PMEPA1 neurons (p = 0.007), SST/NPY neurons (p = 0.018), T cells (p = 0.008), and THEMIS/TMEM233 cells (p = 0.009), suggesting widespread but cell type-specific transcriptional changes. C9orf72 exhibited striking nominal significance in arterial cells (p = 0.004), capillaries (p = 0.0003), CUX2/RASGRF2 neurons (p = 0.00004), GFAP - astrocytes (p = 0.0005), LAMP5/PMEPA1 neurons (p = 0.003), microglia (p = 0.002), oligodendrocytes (p = 0.008), SST/NPY neurons (p = 0.0002), T cells (p = 0.0005), and THEMIS/TMEM233 cells (p = 0.0004), confirming strong cell type-specific transcriptional effects. VCP showed significant p-values in arterial cells (p = 0.0002), capillaries (p = 0.00004), CUX2/RASGRF2 neurons (p = 0.0004), GFAP- astrocytes (p = 0.0002), microglia (p = 0.015), oligodendrocytes (p = 0.027), SST/NPY neurons (p = 0.0001), T cells (p = 0.00005), and THEMIS/TMEM233 cells (p = 0.0001), reflecting selective transcriptional dysregulation across multiple cell types. MATR3 presented nominal significance in arterial cells (p = 0.086), capillaries (p = 0.046), CUX2/RASGRF2 neurons (p = 0.042), GFAP - astrocytes (p = 0.047), LAMP5/PMEPA1 neurons (p = 0.061), microglia (p = 0.077), oligodendrocytes (p = 0.027), SST/NPY neurons (p = 0.032), and T cells (p = 0.032), suggesting moderate cell type-specific effects. DPP6 exhibited nominal significance in CDH4/SCGN neurons (p = 0.036), CUX2/RASGRF2 neurons (p = 0.003), GFAP + astrocytes (p = 0.003), microglia (p = 0.030), SST/NPY neurons (p = 0.005), and T cells (p = 0.024), indicating restricted but consistent alterations in excitatory neurons, astrocytes, and interneurons. Other genes such as NEFL, OPTN, GRN, TARDBP, HNRNPA1, MAPT, UNC13A, L3MBTL1, and VIPR1 displayed variable nominal significance across a few cell types, whereas many genes including NPTX2, UBQLN2, C19orf52, and ANO9 did not show any nominally significant changes in any cell type."
  },
  {
    "objectID": "Results/Sc_dea_results_C9.html#c9",
    "href": "Results/Sc_dea_results_C9.html#c9",
    "title": "Single cell difference expression analysis ( C9orf72 )",
    "section": "",
    "text": "From the 43 deconvolved cells, only 28 had sufficient expression levels for EdgeR to perform differential expression analysis. Among these, 15 distinct cell types showed significant differential gene expression. RORB/POU3F2 characterized excitatory neuron exhibited the highest anount of alterations, with 433 differentially expressed genes (DEGs) and RORB/LRRK1 (263 DEGs) was also notably affected. For the inhibitory neurons we found DEG in the cells characterized by CUX2/RASGRF2 123, LAMP5/PMEPA1 22. Smooth muscle cells (SMC) also shown 270 DEG. Vascular cells such as arterial, and capillary subtypes displayed 52 and 63 deregulated genes respectively. T cells contributed with 33 DEGs. Across all cell types, upregulated genes were more frequent than downregulated ones.\n\n\nDifferences in excitatory neuron composition reveal key changes in RORB-characterized subtypes. Differential gene expression analysis at cell state resolution identified downregulation of the disease-associated gene C9orf72 in the CUX2/RASGRF2 (adjusted p= 0,016 FC: 0.75), RORB/LRRK1(adjusted p= 0,026; FC: 0.78), and RORB/POU3F2 (adjusted p= 0,033; FC: 0,79) subtypes (PMCID: PMC3430713). Additionally, inflammatory marker genes were upregulated across excitatory neuron subtypes. For example, CHI3L1 was found upregulated in RORB/POU3F2(adjusted p=: 0,036; FC: 2,69) , consistent with its known elevation in cerebrospinal fluid as a biomarker (PMID: 32344399).\nHemoglobin subunits HBA1 in RORB/LRRK1 (adjusted p= 0,041; FC: 0,22) and RORB/POU3F2 (p= -0.04; FC: 0,22) and HBB in RORB/LRRK1 (adjusted p= 0,036; logFC: 0.23) and RORB/POU3F2 (adjusted p= 0,024; logFC: 0,23) also showed decreased expression that has been previously described in the frontal cortex of patents with neurodegenerative diseases (PMCID: PMC5786544). Functionally, downregulated genes in RORB/LRRK1 and RORB/POU3F2-expressing neurons are enriched in postsynaptic components and synaptic transmission. In the CUX2/RASGRF subtype, affected genes relate to postsynapse and transmission regulation. Upregulated genes in the CUX2/RASGRF subtype indicate enrichment in behavior, presinapse, and neuron apoptotic process, while in RORB/LRRK1 and RORB/POU3F2 subtypes, they relate to synaptic organization, behaviour and amyloid-beta response.\n\n\n\nInhibitory neurons display vulnerable transcriptional signatures in LAMP5/PMEPA1. Alterations in LAMP5/PMEPA1 expression involve genes without a previously established association with FTLD. Biological functions and pathways enriched among deregulated genes were observed exclusively in LAMP5/PMEPA1 neurons. These include enrichment of upregulated genes in axon and learning or memory, and for the downregulated genes synaptic vessicles, membrane and axon.\n\n\n\nAmong non-neuronal cell types—astrocytes (GFAP+ and GFAP-), microglia, and oligodendrocytes—a common reduction in HBB expression was observed in GFAP- (adjusted p= 0,043; FC: 0,23) and oligodendrocytes (adjusted p= 0,017; FC:, 0,22) (PMCID: PMC5786544). Functional enrichment analysis of deregulated genes in these cell types highlighted processes such as humoral immune response, axon guidance , memory, glial cell development and intrinsic apoptotic signaling pathway. Conversely, reductions were found in trans-synaptic signaling, social behavior and dendrites.\n\n\n\nArterial, capillary, smooth muscle cells (SMCs), and T cells were grouped as vascular cells. Differential expression analysis showed reduced expression of HBB in SMC (adjusted p= 0,035; FC: 0,23), HBA1 in arterial (adjusted p= 0,032; FC: 0,23), capillary (adjusted p= 0,032; FC: 0,22) and SMCs (adjusted p= 0,013; FC: 0,21) and HBA2 in arterial (adjusted p= 0,042; FC: 0,23), capillary (adjusted p= 0,017; FC: 0,23 ) and SMCs (adjusted p= 1.26e-81; FC: 0.22 ) in FTLD. An additional notable finding points to an upregulation tendency of CXCL11 in SMC (adjusted p= 0,069; FC: 19,66).\nPathway analysis revealed increased activity in processes such as behaviour , regulation of neuron apoptotic process, neuropeptide signaling pathway. Reductions were observed in regulation of biological processes, synaptic vessicle exocytocis, secretion , presynaptic membrane, oxygen carier activity, postsynapse. Genes of interest DE Nominal p-values\nAnalysis of nominal p-values per gene and cell type in FTLD-C9 revealed a number of genes exhibiting p &lt; 0.05 in specific cell populations, suggesting restricted transcriptional alterations. TUBA4A showed nominal significance in arterial cells (p = 0.011), capillaries (p = 0.006), CUX2/RASGRF2 neurons (p = 0.007), GFAP - astrocytes (p = 0.008), SST/NPY neurons (p = 0.003), T cells (p = 0.005), and THEMIS/TMEM233 cells (p = 0.006), indicating potential alterations in vascular, glial, and neuronal subtypes. FUS displayed significant nominal p-values in arterial cells (p = 0.002), capillaries (p = 0.005), CUX2/RASGRF2 neurons (p = 0.022), GFAP - astrocytes (p = 0.008), LAMP5/PMEPA1 neurons (p = 0.007), SST/NPY neurons (p = 0.018), T cells (p = 0.008), and THEMIS/TMEM233 cells (p = 0.009), suggesting widespread but cell type-specific transcriptional changes. C9orf72 exhibited striking nominal significance in arterial cells (p = 0.004), capillaries (p = 0.0003), CUX2/RASGRF2 neurons (p = 0.00004), GFAP - astrocytes (p = 0.0005), LAMP5/PMEPA1 neurons (p = 0.003), microglia (p = 0.002), oligodendrocytes (p = 0.008), SST/NPY neurons (p = 0.0002), T cells (p = 0.0005), and THEMIS/TMEM233 cells (p = 0.0004), confirming strong cell type-specific transcriptional effects. VCP showed significant p-values in arterial cells (p = 0.0002), capillaries (p = 0.00004), CUX2/RASGRF2 neurons (p = 0.0004), GFAP- astrocytes (p = 0.0002), microglia (p = 0.015), oligodendrocytes (p = 0.027), SST/NPY neurons (p = 0.0001), T cells (p = 0.00005), and THEMIS/TMEM233 cells (p = 0.0001), reflecting selective transcriptional dysregulation across multiple cell types. MATR3 presented nominal significance in arterial cells (p = 0.086), capillaries (p = 0.046), CUX2/RASGRF2 neurons (p = 0.042), GFAP - astrocytes (p = 0.047), LAMP5/PMEPA1 neurons (p = 0.061), microglia (p = 0.077), oligodendrocytes (p = 0.027), SST/NPY neurons (p = 0.032), and T cells (p = 0.032), suggesting moderate cell type-specific effects. DPP6 exhibited nominal significance in CDH4/SCGN neurons (p = 0.036), CUX2/RASGRF2 neurons (p = 0.003), GFAP + astrocytes (p = 0.003), microglia (p = 0.030), SST/NPY neurons (p = 0.005), and T cells (p = 0.024), indicating restricted but consistent alterations in excitatory neurons, astrocytes, and interneurons. Other genes such as NEFL, OPTN, GRN, TARDBP, HNRNPA1, MAPT, UNC13A, L3MBTL1, and VIPR1 displayed variable nominal significance across a few cell types, whereas many genes including NPTX2, UBQLN2, C19orf52, and ANO9 did not show any nominally significant changes in any cell type."
  },
  {
    "objectID": "Results/Sc_dea_results_C9.html#sant-pau",
    "href": "Results/Sc_dea_results_C9.html#sant-pau",
    "title": "Single cell difference expression analysis ( C9orf72 )",
    "section": "Sant Pau",
    "text": "Sant Pau\n\n\n\n\n\n\n\nArterial\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ncounter &lt;- 1\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_FTLD_C9.xlsx\"\nsheets &lt;- excel_sheets(file)\n\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCapillary\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCDH4_CCK\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCDH4_SCGN\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCLMP_KCNMA1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCLMP_PDGFRA\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCUX2_RASGRF2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCUX2_RORB\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nDISC1_CCK\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nDISC1_RELN\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nGFAP_neg\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nGFAP_pos\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nLAMP5_CA3\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nLAMP5_PMEPA1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nMicro\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nOligo\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nOPC\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPCP4_NXPH2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPericyte\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPVALB_CEMIP\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPVALB_MYBPC1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPVALB_PTHLH\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_ADGRL4\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_FOXO1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_LRRK1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_POU3F2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSCN4B_NEFH\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSMC\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_ADAMTS19\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_BRINP3\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_GALNT14\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_NPY\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nT_Cell\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTHEMIS_NR4A2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTHEMIS_TMEM233\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTLE4_CCBE1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTLE4_MEGF11\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTLE4_SEMA3D\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVAT1L_EYA4\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVenous\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVIP_CLSTN2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVIP_HTR2C\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVIP_LAMA3\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1"
  },
  {
    "objectID": "Results/Sc_dea_results_TDP.html",
    "href": "Results/Sc_dea_results_TDP.html",
    "title": "Single cell difference expression analysis ( TDP )",
    "section": "",
    "text": "From the 43 deconvolved cells, only 27 had sufficient expression levels for EdgeR to perform differential expression analysis. Among these, 15 distinct cell types showed significant differential gene expression. RORB/POU3F2-characterized excitatory neurons exhibited the highest number of alterations, with 8 differentially expressed genes (DEGs), while RORB/LRRK1 showed 1 DEG. Smooth muscle cells (SMCs) also displayed 6 DEGs. Across all cell types, upregulated genes were more frequent than downregulated ones.\n\n\nDifferences in excitatory neuron composition revealed key transcriptional changes. In RORB/FOXO1 neurons, RTP5 was downregulated (adjusted p = 0.0158; FC = 0,39). Inflammatory marker CHI3L1 was upregulated in RORB/LRRK1 (adjusted p = 0.0038; FC = 2.87) and RORB/POU3F2 (adjusted p = 0.00032; FC = 3,03), consistent with its role as a neuroinflammatory biomarker. Additionally, METRN was downregulated in RORB/POU3F2 (adjusted p = 0.0076; FC =0,74).The deregulated genes do not enrich biological pathways or functions.\n\n\n\nNo differentially expressed genes were detected in inhibitory neuron subtypes.\n\n\n\nAmong non-neuronal cell types—including astrocytes (GFAP+ and GFAP-), microglia, and oligodendrocytes—several transcriptional alterations were observed. In GFAP- astrocytes (adjusted p = 0.00018; FC = 3,04) and microglia (adjusted p = 0.01; FC = 3,04), the inflammatory marker CHI3L1 was upregulated and , reflecting an activation of neuroinflammatory pathways. Conversely, METRN expression was reduced in GFAP- astrocytes (adjusted p = 0.0032; FC = 0,74), and ACSM5 was downregulated in microglia (adjusted p = 0.035; FC = 0,47). In oligodendrocytes, GIPR was significantly upregulated (adjusted p = 0.0009; FC = 3,90), suggesting potential alterations in oligodendrocyte signaling or metabolic processes.\nThese findings indicate that TDP-43 pathology is associated with both pro-inflammatory activation and suppression of specific functional genes across non-neuronal cell populations. Enrichment analysis do not show significativly enriched pathways.\nVascular cells Arterial, capillary, and T cell subtypes did not display significant differential gene expression. In SMCs, CHI3L1 was upregulated (adjusted p = 0.013; FC = 3,05) and METRN was downregulated (adjusted p = 0.013; FC = 0.74).The enrichment analysis on this cell types did not indicate any enriched term.\nNominal p-values In the case of FTLD-TDP, analysis of nominal p-values per gene and cell type revealed several genes exhibiting p &lt; 0.05 in specific cell populations, suggesting restricted transcriptional alterations. CHCHD10 showed nominal significance in RORB/FOXO1 neurons (p = 0.056), RORB/LRRK1 neurons (p = 0.132), and SMC (p = 0.039), indicating potential alterations in vascular and neuronal subtypes. GRN presented significant nominal p-values in Oligodendrocytes (p = 0.046), RORB/LRRK1 neurons (p = 0.066), and RORB/POU3F2 neurons (p = 0.121), suggesting glial and neuronal involvement. UNC13A exhibited nominal significance in Oligodendrocytes (p = 0.045), consistent with selective transcriptional changes within this glial subtype. L3MBTL1 showed nominal p-values in GFAP+ astrocytes (p = 0.019) and Oligodendrocytes (p = 0.017), indicating glial cell–specific effects. SMG8 demonstrated nominal significance in Oligodendrocytes (p = 0.045) and RORB/POU3F2 neurons (p = 0.106), supporting moderate transcriptional dysregulation across glial and neuronal populations. NPTX2 displayed the most striking pattern, with highly significant nominal p-values across multiple cell types, including Arterial (p = 0.0008), Capillary (p = 0.0057), CUX2/RASGRF2 neurons (p = 0.003), GFAP - astrocytes (p = 0.013), Oligodendrocytes (p = 0.016), RORB/LRRK1 neurons (p = 0.0096), RORB/POU3F2 neurons (p = 0.0050), SMC (p = 0.0036), and T cells (p = 0.036), confirming strong and cell type–specific transcriptional effects spanning vascular, neuronal, and glial compartments. Other genes such as NEFL, OPTN, MATR3, TBK1, C9orf72, VCP, CHMP2B, SQSTM1, TARDBP, FUS, MAPT, DPP6, TMEM106B, HNRNPA1, HNRNPL, PDS5B, TNIP1, VIPR1, RCL1, C3AR1, TINAG, RBPJL, and FARP2 did not exhibit any nominally significant changes across cell types, whereas UBQLN2, C19orf52, and ANO9 lacked available data. Collectively, these findings suggest that among the tested genes, NPTX2 exhibits the most prominent and broad transcriptional alterations, followed by moderate, cell type–restricted effects for CHCHD10, GRN, L3MBTL1, SMG8, and UNC13A."
  },
  {
    "objectID": "Results/Sc_dea_results_TDP.html#tdp",
    "href": "Results/Sc_dea_results_TDP.html#tdp",
    "title": "Single cell difference expression analysis ( TDP )",
    "section": "",
    "text": "From the 43 deconvolved cells, only 27 had sufficient expression levels for EdgeR to perform differential expression analysis. Among these, 15 distinct cell types showed significant differential gene expression. RORB/POU3F2-characterized excitatory neurons exhibited the highest number of alterations, with 8 differentially expressed genes (DEGs), while RORB/LRRK1 showed 1 DEG. Smooth muscle cells (SMCs) also displayed 6 DEGs. Across all cell types, upregulated genes were more frequent than downregulated ones.\n\n\nDifferences in excitatory neuron composition revealed key transcriptional changes. In RORB/FOXO1 neurons, RTP5 was downregulated (adjusted p = 0.0158; FC = 0,39). Inflammatory marker CHI3L1 was upregulated in RORB/LRRK1 (adjusted p = 0.0038; FC = 2.87) and RORB/POU3F2 (adjusted p = 0.00032; FC = 3,03), consistent with its role as a neuroinflammatory biomarker. Additionally, METRN was downregulated in RORB/POU3F2 (adjusted p = 0.0076; FC =0,74).The deregulated genes do not enrich biological pathways or functions.\n\n\n\nNo differentially expressed genes were detected in inhibitory neuron subtypes.\n\n\n\nAmong non-neuronal cell types—including astrocytes (GFAP+ and GFAP-), microglia, and oligodendrocytes—several transcriptional alterations were observed. In GFAP- astrocytes (adjusted p = 0.00018; FC = 3,04) and microglia (adjusted p = 0.01; FC = 3,04), the inflammatory marker CHI3L1 was upregulated and , reflecting an activation of neuroinflammatory pathways. Conversely, METRN expression was reduced in GFAP- astrocytes (adjusted p = 0.0032; FC = 0,74), and ACSM5 was downregulated in microglia (adjusted p = 0.035; FC = 0,47). In oligodendrocytes, GIPR was significantly upregulated (adjusted p = 0.0009; FC = 3,90), suggesting potential alterations in oligodendrocyte signaling or metabolic processes.\nThese findings indicate that TDP-43 pathology is associated with both pro-inflammatory activation and suppression of specific functional genes across non-neuronal cell populations. Enrichment analysis do not show significativly enriched pathways.\nVascular cells Arterial, capillary, and T cell subtypes did not display significant differential gene expression. In SMCs, CHI3L1 was upregulated (adjusted p = 0.013; FC = 3,05) and METRN was downregulated (adjusted p = 0.013; FC = 0.74).The enrichment analysis on this cell types did not indicate any enriched term.\nNominal p-values In the case of FTLD-TDP, analysis of nominal p-values per gene and cell type revealed several genes exhibiting p &lt; 0.05 in specific cell populations, suggesting restricted transcriptional alterations. CHCHD10 showed nominal significance in RORB/FOXO1 neurons (p = 0.056), RORB/LRRK1 neurons (p = 0.132), and SMC (p = 0.039), indicating potential alterations in vascular and neuronal subtypes. GRN presented significant nominal p-values in Oligodendrocytes (p = 0.046), RORB/LRRK1 neurons (p = 0.066), and RORB/POU3F2 neurons (p = 0.121), suggesting glial and neuronal involvement. UNC13A exhibited nominal significance in Oligodendrocytes (p = 0.045), consistent with selective transcriptional changes within this glial subtype. L3MBTL1 showed nominal p-values in GFAP+ astrocytes (p = 0.019) and Oligodendrocytes (p = 0.017), indicating glial cell–specific effects. SMG8 demonstrated nominal significance in Oligodendrocytes (p = 0.045) and RORB/POU3F2 neurons (p = 0.106), supporting moderate transcriptional dysregulation across glial and neuronal populations. NPTX2 displayed the most striking pattern, with highly significant nominal p-values across multiple cell types, including Arterial (p = 0.0008), Capillary (p = 0.0057), CUX2/RASGRF2 neurons (p = 0.003), GFAP - astrocytes (p = 0.013), Oligodendrocytes (p = 0.016), RORB/LRRK1 neurons (p = 0.0096), RORB/POU3F2 neurons (p = 0.0050), SMC (p = 0.0036), and T cells (p = 0.036), confirming strong and cell type–specific transcriptional effects spanning vascular, neuronal, and glial compartments. Other genes such as NEFL, OPTN, MATR3, TBK1, C9orf72, VCP, CHMP2B, SQSTM1, TARDBP, FUS, MAPT, DPP6, TMEM106B, HNRNPA1, HNRNPL, PDS5B, TNIP1, VIPR1, RCL1, C3AR1, TINAG, RBPJL, and FARP2 did not exhibit any nominally significant changes across cell types, whereas UBQLN2, C19orf52, and ANO9 lacked available data. Collectively, these findings suggest that among the tested genes, NPTX2 exhibits the most prominent and broad transcriptional alterations, followed by moderate, cell type–restricted effects for CHCHD10, GRN, L3MBTL1, SMG8, and UNC13A."
  },
  {
    "objectID": "Results/Sc_dea_results_TDP.html#sant-pau",
    "href": "Results/Sc_dea_results_TDP.html#sant-pau",
    "title": "Single cell difference expression analysis ( TDP )",
    "section": "Sant Pau",
    "text": "Sant Pau\n\n\nCode\nlibrary(readxl)\nlibrary(plotly)\nlibrary(tidyverse)\n\n# ---- File and sheets ----\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_FTLD_TDP.xlsx\"\nsheets &lt;- excel_sheets(file)\n\n# ---- Genes to highlight ----\ngenes_highlight &lt;- c(\"\")\n\n# ---- Read and standardize data per sheet ----\ndata_list &lt;- list()\n\nfor (sheet in sheets) {\n  df_raw &lt;- read_excel(file, sheet = sheet)\n  colnames(df_raw) &lt;- tolower(make.names(colnames(df_raw), unique = TRUE))\n  cols &lt;- colnames(df_raw)\n  \n  logfc_col &lt;- intersect(c(\"logfc\", \"log2fc\"), cols)\n  fdr_col   &lt;- intersect(c(\"adj_pval\", \"adj.pval\", \"fdr\", \"padj\"), cols)\n  pval_col  &lt;- intersect(c(\"pvalue\", \"p.val\", \"pval\"), cols)\n  \n  if (length(logfc_col) == 0 || length(fdr_col) == 0) {\n    message(\"⚠️ Skipping \", sheet, \" — missing logFC or FDR/adj_pval column.\")\n    next\n  }\n  \n  data &lt;- tibble(\n    gene   = df_raw[[1]],\n    logfc  = as.numeric(df_raw[[logfc_col[1]]]),\n    fdr    = as.numeric(df_raw[[fdr_col[1]]]),\n    pvalue = if (length(pval_col) &gt; 0) as.numeric(df_raw[[pval_col[1]]]) else NA_real_\n  ) %&gt;%\n    mutate(\n      neglog10fdr = -log10(fdr),\n      significance = case_when(\n        fdr &lt; 0.05 & logfc &gt; 0 ~ \"Upregulated\",\n        fdr &lt; 0.05 & logfc &lt; 0 ~ \"Downregulated\",\n        TRUE ~ \"Not significant\"\n      ),\n      label = ifelse(gene %in% genes_highlight, gene, NA_character_)\n    ) %&gt;%\n    drop_na(logfc, fdr)\n  \n  if (nrow(data) == 0) {\n    message(\"⚠️ Skipping \", sheet, \" — no valid rows after cleaning.\")\n    next\n  }\n  \n  data_list[[sheet]] &lt;- data\n}\n\nvalid_sheets &lt;- names(data_list)\nmessage(\"✅ Prepared volcano data for: \", paste(valid_sheets, collapse = \", \"))\n\n# ---- Fixed color palette (green for not significant) ----\ncol_map &lt;- c(\n  \"Upregulated\"   = \"#D55E00\",\n  \"Downregulated\" = \"#0072B2\",\n  \"Not significant\" = \"#009E73\"   # green tone (replace with grey70 if preferred)\n)\n\n# ---- Build multi-sheet plot ----\nfig &lt;- plot_ly()\ntrace_ranges &lt;- list()\n\nfor (i in seq_along(valid_sheets)) {\n  sheet &lt;- valid_sheets[i]\n  df &lt;- data_list[[sheet]]\n  \n  start_idx &lt;- length(fig$x$data) + 1\n  \n  for (sig in c(\"Upregulated\", \"Downregulated\", \"Not significant\")) {\n    sub &lt;- df %&gt;% filter(significance == sig)\n    if (nrow(sub) == 0) next\n    \n    # Only label highlighted genes\n    text_labels &lt;- ifelse(is.na(sub$label), \"\", sub$label)\n    \n    fig &lt;- fig %&gt;%\n      add_trace(\n        type = \"scatter\",\n        mode = \"markers+text\",\n        x = sub$logfc,\n        y = sub$neglog10fdr,\n        marker = list(\n          color = col_map[[sig]],\n          size = 6,\n          opacity = 0.8\n        ),\n        text = text_labels,\n        textposition = \"top center\",\n        textfont = list(size = 9),\n        hovertext = paste0(\n          \"&lt;b&gt;\", sub$gene, \"&lt;/b&gt;&lt;br&gt;\",\n          \"logFC: \", round(sub$logfc, 2), \"&lt;br&gt;\",\n          \"FDR: \", signif(sub$fdr, 3)\n        ),\n        hoverinfo = \"text\",\n        name = sig,\n        showlegend = (i == 1),\n        visible = (i == 1)\n      )\n  }\n  \n  end_idx &lt;- length(fig$x$data)\n  trace_ranges[[i]] &lt;- start_idx:end_idx\n}\n\n# ---- Dropdown ----\nbuttons &lt;- lapply(seq_along(valid_sheets), function(i) {\n  vis &lt;- rep(FALSE, length(fig$x$data))\n  vis[trace_ranges[[i]]] &lt;- TRUE\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = vis),\n      list(title = paste(\"Interactive Volcano Plot —\", valid_sheets[i]))\n    ),\n    label = valid_sheets[i]\n  )\n})\n\n# ---- Layout ----\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Interactive Volcano Plot —\", valid_sheets[1]), x = 0.05),\n    xaxis = list(title = \"log₂ Fold Change\"),\n    yaxis = list(title = \"−log₁₀(FDR)\"),\n    updatemenus = list(list(\n      y = 1.1,\n      x = 0,\n      buttons = buttons,\n      direction = \"down\",\n      showactive = TRUE,\n      xanchor = \"left\",\n      yanchor = \"top\",\n      title = list(text = \"Select cell state / sheet\")\n    ))\n  )\n\nfig\n\n\n\nArterial\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(DT)\ncounter &lt;- 1\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_FTLD_TDP.xlsx\"\nsheets &lt;- excel_sheets(file)\n\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCapillary\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCDH4_CCK\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCDH4_SCGN\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCLMP_KCNMA1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCLMP_PDGFRA\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCUX2_RASGRF2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nCUX2_RORB\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nDISC1_CCK\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nDISC1_RELN\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nGFAP_neg\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nGFAP_pos\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nLAMP5_CA3\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nLAMP5_PMEPA1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nMicro\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nOligo\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nOPC\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPCP4_NXPH2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPericyte\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPVALB_CEMIP\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPVALB_MYBPC1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nPVALB_PTHLH\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_ADGRL4\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_FOXO1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_LRRK1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nRORB_POU3F2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSCN4B_NEFH\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSMC\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_ADAMTS19\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_BRINP3\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_GALNT14\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nSST_NPY\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nT_Cell\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTHEMIS_NR4A2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTHEMIS_TMEM233\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTLE4_CCBE1\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTLE4_MEGF11\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nTLE4_SEMA3D\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVAT1L_EYA4\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVenous\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVIP_CLSTN2\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVIP_HTR2C\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\nVIP_LAMA3\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1"
  },
  {
    "objectID": "Introduction/Cohort.html",
    "href": "Introduction/Cohort.html",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "Our analysis integrated transcriptomic data from four independent bulk RNA-sequencing cohorts, comprising two newly generated datasets from Hospital de la Santa Creu i Sant Pau and two publicly available external datasets used for validation. All datasets consisted of post-mortem frontal cortex samples from individuals diagnosed with FTLD and cognitively healthy controls. Collectively, these cohorts enabled robust, cross-cohort evaluation of cell-type–resolved transcriptional alterations and disease-associated gene expression programs.\n\n\nThe first primary dataset was generated at Hospital de la Santa Creu i Sant Pau and included 11 individuals with FTLD due to a C9orf72 hexanucleotide repeat expansion (FTLD-C9) and 7 cognitively healthy controls. Diagnoses were neuropathologically verified, and all samples were sequenced from the frontal cortex. This cohort served as the discovery dataset for identifying disease-associated transcriptional changes, alterations in inferred cell-state composition, and correlations with C9orf72-specific neuropathological markers, including RNA foci, dipeptide repeat proteins (polyGA, polyGP, polyGR), and TDP-43–related measures.\n\n\nCode\ndata&lt;-read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", sheetIndex = 1)\ndata &lt;- data[data$group.ID %in% c(\"Healthy\", \"C9orf72\"),]\ntable(data$group.ID)\n\n\n\nC9orf72 Healthy \n     11       7 \n\n\n\n\nCode\ndata&lt;-read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\")\ndim(data)[1]\n\n\n[1] 57169\n\n\n\n\n\nA second independent dataset from Sant Pau included 9 individuals with sporadic FTLD-TDP and 7 controls from the same anatomical region and processed using equivalent library preparation and sequencing pipelines. This cohort provided complementary transcriptomic profiling for FTLD-TDP, enabling direct comparison between genetic (C9orf72-associated) and sporadic TDP-43 proteinopathies within a harmonized experimental framework. Neuropathological quantification of pTDP-43 and STMN2 levels allowed integration of transcriptional changes with molecular markers of TDP-43 dysfunction.\n\n\nCode\ndata&lt;-read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", sheetIndex = 1)\ndata &lt;- data[data$group.ID %in% c(\"Healthy\", \"TDP\"),]\ntable(data$group.ID)\n\n\n\nHealthy     TDP \n      7       9 \n\n\n\n\nCode\ndata&lt;-read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\")\ndim(data)[1]\n\n\n[1] 57169\n\n\n\n\n\nTo evaluate the reproducibility of FTLD-C9 transcriptional signatures, we used the bulk RNA-seq dataset published by Menden et al. (2023) (Menden et al. 2023) and available through the European Genome-Phenome Archive (EGAC00001001879). From this study, we selected 13 C9orf72-expansion FTLD cases and 16 controls, restricting analyses to neuropathologically confirmed FTLD-C9 samples. This dataset served as an external validation cohort for differential expression, Bayesian deconvolution, and co-expression network findings from the Sant Pau FTLD-C9 dataset.\n\n\nCode\ndata&lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\")\ndata &lt;- data[data$DiseaseCode %in% c(\"control\", \"FTD-C9\"),]\ntable(data$DiseaseCode)\n\n\n\ncontrol  FTD-C9 \n     16      13 \n\n\n\n\nCode\ndata&lt;-read.delim(\"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\")\ndim(data)[1]\n\n\n[1] 49327\n\n\n\n\n\nValidation of FTLD-TDP results was performed using the dataset published by Pottier et al. (Pottier et al. 2018), which includes frontal cortex RNA-sequencing data from 44 FTLD-TDP cases and 24 controls. Only individuals with neuropathologically verified FTLD-TDP type A or B pathology were retained for analysis. This dataset provided an independent, high-powered external resource to assess the robustness of the Sant Pau FTLD-TDP differential expression, cell-state–specific transcriptional shifts, and co-expression modules.\n\n\nCode\ndata&lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\")\ndata &lt;- data[!data$GROUP %in% c(\"FTLD-TDP-C\"),]\ndata[!data$GROUP %in% c(\"Control\"),]&lt;- \"TDP\"\ntable(data$GROUP)\n\n\n\nControl     TDP \n     24      44 \n\n\n\n\nCode\ndata&lt;-read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\")\ndim(data)[1]\n\n\n[1] 64253"
  },
  {
    "objectID": "Introduction/Cohort.html#sant-pau-ftld-c9",
    "href": "Introduction/Cohort.html#sant-pau-ftld-c9",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "The first primary dataset was generated at Hospital de la Santa Creu i Sant Pau and included 11 individuals with FTLD due to a C9orf72 hexanucleotide repeat expansion (FTLD-C9) and 7 cognitively healthy controls. Diagnoses were neuropathologically verified, and all samples were sequenced from the frontal cortex. This cohort served as the discovery dataset for identifying disease-associated transcriptional changes, alterations in inferred cell-state composition, and correlations with C9orf72-specific neuropathological markers, including RNA foci, dipeptide repeat proteins (polyGA, polyGP, polyGR), and TDP-43–related measures.\n\n\nCode\ndata&lt;-read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", sheetIndex = 1)\ndata &lt;- data[data$group.ID %in% c(\"Healthy\", \"C9orf72\"),]\ntable(data$group.ID)\n\n\n\nC9orf72 Healthy \n     11       7 \n\n\n\n\nCode\ndata&lt;-read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\")\ndim(data)[1]\n\n\n[1] 57169"
  },
  {
    "objectID": "Introduction/Cohort.html#sant-pau-ftld-tdp",
    "href": "Introduction/Cohort.html#sant-pau-ftld-tdp",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "A second independent dataset from Sant Pau included 9 individuals with sporadic FTLD-TDP and 7 controls from the same anatomical region and processed using equivalent library preparation and sequencing pipelines. This cohort provided complementary transcriptomic profiling for FTLD-TDP, enabling direct comparison between genetic (C9orf72-associated) and sporadic TDP-43 proteinopathies within a harmonized experimental framework. Neuropathological quantification of pTDP-43 and STMN2 levels allowed integration of transcriptional changes with molecular markers of TDP-43 dysfunction.\n\n\nCode\ndata&lt;-read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", sheetIndex = 1)\ndata &lt;- data[data$group.ID %in% c(\"Healthy\", \"TDP\"),]\ntable(data$group.ID)\n\n\n\nHealthy     TDP \n      7       9 \n\n\n\n\nCode\ndata&lt;-read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\")\ndim(data)[1]\n\n\n[1] 57169"
  },
  {
    "objectID": "Introduction/Cohort.html#menden-et-al.-validation-cohort-ega",
    "href": "Introduction/Cohort.html#menden-et-al.-validation-cohort-ega",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "To evaluate the reproducibility of FTLD-C9 transcriptional signatures, we used the bulk RNA-seq dataset published by Menden et al. (2023) (Menden et al. 2023) and available through the European Genome-Phenome Archive (EGAC00001001879). From this study, we selected 13 C9orf72-expansion FTLD cases and 16 controls, restricting analyses to neuropathologically confirmed FTLD-C9 samples. This dataset served as an external validation cohort for differential expression, Bayesian deconvolution, and co-expression network findings from the Sant Pau FTLD-C9 dataset.\n\n\nCode\ndata&lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\")\ndata &lt;- data[data$DiseaseCode %in% c(\"control\", \"FTD-C9\"),]\ntable(data$DiseaseCode)\n\n\n\ncontrol  FTD-C9 \n     16      13 \n\n\n\n\nCode\ndata&lt;-read.delim(\"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\")\ndim(data)[1]\n\n\n[1] 49327"
  },
  {
    "objectID": "Introduction/Cohort.html#pottier-et-al.-validation-cohort",
    "href": "Introduction/Cohort.html#pottier-et-al.-validation-cohort",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "Validation of FTLD-TDP results was performed using the dataset published by Pottier et al. (Pottier et al. 2018), which includes frontal cortex RNA-sequencing data from 44 FTLD-TDP cases and 24 controls. Only individuals with neuropathologically verified FTLD-TDP type A or B pathology were retained for analysis. This dataset provided an independent, high-powered external resource to assess the robustness of the Sant Pau FTLD-TDP differential expression, cell-state–specific transcriptional shifts, and co-expression modules.\n\n\nCode\ndata&lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\")\ndata &lt;- data[!data$GROUP %in% c(\"FTLD-TDP-C\"),]\ndata[!data$GROUP %in% c(\"Control\"),]&lt;- \"TDP\"\ntable(data$GROUP)\n\n\n\nControl     TDP \n     24      44 \n\n\n\n\nCode\ndata&lt;-read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\")\ndim(data)[1]\n\n\n[1] 64253"
  },
  {
    "objectID": "Results/Sc_gene_correlation.html",
    "href": "Results/Sc_gene_correlation.html",
    "title": "Single cell gene correlation with neuropathology markers",
    "section": "",
    "text": "In excitatory neurons, correlations between cell-type markers and significantly deregulated genes in FTLD-C9 highlighted a consistent association with STMN2 expression, a gene central to axonal maintenance.\nAcross several RORB-characterized excitatory subtypes, including RORB/FOXO1, RORB/LRRK1 and RORB/ADGRL4, and PCP4/NXPH2, strong negative correlations with STMN2 were observed. Among these, the RORB/FOXO1 gene C9orf72 correlation with STMN2 (ρ = −0.99, p = 0,016), the RORB/LRRK1 genes STMN2 (ρ = −0.85, p = 0,0016), NPTX2 (ρ = −0.73, p = 0,013), C9orf72 (ρ = -0,85, p = 0,0016), SPP1 (ρ = −0.8, p = 0,005), the RORB/ADGRL4 C9orf72(ρ = -0,66, p = 0,0308), STMN2(ρ = -0,74, p = 0,011) and PCP4/NXPH2 STMN2 (ρ =-0.84, p = 0.001).\nTHEMIS- characterized cells also shown genes with STMN2 marker correlation. THEMIS/NR4A2 STMN2 (ρ =-0.65, p = 0.029), THEMIS/TMEM233 C9orf72(ρ =-0.66, p = 0.025), NPTX2(ρ =-0.63, p = 0.034) and STMN2(ρ =-0.75, p = 0.01), TLE4/MEGF11 STMN2(ρ =-0.65, p = 0.028) and TLE4/SEMA3D C9orf72(ρ =0.61, p = 0.046) and CX3CR1(ρ =0.82, p = 0.0016) .\nThese findings indicate that, although excitatory neuron proportions defined by RORB expression do not differ between FTLD-C9 and controls, their association with STMN2 expression reflects a dynamic remodeling of excitatory circuits along disease progression, suggesting that excitatory neuronal dysfunction is intimately linked to STMN2-associated pathology.\nOnly THEMIS/TMEM233 STMN2 expression shown correlation with pTDP43 marker (ρ = 0.809, p = 0.021). In non-neuronal populations, significant correlations with STMN2 expression were detected in oligodendrocytes. In it both C9orf72 (ρ = −0.64, p = 0.03) and STMN2 (ρ = −0.63, p = 0.04) were negatively correlated with STMN2, further reinforcing the presence of interactions in STMN2-dependent processes.\n\n\nCode\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(DT)\n\n# ============================================================\n# LOAD DATA\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/6. GENES OF INTERST CORRELATION/C9_genes_correlation_allCovs.csv\"\n\nfiltered &lt;- read.csv(file_path)\n\n# ============================================================\n# CLEAN COLUMN NAMES IF NEEDED\n# Some sheets have \"NA.\" or \"rho\" in first column.\n# Keep only meaningful columns: Cell, Gene, Spearman, p_value.\n# ============================================================\n\n# Try to detect the first unnamed column (if present)\nfirst_col &lt;- colnames(filtered)[1]\nif (first_col %in% c(\"NA.\", \"rho\", \"rho1\", \"\", NA)) {\n  filtered &lt;- filtered %&gt;% select(-1)\n}\n\n# ============================================================\n# FILTERABLE HTML TABLE FOR QUARTO\n# ============================================================\n\ndatatable(\n  filtered,\n  filter = \"top\",\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"frtip\"   # no download buttons\n  )\n)\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"pTDP43\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"ACSL3\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"lncRNA\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"STMN2\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"fociSENSE\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"fociANTI\"   \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"polyGP\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"polyGA\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"polyGP\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"polyGP\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"polyGP\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"polyGP\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"polyGP\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"polyGP Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"polyGP\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Sc_gene_correlation.html#c9",
    "href": "Results/Sc_gene_correlation.html#c9",
    "title": "Single cell gene correlation with neuropathology markers",
    "section": "",
    "text": "In excitatory neurons, correlations between cell-type markers and significantly deregulated genes in FTLD-C9 highlighted a consistent association with STMN2 expression, a gene central to axonal maintenance.\nAcross several RORB-characterized excitatory subtypes, including RORB/FOXO1, RORB/LRRK1 and RORB/ADGRL4, and PCP4/NXPH2, strong negative correlations with STMN2 were observed. Among these, the RORB/FOXO1 gene C9orf72 correlation with STMN2 (ρ = −0.99, p = 0,016), the RORB/LRRK1 genes STMN2 (ρ = −0.85, p = 0,0016), NPTX2 (ρ = −0.73, p = 0,013), C9orf72 (ρ = -0,85, p = 0,0016), SPP1 (ρ = −0.8, p = 0,005), the RORB/ADGRL4 C9orf72(ρ = -0,66, p = 0,0308), STMN2(ρ = -0,74, p = 0,011) and PCP4/NXPH2 STMN2 (ρ =-0.84, p = 0.001).\nTHEMIS- characterized cells also shown genes with STMN2 marker correlation. THEMIS/NR4A2 STMN2 (ρ =-0.65, p = 0.029), THEMIS/TMEM233 C9orf72(ρ =-0.66, p = 0.025), NPTX2(ρ =-0.63, p = 0.034) and STMN2(ρ =-0.75, p = 0.01), TLE4/MEGF11 STMN2(ρ =-0.65, p = 0.028) and TLE4/SEMA3D C9orf72(ρ =0.61, p = 0.046) and CX3CR1(ρ =0.82, p = 0.0016) .\nThese findings indicate that, although excitatory neuron proportions defined by RORB expression do not differ between FTLD-C9 and controls, their association with STMN2 expression reflects a dynamic remodeling of excitatory circuits along disease progression, suggesting that excitatory neuronal dysfunction is intimately linked to STMN2-associated pathology.\nOnly THEMIS/TMEM233 STMN2 expression shown correlation with pTDP43 marker (ρ = 0.809, p = 0.021). In non-neuronal populations, significant correlations with STMN2 expression were detected in oligodendrocytes. In it both C9orf72 (ρ = −0.64, p = 0.03) and STMN2 (ρ = −0.63, p = 0.04) were negatively correlated with STMN2, further reinforcing the presence of interactions in STMN2-dependent processes.\n\n\nCode\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(DT)\n\n# ============================================================\n# LOAD DATA\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/6. GENES OF INTERST CORRELATION/C9_genes_correlation_allCovs.csv\"\n\nfiltered &lt;- read.csv(file_path)\n\n# ============================================================\n# CLEAN COLUMN NAMES IF NEEDED\n# Some sheets have \"NA.\" or \"rho\" in first column.\n# Keep only meaningful columns: Cell, Gene, Spearman, p_value.\n# ============================================================\n\n# Try to detect the first unnamed column (if present)\nfirst_col &lt;- colnames(filtered)[1]\nif (first_col %in% c(\"NA.\", \"rho\", \"rho1\", \"\", NA)) {\n  filtered &lt;- filtered %&gt;% select(-1)\n}\n\n# ============================================================\n# FILTERABLE HTML TABLE FOR QUARTO\n# ============================================================\n\ndatatable(\n  filtered,\n  filter = \"top\",\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"frtip\"   # no download buttons\n  )\n)\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"pTDP43\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"ACSL3\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"lncRNA\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"STMN2\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"fociSENSE\"   # &lt;&lt;&lt; FORCE only pTDP43\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"fociANTI\"   \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"polyGP\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"polyGA\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"pTDP43\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"pTDP43\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"pTDP43\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"pTDP43\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"pTDP43 Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"pTDP43\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – ONLY pTDP43, SELECT CELL + GENE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\ncovariables &lt;- \"polyGP\"  \n\n# ============================================================\n# ---- COMPUTE CORRELATIONS ----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Gene = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  file_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(file_path)) next\n  \n  data &lt;- read.csv(file_path, row.names = \"X\")\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    subset_gene &lt;- data[common_ids, gene, drop = FALSE]\n    subset_cov  &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), ]\n    \n    result_corr &lt;- safe_cor(subset_gene[[1]], subset_cov[, \"polyGP\"])\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Gene = gene,\n                                Covariable = \"polyGP\",\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA ------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Gene = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names = 1)\n  rownames(expr_df) &lt;- gsub(\"^X\", \"\", rownames(expr_df))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", \"polyGP\")]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  cov_df &lt;- cov_df[!is.na(cov_df$pTDP43), ]\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), \"polyGP\"],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, gene),\n      text = paste0(\"&lt;b&gt;\", gene, \" in \", cell, \"&lt;/b&gt;&lt;br&gt;ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.75),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x,\n      y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Gene = gene)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER ------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Gene == gene_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + GENE ONLY ---------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(c, genes_list[1])),\n                list(title = paste(\"Cell:\", c))),\n    label = c\n  )\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(cells_list[1], g)),\n                list(title = paste(\"Gene:\", g))),\n    label = g\n  )\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY ------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], genes_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = \"polyGP Correlation Scatterplots\", x = 0.05),\n    xaxis = list(title = \"polyGP\"),\n    yaxis = list(title = \"Gene expression\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Cell State\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_gene,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\", yanchor = \"top\",\n        title = list(text = \"Gene\")\n      )\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Sc_gene_correlation.html#tdp",
    "href": "Results/Sc_gene_correlation.html#tdp",
    "title": "Single cell gene correlation with neuropathology markers",
    "section": "TDP",
    "text": "TDP\nIn excitatory neurons, correlations with TDP-43 burden revealed strong and consistent associations with STMN2 expression and TDP43b. The RORB/ADGRL4 subtype showed SPP1 (-0.81, 0.0078) and CX3CR1 (-0.79, 0.01) negatively correlating with TDP43 burden. RORB/LRRK1 subtype showed one of the most pronounced effects in correlation with TDP43b, with genes NPTX2 (ρ = −0.78, p = 0,017), STMN2 (ρ = −0.8, p = 0,013), C9orf72 (ρ = −0,8, p = 0,013), SPP1(ρ = −0.73, p = 0,031) and CX3CR1 (ρ = −0.71, p = 0,031) significativly negatively correlated.\nOther excitatory subtypes also showed significant negative correlations with TDP43b, including CUX2/RASGRF2 with NPTX2 (ρ = −0.7, p = 0.043) and RORB/POU3F2 with NPTX2 (ρ = −0.75 , p = 0.025) and CX3CR1 (ρ = −0.8 , p = 0.013).\nAdditionaly neuropathology marker STMN2 in CUX2/RORB also correlated negatively with NPTX2expression (ρ = −0.80 , p = 0.016). Together, these findings point to a robust inverse association between excitatory neuron signatures and STMN2 levels in the context of TDP-43 pathology, suggesting a central role of excitatory neuronal dysfunction in linking STMN2 downregulation with TDP-43 accumulation.\nIn non-neuronal populations, strong correlations with STMN2 were also observed. In TLE4/CCBE1 cells STMN2 pathology showed negative correlation, with C9orf72 (ρ = -0.76, p = 0.025), also the astrocyte GFAP - correlated negatively with C9orf72 in relation to TDP-43 burden (ρ = −0.73, p = 0.031).\nThese results highlight that astrocyte populations, and TLE4/CCBE1, display heterogeneous but significant associations between C9orf72 and TDP-43 burden, complementing the strong excitatory neuron correlations and underscoring the interplay between neuronal vulnerability and glial responses in FTLD-TDP.\n\n\nCode\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(DT)\n\n# ============================================================\n# LOAD DATA\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/6. GENES OF INTERST CORRELATION/ALL_genes_correlation.xlsx\"\n\nfiltered &lt;- readxl::read_excel(file_path, sheet = 1)\n\n# ============================================================\n# CLEAN COLUMN NAMES IF NEEDED\n# Some sheets have \"NA.\" or \"rho\" in first column.\n# Keep only meaningful columns: Cell, Gene, Spearman, p_value.\n# ============================================================\n\n# Try to detect the first unnamed column (if present)\nfirst_col &lt;- colnames(filtered)[1]\nif (first_col %in% c(\"NA.\", \"rho\", \"rho1\", \"\", NA)) {\n  filtered &lt;- filtered %&gt;% select(-1)\n}\n\n# ============================================================\n# FILTERABLE HTML TABLE FOR QUARTO\n# ============================================================\n\ndatatable(\n  filtered,\n  filter = \"top\",\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"frtip\"   # no download buttons\n  )\n)\n\n\n\n\n\n\n\npTDP43\n\n\nCode\n# ============================================================\n# INTERACTIVE SPEARMAN SCATTERPLOTS – ONLY TDP43b (TDP DATASET)\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\nclean_ids &lt;- function(x){\n  x %&gt;%\n    as.character() %&gt;%\n    trimws() %&gt;%\n    toupper() %&gt;%\n    gsub(\"^(X|LONG)\", \"\", .)\n}\n\n# ============================================================\n# ---- Load data ---------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\n\nOG_Covariables$X &lt;- clean_ids(OG_Covariables$X)\n\n# Force **only TDP43b**\ncovariable_to_use &lt;- \"TDP43b\"\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\n\n# ============================================================\n# ---- Compute correlations -----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell=character(),Gene=character(),\n                      Spearman=numeric(),p_value=numeric(),\n                      stringsAsFactors=FALSE)\n\nfor (cell in cells) {\n  \n  f &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(f)) next\n  \n  expr &lt;- read.csv(f, row.names=1)\n  rownames(expr) &lt;- clean_ids(rownames(expr))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(expr))) next\n    \n    common_ids &lt;- intersect(rownames(expr), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    gvals &lt;- expr[common_ids, gene]\n    covvals &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    rc &lt;- safe_cor(gvals, covvals)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell=cell,Gene=gene,\n                                Spearman=rc$estimate,\n                                p_value=rc$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- Build scatterplots -------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(Cell=character(), Gene=character(), trace_id=integer())\ntrace_index &lt;- 0\n\ncov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\ncov_df$X &lt;- clean_ids(cov_df$X)\ncov_df &lt;- cov_df[!is.na(cov_df[[covariable_to_use]]), ]\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names=1)\n  rownames(expr_df) &lt;- clean_ids(rownames(expr_df))\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x)==0 || sd(df$y)==0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method=\"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method=\"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y~x, data=df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out=100))\n    line_df$y &lt;- predict(lmfit, newdata=line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type=\"scatter\", mode=\"markers\",\n      x=df$x, y=df$y,\n      text=paste0(\"&lt;b&gt;\",gene,\" in \",cell,\"&lt;/b&gt;&lt;br&gt;\",\n                  \"ρ = \",round(rho,3),\"&lt;br&gt;\",\n                  \"p = \",signif(pval,3)),\n      hoverinfo=\"text\",\n      marker=list(size=7,opacity=0.7),\n      visible=FALSE\n    )\n    \n    # Regression\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type=\"scatter\", mode=\"lines\",\n      x=line_df$x, y=line_df$y,\n      line=list(width=2),\n      visible=FALSE\n    )\n    \n    meta &lt;- add_row(meta, Cell=cell, Gene=gene, trace_id=trace_index-1)\n  }\n}\n\n# ============================================================\n# ---- Visibility helper (2-dimensional) ----------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel){\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell==cell_sel & meta$Gene==gene_sel)\n  if (length(combo)==1){\n    idx &lt;- (combo-1)*2 + 1\n    vis[idx:(idx+1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- Dropdowns: Cell + Gene only ----------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c){\n  list(method=\"update\",\n       args=list(list(visible = make_vis(c, genes_list[1])),\n                 list(title=paste(\"Cell:\",c))),\n       label=c)\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g){\n  list(method=\"update\",\n       args=list(list(visible = make_vis(cells_list[1], g)),\n                 list(title=paste(\"Gene:\",g))),\n       label=g)\n})\n\n# ============================================================\n# ---- Initial visibility -------------------------------------\n# ============================================================\n\ninitial_vis &lt;- make_vis(cells_list[1], genes_list[1])\nfor(i in seq_along(all_traces)) all_traces[[i]]$visible &lt;- initial_vis[i]\n\n# ============================================================\n# ---- Build figure -------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor(tr in all_traces){\n  fig &lt;- fig %&gt;% add_trace(\n    type=tr$type, mode=tr$mode,\n    x=tr$x, y=tr$y,\n    text=tr$text, hoverinfo=tr$hoverinfo,\n    marker=tr$marker, line=tr$line,\n    visible=tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title=list(text=\"TDP43b Correlation Scatterplots\", x=0.05),\n    xaxis=list(title=\"TDP43b\"),\n    yaxis=list(title=\"Gene expression\"),\n    showlegend=FALSE,\n    updatemenus=list(\n      list(\n        y=1.15, x=0.0,\n        buttons=buttons_cell,\n        direction=\"down\",\n        showactive=TRUE,\n        title=list(text=\"Cell State\")\n      ),\n      list(\n        y=1.15, x=0.35,\n        buttons=buttons_gene,\n        direction=\"down\",\n        showactive=TRUE,\n        title=list(text=\"Gene\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\nSTMN2\n\n\nCode\n# ============================================================\n# INTERACTIVE SPEARMAN SCATTERPLOTS – ONLY TDP43b (TDP DATASET)\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\nclean_ids &lt;- function(x){\n  x %&gt;%\n    as.character() %&gt;%\n    trimws() %&gt;%\n    toupper() %&gt;%\n    gsub(\"^(X|LONG)\", \"\", .)\n}\n\n# ============================================================\n# ---- Load data ---------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE ORIGINAL/\"\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\n\nOG_Covariables$X &lt;- clean_ids(OG_Covariables$X)\n\n# Force **only TDP43b**\ncovariable_to_use &lt;- \"STMN2\"\n\ncells &lt;- c(\"CUX2_RASGRF2\",\"CUX2_RORB\",\"SCN4B_NEFH\",\"RORB_FOXO1\",\n           \"RORB_POU3F2\",\"RORB_ADGRL4\",\"RORB_LRRK1\",\"PCP4_NXPH2\",\n           \"VAT1L_EYA4\",\"VAT1L_THSD4\",\"THEMIS_NR4A2\",\"THEMIS_TMEM233\",\n           \"TLE4_CCBE1\",\"TLE4_MEGF11\",\"TLE4_SEMA3D\")\n\ngenes &lt;- c(\"STMN2\",\"NPTX2\",\"C9orf72\",\"CXCL10\",\"SPP1\",\"CX3CR1\")\n\n# ============================================================\n# ---- Compute correlations -----------------------------------\n# ============================================================\n\nresults &lt;- data.frame(Cell=character(),Gene=character(),\n                      Spearman=numeric(),p_value=numeric(),\n                      stringsAsFactors=FALSE)\n\nfor (cell in cells) {\n  \n  f &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(f)) next\n  \n  expr &lt;- read.csv(f, row.names=1)\n  rownames(expr) &lt;- clean_ids(rownames(expr))\n  \n  for (gene in genes) {\n    if (!(gene %in% colnames(expr))) next\n    \n    common_ids &lt;- intersect(rownames(expr), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    gvals &lt;- expr[common_ids, gene]\n    covvals &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    rc &lt;- safe_cor(gvals, covvals)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell=cell,Gene=gene,\n                                Spearman=rc$estimate,\n                                p_value=rc$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- Build scatterplots -------------------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(Cell=character(), Gene=character(), trace_id=integer())\ntrace_index &lt;- 0\n\ncov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\ncov_df$X &lt;- clean_ids(cov_df$X)\ncov_df &lt;- cov_df[!is.na(cov_df[[covariable_to_use]]), ]\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, paste0(cell, \".csv\"))\n  if (!file.exists(expr_path)) next\n  \n  expr_df &lt;- read.csv(expr_path, row.names=1)\n  rownames(expr_df) &lt;- clean_ids(rownames(expr_df))\n  \n  for (gene in unique(results$Gene)) {\n    if (!(gene %in% colnames(expr_df))) next\n    \n    common_ids &lt;- intersect(rownames(expr_df), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = expr_df[common_ids, gene]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x)==0 || sd(df$y)==0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method=\"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method=\"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y~x, data=df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out=100))\n    line_df$y &lt;- predict(lmfit, newdata=line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type=\"scatter\", mode=\"markers\",\n      x=df$x, y=df$y,\n      text=paste0(\"&lt;b&gt;\",gene,\" in \",cell,\"&lt;/b&gt;&lt;br&gt;\",\n                  \"ρ = \",round(rho,3),\"&lt;br&gt;\",\n                  \"p = \",signif(pval,3)),\n      hoverinfo=\"text\",\n      marker=list(size=7,opacity=0.7),\n      visible=FALSE\n    )\n    \n    # Regression\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type=\"scatter\", mode=\"lines\",\n      x=line_df$x, y=line_df$y,\n      line=list(width=2),\n      visible=FALSE\n    )\n    \n    meta &lt;- add_row(meta, Cell=cell, Gene=gene, trace_id=trace_index-1)\n  }\n}\n\n# ============================================================\n# ---- Visibility helper (2-dimensional) ----------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, gene_sel){\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell==cell_sel & meta$Gene==gene_sel)\n  if (length(combo)==1){\n    idx &lt;- (combo-1)*2 + 1\n    vis[idx:(idx+1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- Dropdowns: Cell + Gene only ----------------------------\n# ============================================================\n\ncells_list &lt;- unique(meta$Cell)\ngenes_list &lt;- unique(meta$Gene)\n\nbuttons_cell &lt;- lapply(cells_list, function(c){\n  list(method=\"update\",\n       args=list(list(visible = make_vis(c, genes_list[1])),\n                 list(title=paste(\"Cell:\",c))),\n       label=c)\n})\n\nbuttons_gene &lt;- lapply(genes_list, function(g){\n  list(method=\"update\",\n       args=list(list(visible = make_vis(cells_list[1], g)),\n                 list(title=paste(\"Gene:\",g))),\n       label=g)\n})\n\n# ============================================================\n# ---- Initial visibility -------------------------------------\n# ============================================================\n\ninitial_vis &lt;- make_vis(cells_list[1], genes_list[1])\nfor(i in seq_along(all_traces)) all_traces[[i]]$visible &lt;- initial_vis[i]\n\n# ============================================================\n# ---- Build figure -------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor(tr in all_traces){\n  fig &lt;- fig %&gt;% add_trace(\n    type=tr$type, mode=tr$mode,\n    x=tr$x, y=tr$y,\n    text=tr$text, hoverinfo=tr$hoverinfo,\n    marker=tr$marker, line=tr$line,\n    visible=tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title=list(text=\"TDP43b Correlation Scatterplots\", x=0.05),\n    xaxis=list(title=\"TDP43b\"),\n    yaxis=list(title=\"Gene expression\"),\n    showlegend=FALSE,\n    updatemenus=list(\n      list(\n        y=1.15, x=0.0,\n        buttons=buttons_cell,\n        direction=\"down\",\n        showactive=TRUE,\n        title=list(text=\"Cell State\")\n      ),\n      list(\n        y=1.15, x=0.35,\n        buttons=buttons_gene,\n        direction=\"down\",\n        showactive=TRUE,\n        title=list(text=\"Gene\")\n      )\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html",
    "href": "Results/Hdwgcna_C9_correlation.html",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "",
    "text": "Across the FTLD-C9 dataset, multiple co-expression modules showed significant correlations with neuropathological burden, revealing convergent alterations in pathways central to neuronal signaling, synaptic integrity, glial reactivity, and neuroimmune communication. Although some enriched terms reflected generic or peripheral biological processes, several modules captured high-value neurological functions that align with known or emerging mechanisms of FTLD.\n\n\nIn the CDH4/SCGN excitatory neuron population, multiple modules correlated strongly with STMN2 levels, a marker of TDP-43–related axonal dysfunction. Modules positively associated with STMN2 were enriched for dendritic structure, postsynaptic specialization, and voltage-gated ion channel activity, consistent with maintained synaptic excitability in individuals with preserved STMN2 expression. Conversely, STMN2-negative correlations highlighted reductions in cellular respiration, mitochondrial complex III activity, and pyruvate metabolism, suggesting that STMN2 loss is accompanied by impairments in neuronal energy metabolism—one of the best-established mechanisms linking TDP-43 pathology to neuronal degeneration.\nSimilarly, the SCN4B/NEFH neuronal module correlated positively with lncRNA pathology and pointed to disturbances in dopaminergic synapse function, autophagy regulation, and membrane-associated neurite assembly, indicating that lncRNA-associated toxicity may contribute to synaptic remodeling and lysosomal stress in vulnerable excitatory neuron subtypes.\nIn the SST/BRIN3P interneuron population, modules negatively associated with lncRNA burden highlighted alterations in hippocampal mossy-fiber→CA3 synaptic pathways and the function of primary (non-motile) neuronal cilia, structures increasingly implicated in synaptic homeostasis and neurodegenerative signaling. Another SST/BRIN3P module associated with polyGR levels showed upregulation of lipid and glycosphingolipid metabolism, protein refolding, and chromosome-segregation pathways, consistent with a stress-response phenotype.\nTogether, these findings indicate that lncRNA and dipeptide repeat pathology impact cortical neuronal circuits through combined disruption of synaptic connectivity, neuronal metabolic homeostasis, and cilia-dependent signaling.\n\n\n\nMultiple glial and vascular states displayed module–pathology correlations consistent with reactive gliosis, immune signaling, and neurovascular dysfunction, processes increasingly recognized as central contributors to FTLD-C9 pathogenesis.\nPericytes—key regulators of the blood–brain barrier—showed lncRNA-associated reductions in mitochondrial gene expression, ligand-gated channel activity, and detection of chemical stimuli, suggesting impaired neurovascular coupling and diminished pericyte-mediated support to neuronal activity.\nIn TLE4/SEMA3D excitatory neurons, lncRNA-associated modules highlighted pathways involved in glial cell migration, cytokine binding, and vascular development regulation, linking lncRNA burden to coordinated neuron–glia–vascular signaling alterations.\n\n\n\nT cells showed consistent associations with multiple pathology markers. Modules correlated with polyGA and polyGP highlighted functions relevant to chemical synaptic transmission, peptide receptor signaling, and lipid membrane metabolic processes, suggesting that dipeptide pathology may modulate neuroimmune metabolic crosstalk. Although some modules included olfactory-receptor–related terms (common artifacts in single-cell RNA-seq), several enrichment signals pointed to more functionally relevant processes such as cytokine-linked neuromodulation and immune–synaptic interactions.\nThe THEMIS/NR4A2 cell population also displayed lncRNA-associated modules enriched for functions affecting monocarboxylate transport, immunoglobulin binding, and spindle–microtubule attachment, pointing to alterations in metabolic shuttling, immune recognition, and cell-cycle regulation—all processes increasingly implicated in neuronal stress responses.\n\n\n\nRORB-defined excitatory neurons, one of the most vulnerable lineages in FTLD-C9, contained an lncRNA-correlated module enriched for leukocyte activation, regulation of interleukin-10 production, and antimicrobial peptide responses. Although immunological in nature, many of these pathways intersect with neuronal degeneration: IL-10 and antimicrobial peptide pathways have been linked to microglial activation, synaptic pruning, and neuronal stress signaling, suggesting that specific excitatory neuron populations may engage maladaptive immune–synaptic cross-talk under high lncRNA burden.\n\n\nCode\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Path to your file\npath &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/9. CORRELATION MODULES/Summary_Moduletraitcorrelations_C9.ods\"\n\n# 1) List all sheets (each sheet = one cell type)\nsheets &lt;- ods_sheets(path)\n\n# 2) Read each sheet safely\nall_data &lt;- map_dfr(sheets, function(sheetname) {\n\n  # read each sheet\n  df &lt;- tryCatch(\n    read_ods(path, sheet = sheetname),\n    error = function(e) NULL\n  )\n\n  # skip empty or NULL sheets\n  if (is.null(df) || nrow(df) == 0)\n    return(NULL)\n\n  # add cell type column\n  df %&gt;%\n    mutate(cell_type = sheetname)\n})\n\nall_data &lt;- all_data[,c(8,6,2,7,3,4,5)]\n\nlibrary(DT)\n\ndatatable(\n  all_data,\n  options = list(pageLength = 10, scrollX = TRUE),\n  rownames = FALSE\n)"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#c9",
    "href": "Results/Hdwgcna_C9_correlation.html#c9",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "",
    "text": "Across the FTLD-C9 dataset, multiple co-expression modules showed significant correlations with neuropathological burden, revealing convergent alterations in pathways central to neuronal signaling, synaptic integrity, glial reactivity, and neuroimmune communication. Although some enriched terms reflected generic or peripheral biological processes, several modules captured high-value neurological functions that align with known or emerging mechanisms of FTLD.\n\n\nIn the CDH4/SCGN excitatory neuron population, multiple modules correlated strongly with STMN2 levels, a marker of TDP-43–related axonal dysfunction. Modules positively associated with STMN2 were enriched for dendritic structure, postsynaptic specialization, and voltage-gated ion channel activity, consistent with maintained synaptic excitability in individuals with preserved STMN2 expression. Conversely, STMN2-negative correlations highlighted reductions in cellular respiration, mitochondrial complex III activity, and pyruvate metabolism, suggesting that STMN2 loss is accompanied by impairments in neuronal energy metabolism—one of the best-established mechanisms linking TDP-43 pathology to neuronal degeneration.\nSimilarly, the SCN4B/NEFH neuronal module correlated positively with lncRNA pathology and pointed to disturbances in dopaminergic synapse function, autophagy regulation, and membrane-associated neurite assembly, indicating that lncRNA-associated toxicity may contribute to synaptic remodeling and lysosomal stress in vulnerable excitatory neuron subtypes.\nIn the SST/BRIN3P interneuron population, modules negatively associated with lncRNA burden highlighted alterations in hippocampal mossy-fiber→CA3 synaptic pathways and the function of primary (non-motile) neuronal cilia, structures increasingly implicated in synaptic homeostasis and neurodegenerative signaling. Another SST/BRIN3P module associated with polyGR levels showed upregulation of lipid and glycosphingolipid metabolism, protein refolding, and chromosome-segregation pathways, consistent with a stress-response phenotype.\nTogether, these findings indicate that lncRNA and dipeptide repeat pathology impact cortical neuronal circuits through combined disruption of synaptic connectivity, neuronal metabolic homeostasis, and cilia-dependent signaling.\n\n\n\nMultiple glial and vascular states displayed module–pathology correlations consistent with reactive gliosis, immune signaling, and neurovascular dysfunction, processes increasingly recognized as central contributors to FTLD-C9 pathogenesis.\nPericytes—key regulators of the blood–brain barrier—showed lncRNA-associated reductions in mitochondrial gene expression, ligand-gated channel activity, and detection of chemical stimuli, suggesting impaired neurovascular coupling and diminished pericyte-mediated support to neuronal activity.\nIn TLE4/SEMA3D excitatory neurons, lncRNA-associated modules highlighted pathways involved in glial cell migration, cytokine binding, and vascular development regulation, linking lncRNA burden to coordinated neuron–glia–vascular signaling alterations.\n\n\n\nT cells showed consistent associations with multiple pathology markers. Modules correlated with polyGA and polyGP highlighted functions relevant to chemical synaptic transmission, peptide receptor signaling, and lipid membrane metabolic processes, suggesting that dipeptide pathology may modulate neuroimmune metabolic crosstalk. Although some modules included olfactory-receptor–related terms (common artifacts in single-cell RNA-seq), several enrichment signals pointed to more functionally relevant processes such as cytokine-linked neuromodulation and immune–synaptic interactions.\nThe THEMIS/NR4A2 cell population also displayed lncRNA-associated modules enriched for functions affecting monocarboxylate transport, immunoglobulin binding, and spindle–microtubule attachment, pointing to alterations in metabolic shuttling, immune recognition, and cell-cycle regulation—all processes increasingly implicated in neuronal stress responses.\n\n\n\nRORB-defined excitatory neurons, one of the most vulnerable lineages in FTLD-C9, contained an lncRNA-correlated module enriched for leukocyte activation, regulation of interleukin-10 production, and antimicrobial peptide responses. Although immunological in nature, many of these pathways intersect with neuronal degeneration: IL-10 and antimicrobial peptide pathways have been linked to microglial activation, synaptic pruning, and neuronal stress signaling, suggesting that specific excitatory neuron populations may engage maladaptive immune–synaptic cross-talk under high lncRNA burden.\n\n\nCode\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Path to your file\npath &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/9. CORRELATION MODULES/Summary_Moduletraitcorrelations_C9.ods\"\n\n# 1) List all sheets (each sheet = one cell type)\nsheets &lt;- ods_sheets(path)\n\n# 2) Read each sheet safely\nall_data &lt;- map_dfr(sheets, function(sheetname) {\n\n  # read each sheet\n  df &lt;- tryCatch(\n    read_ods(path, sheet = sheetname),\n    error = function(e) NULL\n  )\n\n  # skip empty or NULL sheets\n  if (is.null(df) || nrow(df) == 0)\n    return(NULL)\n\n  # add cell type column\n  df %&gt;%\n    mutate(cell_type = sheetname)\n})\n\nall_data &lt;- all_data[,c(8,6,2,7,3,4,5)]\n\nlibrary(DT)\n\ndatatable(\n  all_data,\n  options = list(pageLength = 10, scrollX = TRUE),\n  rownames = FALSE\n)"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#stmn2",
    "href": "Results/Hdwgcna_C9_correlation.html#stmn2",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "STMN2",
    "text": "STMN2\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"STMN2\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#acsl3",
    "href": "Results/Hdwgcna_C9_correlation.html#acsl3",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "ACSL3",
    "text": "ACSL3\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"ACSL3\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#polyga",
    "href": "Results/Hdwgcna_C9_correlation.html#polyga",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "polyGA",
    "text": "polyGA\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"polyGA\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#polygp",
    "href": "Results/Hdwgcna_C9_correlation.html#polygp",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "polyGP",
    "text": "polyGP\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"polyGP\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#polygr",
    "href": "Results/Hdwgcna_C9_correlation.html#polygr",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "polyGR",
    "text": "polyGR\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"polyGR\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#focisense",
    "href": "Results/Hdwgcna_C9_correlation.html#focisense",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "fociSENSE",
    "text": "fociSENSE\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"fociSENSE\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#focianti",
    "href": "Results/Hdwgcna_C9_correlation.html#focianti",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "fociANTI",
    "text": "fociANTI\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"fociANTI\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#lncrna",
    "href": "Results/Hdwgcna_C9_correlation.html#lncrna",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "lncRNA",
    "text": "lncRNA\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"lncRNA\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_C9_correlation.html#ptdp43",
    "href": "Results/Hdwgcna_C9_correlation.html#ptdp43",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "pTDP43",
    "text": "pTDP43\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"pTDP43\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^X\", \"\", cov_df$X)\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_differences.html",
    "href": "Results/Hdwgcna_differences.html",
    "title": "Gene modules differences",
    "section": "",
    "text": "The co-expression network analysis of FTLD-C9 identified distinct modular organizations within 22 of the 44 individual cell states analyzed, revealing a spectrum of transcriptional complexities across vascular, neural, and immune populations.\nAmong the calculated co-expression modules there were some of them with differences between FTLD cases and healthy controls in 19 of the 22 cell states. Remarkably we find 13 differentially expressed modules in RORB/ADGRL4 and 14 in T CELL.\nThe biological functional enrichment shown differences on the pathways of the different cell states.\nThe excitatory neurons have modules that pioint to an enrichmentin fucntions related to immune responses and cell migration. RORB characterized excitatory neurons are associated with mononuclear cell migration, on ADGRL4 enriched and in LRRK1 reduced. RORB/POU3F2 neuron diferenciation function was found reduced as well as mononuclear cell migration, but leukocyte migration onflamatory process is enriched. CUX2/RASGRF2 shown enrichment in regulation of celular senecense and leukocyte apoptotic process. Among the excitatory neurons cell states it also was seen that THEMIS/NR4A2 is negatively associated with learning and memory.\nInhibitory cell states shown less modules associated to FTLD than the found in excitatory ones. This modules are mostly functionally reduced in several immune response and inflammatory processes like regulation of intrinsic apoptotic pathway in LAMP5/PMEPA1. The cell state SST/BRIN3 shown a totally different group of associated biological functions with a reduction on eating and adult behaviors.\nVascular cells modules biological functions enrichment point to a reduction in external encapsulating structure-related pathways. We find different increased biological pathways among the cells on this group. Arterial and capillary show mostly transcription, structures and organization functions. SMC and T Cell enriched functions indicate a immune respone and cell regulation activation on this cell states.\nThe non-neuronal cell states mostly point to immune processes but the states individually also indicate other different enriched functions. GFAP – is associated with mononuclear cell migration and mRNA CIS splicing. Oligodendrocytes are enriched in regulation of muscle cell apoptosis and RNA translation processes.\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(DT)\n\n# ============================================================\n# AUTO-DETECT FILE TYPE (ODS vs XLSX)\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/8. DIFFERENCES IN MODULES/FTLD-C9-Modules.xlsx\"\n\nfile_type &lt;- tryCatch({\n  readxl::excel_sheets(file_path)\n  \"xlsx\"\n}, error = function(e) \"ods\")\n\nmessage(\"Detected file type: \", file_type)\n\n# ============================================================\n# FUNCTION TO READ ONE SHEET + ADD CELL COLUMN\n# ============================================================\n\nread_one_sheet &lt;- function(path, sheet, type) {\n  \n  df &lt;- tryCatch({\n    if (type == \"xlsx\") readxl::read_excel(path, sheet = sheet)\n    else readODS::read_ods(path, sheet = sheet)\n  }, error = function(e) data.frame())\n  \n  if (nrow(df) == 0) df &lt;- data.frame()\n  \n  df %&gt;%\n    tibble::as_tibble() %&gt;%\n    mutate(cell = sheet, .before = 1)\n}\n\n# ============================================================\n# READ ALL SHEETS\n# ============================================================\n\nsheets &lt;- if (file_type == \"xlsx\") {\n  readxl::excel_sheets(file_path)\n} else {\n  readODS::ods_sheets(file_path)\n}\n\nall_tables &lt;- lapply(sheets, function(s) read_one_sheet(file_path, s, file_type))\nnames(all_tables) &lt;- sheets\n\nmerged &lt;- bind_rows(all_tables)\n\n# ============================================================\n# FILTERABLE HTML TABLE (DT)\n# ============================================================\n\ndatatable(\n  merged,\n  filter = \"top\",          # &lt;-- FILTER ROWS\n  extensions = c(\"Buttons\"),\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"Bfrtip\"\n  )\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(DT)\n\n# ============================================================\n# AUTO-DETECT FILE TYPE (ODS vs XLSX)\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/8. DIFFERENCES IN MODULES/Rimmod-Modules.xlsx\"\n\nfile_type &lt;- tryCatch({\n  readxl::excel_sheets(file_path)\n  \"xlsx\"\n}, error = function(e) \"ods\")\n\nmessage(\"Detected file type: \", file_type)\n\n# ============================================================\n# FUNCTION TO READ ONE SHEET + ADD CELL COLUMN\n# ============================================================\n\nread_one_sheet &lt;- function(path, sheet, type) {\n  \n  df &lt;- tryCatch({\n    if (type == \"xlsx\") readxl::read_excel(path, sheet = sheet)\n    else readODS::read_ods(path, sheet = sheet)\n  }, error = function(e) data.frame())\n  \n  if (nrow(df) == 0) df &lt;- data.frame()\n  \n  df %&gt;%\n    tibble::as_tibble() %&gt;%\n    mutate(cell = sheet, .before = 1)\n}\n\n# ============================================================\n# READ ALL SHEETS\n# ============================================================\n\nsheets &lt;- if (file_type == \"xlsx\") {\n  readxl::excel_sheets(file_path)\n} else {\n  readODS::ods_sheets(file_path)\n}\n\nall_tables &lt;- lapply(sheets, function(s) read_one_sheet(file_path, s, file_type))\nnames(all_tables) &lt;- sheets\n\nmerged &lt;- bind_rows(all_tables)\n\n# ============================================================\n# FILTERABLE HTML TABLE (DT)\n# ============================================================\n\ndatatable(\n  merged,\n  filter = \"top\",          # &lt;-- FILTER ROWS\n  extensions = c(\"Buttons\"),\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"Bfrtip\"\n  )\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(plotly)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(hdWGCNA)\n\n# ---- Base directory containing cell-state folders ----\nbase_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS\"\n\n# ---- Detect folders that contain a Seurat object ----\ncell_states &lt;- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)\ncell_states &lt;- cell_states[\n  file.exists(file.path(cell_states, paste0(basename(cell_states), \"_seurat.rds\")))\n]\nnames(cell_states) &lt;- basename(cell_states)\n\nmessage(\"📂 Found \", length(cell_states), \" cell states with Seurat objects: \",\n        paste(names(cell_states), collapse = \", \"))\n\n# ---- Prepare metadata ----\nmeta_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\n\n# Assuming this is a tab-delimited text table with sample IDs in the first column:\nmetadata_df &lt;- read.delim(\n  meta_path,\n  header = TRUE,\n  row.names = 1,        # first column = sample ID\n  check.names = FALSE,\n  stringsAsFactors = FALSE\n)\n\n# Create a cleaned sample ID column to match Seurat metadata later\nmetadata_df$Sample_clean &lt;- gsub(\"^X\", \"\", rownames(metadata_df))\n\nmessage(\"✅ Loaded metadata with \", nrow(metadata_df), \" samples and \",\n        ncol(metadata_df), \" columns.\")\nhead(metadata_df[, c(\"Sample_clean\")])\n\n\n[1] \"rimod1\"  \"rimod11\" \"rimod12\" \"rimod13\" \"rimod15\" \"rimod16\"\n\n\nCode\n# ---- Load eigengenes for all cell states ----\nME_list &lt;- list()\n\n# Detect grouping column\ngroup_col &lt;- \"DiseaseCode\"\nif (is.na(group_col)) stop(\"❌ Could not find a valid group/condition column in metadata.\")\n\nfor (cs in names(cell_states)) {\n  message(\"➡️ Processing \", cs)\n  A &lt;- readRDS(file.path(cell_states[cs], paste0(cs, \"_seurat.rds\")))\n  \n  # Harmonize metadata\n  A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n  meta_joined &lt;- A@meta.data %&gt;%\n    mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n    left_join(metadata_df, by = \"Sample_clean\")\n  A@meta.data &lt;- meta_joined\n  \n  # Debug info\n  message(\"   Columns in metadata after join: \", paste(colnames(A@meta.data), collapse = \", \"))\n  message(\"   Unique condition values: \",\n          paste(unique(na.omit(A@meta.data[[group_col]])), collapse = \", \"))\n  \n  # Extract module eigengenes\n  MEs &lt;- hdWGCNA::GetMEs(A)\n  sample_order &lt;- rownames(MEs)\n  \n  group_vector &lt;- A@meta.data[match(sample_order, A@meta.data$Sample), group_col]\n  group_vector &lt;- as.factor(group_vector)\n  \n  df_long &lt;- as_tibble(MEs, rownames = \"Sample\") %&gt;%\n    pivot_longer(-Sample, names_to = \"Module\", values_to = \"MEvalue\") %&gt;%\n    mutate(CellState = cs,\n           Condition = group_vector[match(Sample, sample_order)])\n  \n  ME_list[[cs]] &lt;- df_long\n  rm(A)\n}\n\nME_all &lt;- bind_rows(ME_list)\nME_all &lt;- ME_all %&gt;% drop_na(Condition)\n\n# ---- Create interactive boxplots ----\nfig &lt;- plot_ly(type = \"box\")\n\n# Each combination of CellState × Module becomes a separate trace\nunique_pairs &lt;- ME_all %&gt;% distinct(CellState, Module)\n\nfor (i in seq_len(nrow(unique_pairs))) {\n  cs  &lt;- unique_pairs$CellState[i]\n  mod &lt;- unique_pairs$Module[i]\n  df  &lt;- ME_all %&gt;% filter(CellState == cs, Module == mod)\n  \n  fig &lt;- fig %&gt;% add_boxplot(\n    data = df,\n    x = ~Condition,\n    y = ~MEvalue,\n    name = paste(cs, mod),\n    boxpoints = \"all\",\n    jitter = 0.4,\n    marker = list(opacity = 0.6, size = 4),\n    line = list(width = 1),\n    visible = ifelse(i == 1, TRUE, FALSE)\n  )\n}\n\n# ---- Dropdown menus ----\ncells  &lt;- unique(ME_all$CellState)\nmods   &lt;- unique(ME_all$Module)\nn_combo &lt;- nrow(unique_pairs)\n\n# visibility control function\nmake_vis &lt;- function(cell_idx, mod_idx) {\n  vis &lt;- rep(FALSE, n_combo)\n  # which trace corresponds to this combination\n  idx &lt;- which(unique_pairs$CellState == cells[cell_idx] &\n               unique_pairs$Module    == mods[mod_idx])\n  if (length(idx) == 1) vis[idx] &lt;- TRUE\n  vis\n}\n\nbuttons_cell &lt;- lapply(seq_along(cells), function(i) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(i, 1)),\n                list(title = paste0(\"Cell state: \", cells[i]))),\n    label = cells[i]\n  )\n})\n\nbuttons_mod &lt;- lapply(seq_along(mods), function(j) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(1, j)),\n                list(title = paste0(\"Module: \", mods[j]))),\n    label = mods[j]\n  )\n})\n\n# ---- Layout ----\nfig &lt;- fig %&gt;%\n  layout(\n    title = paste0(\"Module eigengenes — \", cells[1], \" / \", mods[1]),\n    yaxis = list(title = \"Module eigengene value\", autorange = TRUE),\n    xaxis = list(title = \"Condition\"),\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        pad = list(r = 10, t = 10),\n        xanchor = \"left\", yanchor = \"top\",\n        name = \"CellState\", title = list(text = \"Cell state\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_mod,\n        direction = \"down\",\n        showactive = TRUE,\n        pad = list(r = 10, t = 10),\n        xanchor = \"left\", yanchor = \"top\",\n        name = \"Module\", title = list(text = \"Module\")\n      )\n    ),\n    showlegend = FALSE\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_differences.html#c9",
    "href": "Results/Hdwgcna_differences.html#c9",
    "title": "Gene modules differences",
    "section": "",
    "text": "The co-expression network analysis of FTLD-C9 identified distinct modular organizations within 22 of the 44 individual cell states analyzed, revealing a spectrum of transcriptional complexities across vascular, neural, and immune populations.\nAmong the calculated co-expression modules there were some of them with differences between FTLD cases and healthy controls in 19 of the 22 cell states. Remarkably we find 13 differentially expressed modules in RORB/ADGRL4 and 14 in T CELL.\nThe biological functional enrichment shown differences on the pathways of the different cell states.\nThe excitatory neurons have modules that pioint to an enrichmentin fucntions related to immune responses and cell migration. RORB characterized excitatory neurons are associated with mononuclear cell migration, on ADGRL4 enriched and in LRRK1 reduced. RORB/POU3F2 neuron diferenciation function was found reduced as well as mononuclear cell migration, but leukocyte migration onflamatory process is enriched. CUX2/RASGRF2 shown enrichment in regulation of celular senecense and leukocyte apoptotic process. Among the excitatory neurons cell states it also was seen that THEMIS/NR4A2 is negatively associated with learning and memory.\nInhibitory cell states shown less modules associated to FTLD than the found in excitatory ones. This modules are mostly functionally reduced in several immune response and inflammatory processes like regulation of intrinsic apoptotic pathway in LAMP5/PMEPA1. The cell state SST/BRIN3 shown a totally different group of associated biological functions with a reduction on eating and adult behaviors.\nVascular cells modules biological functions enrichment point to a reduction in external encapsulating structure-related pathways. We find different increased biological pathways among the cells on this group. Arterial and capillary show mostly transcription, structures and organization functions. SMC and T Cell enriched functions indicate a immune respone and cell regulation activation on this cell states.\nThe non-neuronal cell states mostly point to immune processes but the states individually also indicate other different enriched functions. GFAP – is associated with mononuclear cell migration and mRNA CIS splicing. Oligodendrocytes are enriched in regulation of muscle cell apoptosis and RNA translation processes.\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(DT)\n\n# ============================================================\n# AUTO-DETECT FILE TYPE (ODS vs XLSX)\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/8. DIFFERENCES IN MODULES/FTLD-C9-Modules.xlsx\"\n\nfile_type &lt;- tryCatch({\n  readxl::excel_sheets(file_path)\n  \"xlsx\"\n}, error = function(e) \"ods\")\n\nmessage(\"Detected file type: \", file_type)\n\n# ============================================================\n# FUNCTION TO READ ONE SHEET + ADD CELL COLUMN\n# ============================================================\n\nread_one_sheet &lt;- function(path, sheet, type) {\n  \n  df &lt;- tryCatch({\n    if (type == \"xlsx\") readxl::read_excel(path, sheet = sheet)\n    else readODS::read_ods(path, sheet = sheet)\n  }, error = function(e) data.frame())\n  \n  if (nrow(df) == 0) df &lt;- data.frame()\n  \n  df %&gt;%\n    tibble::as_tibble() %&gt;%\n    mutate(cell = sheet, .before = 1)\n}\n\n# ============================================================\n# READ ALL SHEETS\n# ============================================================\n\nsheets &lt;- if (file_type == \"xlsx\") {\n  readxl::excel_sheets(file_path)\n} else {\n  readODS::ods_sheets(file_path)\n}\n\nall_tables &lt;- lapply(sheets, function(s) read_one_sheet(file_path, s, file_type))\nnames(all_tables) &lt;- sheets\n\nmerged &lt;- bind_rows(all_tables)\n\n# ============================================================\n# FILTERABLE HTML TABLE (DT)\n# ============================================================\n\ndatatable(\n  merged,\n  filter = \"top\",          # &lt;-- FILTER ROWS\n  extensions = c(\"Buttons\"),\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"Bfrtip\"\n  )\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(DT)\n\n# ============================================================\n# AUTO-DETECT FILE TYPE (ODS vs XLSX)\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/8. DIFFERENCES IN MODULES/Rimmod-Modules.xlsx\"\n\nfile_type &lt;- tryCatch({\n  readxl::excel_sheets(file_path)\n  \"xlsx\"\n}, error = function(e) \"ods\")\n\nmessage(\"Detected file type: \", file_type)\n\n# ============================================================\n# FUNCTION TO READ ONE SHEET + ADD CELL COLUMN\n# ============================================================\n\nread_one_sheet &lt;- function(path, sheet, type) {\n  \n  df &lt;- tryCatch({\n    if (type == \"xlsx\") readxl::read_excel(path, sheet = sheet)\n    else readODS::read_ods(path, sheet = sheet)\n  }, error = function(e) data.frame())\n  \n  if (nrow(df) == 0) df &lt;- data.frame()\n  \n  df %&gt;%\n    tibble::as_tibble() %&gt;%\n    mutate(cell = sheet, .before = 1)\n}\n\n# ============================================================\n# READ ALL SHEETS\n# ============================================================\n\nsheets &lt;- if (file_type == \"xlsx\") {\n  readxl::excel_sheets(file_path)\n} else {\n  readODS::ods_sheets(file_path)\n}\n\nall_tables &lt;- lapply(sheets, function(s) read_one_sheet(file_path, s, file_type))\nnames(all_tables) &lt;- sheets\n\nmerged &lt;- bind_rows(all_tables)\n\n# ============================================================\n# FILTERABLE HTML TABLE (DT)\n# ============================================================\n\ndatatable(\n  merged,\n  filter = \"top\",          # &lt;-- FILTER ROWS\n  extensions = c(\"Buttons\"),\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"Bfrtip\"\n  )\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(plotly)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(hdWGCNA)\n\n# ---- Base directory containing cell-state folders ----\nbase_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS\"\n\n# ---- Detect folders that contain a Seurat object ----\ncell_states &lt;- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)\ncell_states &lt;- cell_states[\n  file.exists(file.path(cell_states, paste0(basename(cell_states), \"_seurat.rds\")))\n]\nnames(cell_states) &lt;- basename(cell_states)\n\nmessage(\"📂 Found \", length(cell_states), \" cell states with Seurat objects: \",\n        paste(names(cell_states), collapse = \", \"))\n\n# ---- Prepare metadata ----\nmeta_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\n\n# Assuming this is a tab-delimited text table with sample IDs in the first column:\nmetadata_df &lt;- read.delim(\n  meta_path,\n  header = TRUE,\n  row.names = 1,        # first column = sample ID\n  check.names = FALSE,\n  stringsAsFactors = FALSE\n)\n\n# Create a cleaned sample ID column to match Seurat metadata later\nmetadata_df$Sample_clean &lt;- gsub(\"^X\", \"\", rownames(metadata_df))\n\nmessage(\"✅ Loaded metadata with \", nrow(metadata_df), \" samples and \",\n        ncol(metadata_df), \" columns.\")\nhead(metadata_df[, c(\"Sample_clean\")])\n\n\n[1] \"rimod1\"  \"rimod11\" \"rimod12\" \"rimod13\" \"rimod15\" \"rimod16\"\n\n\nCode\n# ---- Load eigengenes for all cell states ----\nME_list &lt;- list()\n\n# Detect grouping column\ngroup_col &lt;- \"DiseaseCode\"\nif (is.na(group_col)) stop(\"❌ Could not find a valid group/condition column in metadata.\")\n\nfor (cs in names(cell_states)) {\n  message(\"➡️ Processing \", cs)\n  A &lt;- readRDS(file.path(cell_states[cs], paste0(cs, \"_seurat.rds\")))\n  \n  # Harmonize metadata\n  A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n  meta_joined &lt;- A@meta.data %&gt;%\n    mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n    left_join(metadata_df, by = \"Sample_clean\")\n  A@meta.data &lt;- meta_joined\n  \n  # Debug info\n  message(\"   Columns in metadata after join: \", paste(colnames(A@meta.data), collapse = \", \"))\n  message(\"   Unique condition values: \",\n          paste(unique(na.omit(A@meta.data[[group_col]])), collapse = \", \"))\n  \n  # Extract module eigengenes\n  MEs &lt;- hdWGCNA::GetMEs(A)\n  sample_order &lt;- rownames(MEs)\n  \n  group_vector &lt;- A@meta.data[match(sample_order, A@meta.data$Sample), group_col]\n  group_vector &lt;- as.factor(group_vector)\n  \n  df_long &lt;- as_tibble(MEs, rownames = \"Sample\") %&gt;%\n    pivot_longer(-Sample, names_to = \"Module\", values_to = \"MEvalue\") %&gt;%\n    mutate(CellState = cs,\n           Condition = group_vector[match(Sample, sample_order)])\n  \n  ME_list[[cs]] &lt;- df_long\n  rm(A)\n}\n\nME_all &lt;- bind_rows(ME_list)\nME_all &lt;- ME_all %&gt;% drop_na(Condition)\n\n# ---- Create interactive boxplots ----\nfig &lt;- plot_ly(type = \"box\")\n\n# Each combination of CellState × Module becomes a separate trace\nunique_pairs &lt;- ME_all %&gt;% distinct(CellState, Module)\n\nfor (i in seq_len(nrow(unique_pairs))) {\n  cs  &lt;- unique_pairs$CellState[i]\n  mod &lt;- unique_pairs$Module[i]\n  df  &lt;- ME_all %&gt;% filter(CellState == cs, Module == mod)\n  \n  fig &lt;- fig %&gt;% add_boxplot(\n    data = df,\n    x = ~Condition,\n    y = ~MEvalue,\n    name = paste(cs, mod),\n    boxpoints = \"all\",\n    jitter = 0.4,\n    marker = list(opacity = 0.6, size = 4),\n    line = list(width = 1),\n    visible = ifelse(i == 1, TRUE, FALSE)\n  )\n}\n\n# ---- Dropdown menus ----\ncells  &lt;- unique(ME_all$CellState)\nmods   &lt;- unique(ME_all$Module)\nn_combo &lt;- nrow(unique_pairs)\n\n# visibility control function\nmake_vis &lt;- function(cell_idx, mod_idx) {\n  vis &lt;- rep(FALSE, n_combo)\n  # which trace corresponds to this combination\n  idx &lt;- which(unique_pairs$CellState == cells[cell_idx] &\n               unique_pairs$Module    == mods[mod_idx])\n  if (length(idx) == 1) vis[idx] &lt;- TRUE\n  vis\n}\n\nbuttons_cell &lt;- lapply(seq_along(cells), function(i) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(i, 1)),\n                list(title = paste0(\"Cell state: \", cells[i]))),\n    label = cells[i]\n  )\n})\n\nbuttons_mod &lt;- lapply(seq_along(mods), function(j) {\n  list(\n    method = \"update\",\n    args = list(list(visible = make_vis(1, j)),\n                list(title = paste0(\"Module: \", mods[j]))),\n    label = mods[j]\n  )\n})\n\n# ---- Layout ----\nfig &lt;- fig %&gt;%\n  layout(\n    title = paste0(\"Module eigengenes — \", cells[1], \" / \", mods[1]),\n    yaxis = list(title = \"Module eigengene value\", autorange = TRUE),\n    xaxis = list(title = \"Condition\"),\n    updatemenus = list(\n      list(\n        y = 1.15, x = 0,\n        buttons = buttons_cell,\n        direction = \"down\",\n        showactive = TRUE,\n        pad = list(r = 10, t = 10),\n        xanchor = \"left\", yanchor = \"top\",\n        name = \"CellState\", title = list(text = \"Cell state\")\n      ),\n      list(\n        y = 1.15, x = 0.35,\n        buttons = buttons_mod,\n        direction = \"down\",\n        showactive = TRUE,\n        pad = list(r = 10, t = 10),\n        xanchor = \"left\", yanchor = \"top\",\n        name = \"Module\", title = list(text = \"Module\")\n      )\n    ),\n    showlegend = FALSE\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_differences.html#tdp",
    "href": "Results/Hdwgcna_differences.html#tdp",
    "title": "Gene modules differences",
    "section": "TDP",
    "text": "TDP\nFor the FTLD-TDP data, the co-expression network analysis identified distinct modular organizations within 19 of the 44 individual cell states analyzed, revealing a spectrum of transcriptional complexities across vascular, neural, and immune populations. Among these, differences between FTLD-TDP cases and healthy controls were observed in multiple cell states, reflecting widespread disease-associated transcriptional alterations. CLMP/PDGFRA cells exhibited the highest modular complexity with 44 discrete gene co-expression modules, indicating diverse stromal or vascular regulatory programs.\nArterial and capillary endothelial cells displayed 38 modules each, consistent with specialized vascular functions. CDH4/SCGN cells contained 40 modules, suggesting potential transitional or hybrid endothelial-neuroendocrine roles. Microglia, as central innate immune cells, exhibited 40 modules, underscoring dynamic transcriptional responsiveness in FTLD-TDP.\nNeural lineage populations showed variable modular organization. GFAP - glial cells contained 37 modules, whereas GFAP + glial cells had 26 modules, suggesting differential regulatory states based on GFAP expression. CUX2/RASGRF2 modules numbered 33, and LAMP5/PMEPA1 modules 20. Oligodendrocytes and OPCs showed lower modular complexity, with 6 and 18 modules respectively, reflecting restricted developmental programs.\nAmong RORB-expressing cells, modularity varied by transcriptional context: RORB/FOXO1 had 38 modules, RORB/POU3F2 35, RORB/ADGRL4 22, and RORB/LRRK1 19 modules, indicating context-dependent RORB regulatory networks. Smooth muscle cells (SMC) and T cells exhibited intermediate complexity with 34 and 36 modules respectively, while TLE4/CCBE1 had 27 modules, reflecting moderate regulatory intricacy.\n\nSant Pau\n\n\nCode\nlibrary(readxl)\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(DT)\n\n# ============================================================\n# AUTO-DETECT FILE TYPE (ODS vs XLSX)\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/8. DIFFERENCES IN MODULES/FTLD-TDP-Modules.xlsx\"\n\nfile_type &lt;- tryCatch({\n  readxl::excel_sheets(file_path)\n  \"xlsx\"\n}, error = function(e) \"ods\")\n\nmessage(\"Detected file type: \", file_type)\n\n# ============================================================\n# FUNCTION TO READ ONE SHEET + ADD CELL COLUMN\n# ============================================================\n\nread_one_sheet &lt;- function(path, sheet, type) {\n  \n  df &lt;- tryCatch({\n    if (type == \"xlsx\") readxl::read_excel(path, sheet = sheet)\n    else readODS::read_ods(path, sheet = sheet)\n  }, error = function(e) data.frame())\n  \n  if (nrow(df) == 0) df &lt;- data.frame()\n  \n  df %&gt;%\n    tibble::as_tibble() %&gt;%\n    mutate(cell = sheet, .before = 1)\n}\n\n# ============================================================\n# READ ALL SHEETS\n# ============================================================\n\nsheets &lt;- if (file_type == \"xlsx\") {\n  readxl::excel_sheets(file_path)\n} else {\n  readODS::ods_sheets(file_path)\n}\n\nall_tables &lt;- lapply(sheets, function(s) read_one_sheet(file_path, s, file_type))\nnames(all_tables) &lt;- sheets\n\nmerged &lt;- bind_rows(all_tables)\n\n# ============================================================\n# FILTERABLE HTML TABLE (DT)\n# ============================================================\n\ndatatable(\n  merged,\n  filter = \"top\",          # &lt;-- FILTER ROWS\n  extensions = c(\"Buttons\"),\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"Bfrtip\"\n  )\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPottier\n\n\nCode\nlibrary(readxl)\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(DT)\n\n# ============================================================\n# AUTO-DETECT FILE TYPE (ODS vs XLSX)\n# ============================================================\n\nfile_path &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/8. DIFFERENCES IN MODULES/Pottier-Modules.xlsx\"\n\nfile_type &lt;- tryCatch({\n  readxl::excel_sheets(file_path)\n  \"xlsx\"\n}, error = function(e) \"ods\")\n\nmessage(\"Detected file type: \", file_type)\n\n# ============================================================\n# FUNCTION TO READ ONE SHEET + ADD CELL COLUMN\n# ============================================================\n\nread_one_sheet &lt;- function(path, sheet, type) {\n  \n  df &lt;- tryCatch({\n    if (type == \"xlsx\") readxl::read_excel(path, sheet = sheet)\n    else readODS::read_ods(path, sheet = sheet)\n  }, error = function(e) data.frame())\n  \n  if (nrow(df) == 0) df &lt;- data.frame()\n  \n  df %&gt;%\n    tibble::as_tibble() %&gt;%\n    mutate(cell = sheet, .before = 1)\n}\n\n# ============================================================\n# READ ALL SHEETS\n# ============================================================\n\nsheets &lt;- if (file_type == \"xlsx\") {\n  readxl::excel_sheets(file_path)\n} else {\n  readODS::ods_sheets(file_path)\n}\n\nall_tables &lt;- lapply(sheets, function(s) read_one_sheet(file_path, s, file_type))\nnames(all_tables) &lt;- sheets\n\nmerged &lt;- bind_rows(all_tables)\n\n# ============================================================\n# FILTERABLE HTML TABLE (DT)\n# ============================================================\n\ndatatable(\n  merged,\n  filter = \"top\",          # &lt;-- FILTER ROWS\n  extensions = c(\"Buttons\"),\n  options = list(\n    scrollX = TRUE,\n    pageLength = 25,\n    dom = \"Bfrtip\"\n  )\n)\n\n\n\n\n\n\n\n\n\nHealthy    FTLD \n     24      44"
  },
  {
    "objectID": "Methods/Hdwgcna.html",
    "href": "Methods/Hdwgcna.html",
    "title": "Gene modules",
    "section": "",
    "text": "While differential expression identifies gene-level changes associated with FTLD, it does not capture the higher-order organization of transcriptional programs or the coordinated dysregulation of functional gene networks. Neurodegenerative diseases—including FTLD-C9 and FTLD-TDP—are characterized by complex regulatory alterations affecting synaptic systems, glial and immune reactivity, metabolic rewiring, and RNA-processing machinery. These processes are best understood at the module (network) level rather than through isolated transcripts.\nTo resolve network-level biology at cell-state resolution, we applied hdWGCNA (Morabito et al. 2023), a scalable adaptation of weighted gene co-expression network analysis (WGCNA) optimized for single-cell and pseudobulk data. By applying hdWGCNA to BayesPrism-derived expression matrices, we reconstructed cell-state–specific co-expression networks, enabling detection of modules associated with disease status, neuropathological markers, and lineage-specific vulnerability.\n\n\n\n\n\nFor each cohort (Sant Pau FTLD-C9, Sant Pau FTLD-TDP, Menden et al., Pottier et al.), hdWGCNA was performed independently for every cell state inferred by BayesPrism.\nThe input matrices consisted of:\n\nlog2-transformed counts per million (logCPM),\ngene expression estimates for each sample within each cell state,\nonly genes expressed in at least 5% of samples in that state (to reduce network noise and ensure connectivity).\n\nEach cell state was stored as a pseudobulk Seurat object, enabling hdWGCNA’s native functions for network construction and visualization.\n\n\n\nFollowing standard WGCNA principles, hdWGCNA constructs networks that approximate scale-free topology. For each cell state:\n\nSoft-thresholding power (β) was selected using the scale-free topology criterion (pickSoftThreshold), ensuring:\n\n-   high scale-free fit index,\n\n-   sufficient mean connectivity,\n\n-   biologically interpretable network structure.\n\nAn unsigned network was used for all analyses, allowing detection of both positively and negatively co-expressed gene relationships.\n\n\n\n\nA module eigengene (ME)—the first principal component summarizing module expression—was computed for each module.\nFor each cell state and each module:\n\nMEs were compared between FTLD-C9 or FTLD-TDP and controls to identify disease-associated modules using linear models.\n\nMEs were correlated (Spearman) with:\n\n-   **neuropathological markers** (ACSL3, lncRNAs, RNA foci sense/antisense, polyGA, polyGP, polyGR, pTDP-43, STMN2)\n\n-   **diagnostic group**\n\n-   **cell-state proportions**.\nThis yielded marker-associated modules, capturing functional programs linked to pathological burden.\nModules were ranked by:\n\ncorrelation magnitude,\np-value,\nbiological coherence,\nnumber of hub genes.\n\n\n\n\nHub genes for each module were identified using:\n\nkME (module membership),\ncorrelation of each gene with the corresponding eigengene.\n\nGenes with kME ≥ 0.90 were classified as high-confidence hub genes.\nThese anchors define the regulatory core of each transcriptional module.\n\n\n\nFor each significantly disease-associated module:\n\nGene Ontology enrichment was performed using Metascape, restricted to:\n\n-   Biological Process\n\n-   Molecular Function\n\n-    Cellular Component\nBackground sets were defined as:\n\nAll genes expressed in that cell state (from Pineda et al. reference).\n\nThis ensured biologically appropriate enrichment interpretations.\nEnrichment pinpointed:\n\nsynaptic processes,\nimmune and inflammatory pathways,\nRNA metabolism,\napoptotic signaling,\nvascular remodeling,\nglial activation states.\n\n\n\n\nFor module validation:\n\nGene lists from modules identified in Sant Pau cohorts were compared with those obtained from Menden et al. (for FTLD-C9) or Pottier et al. (for FTLD-TDP).\nOverlap statistics were computed using:\n\nGeneOverlap tests,\nJaccard indices,\ndirectionality of eigengene changes.\n\n\nA module was considered validated if:\n\nit showed significant gene overlap (p &lt; 0.05), and\nthe eigengene change direction matched between cohorts.\n\n\n\n\n\nThe hdWGCNA pipeline was designed to:\n\nIdentify cell-state–specific transcriptional modules that distinguish FTLD-C9, FTLD-TDP, and healthy cortex.\nReveal convergent and divergent network-level changes between genetic and sporadic FTLD subtypes.\nMap disease-associated pathways (synaptic signaling, immune activation, metabolic programs) to their cellular origins.\nIntegrate pathology burden (e.g., pTDP-43, STMN2 loss, DPR accumulation, RNA foci density) with module activities.\nDetect hub genes representing potential mechanistic drivers or biomarkers.\nValidate transcriptional networks across independent external datasets.\nProvide a systems-level framework for interpreting FTLD pathophysiology beyond individual DEGs.\n\n\n\nCode\n# single-cell analysis package\nlibrary(Seurat)\n\n# plotting and data science packages\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(patchwork)\n\n# co-expression network analysis packages:\nlibrary(WGCNA)\nlibrary(hdWGCNA)\n\n# paralel processing\nlibrary(fs)\nlibrary(future.apply)\n\n# Configurar sessio\nplan(multisession, workers = parallel::detectCores() - 1)\ntheme_set(theme_cowplot())\nset.seed(12345)\nenableWGCNAThreads(nThreads = 8)\n\n# Directori d'entrada i sortida\ninput_dir &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/25_09/FC/Rimod_C9/CELL STATE/\"\noutput_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS/\"\n\nif (!dir_exists(output_dir)) dir_create(output_dir)\ncsv_files &lt;- dir_ls(input_dir, glob = \"*.csv\")\n\nWGCNA_pseudobulk &lt;- function(file) {\n  tryCatch({\n    \n    # Obtenir el nom base de l'arxiu sense extensió\n    sample_name &lt;- path_ext_remove(path_file(file))\n    sample_output_dir &lt;- file.path(output_dir, sample_name)\n    \n    if (!dir_exists(sample_output_dir)) dir_create(sample_output_dir)\n    \n    message(\"Processing sample: \", sample_name)\n    \n    # Carregar dades en format CSV\n    sc_data &lt;- read.csv(file, row.names = 1)\n    \n    # Convertir a objecte Seurat\n    seurat_obj &lt;- CreateSeuratObject(counts = t(sc_data))\n    seurat_obj &lt;- SeuratObject::UpdateSeuratObject(seurat_obj)\n    \n    seurat_obj@meta.data$Sample &lt;- rownames(sc_data)\n    seurat_obj@meta.data$cell_type &lt;- sample_name\n    \n    seurat_obj &lt;- SetupForWGCNA(\n      seurat_obj,\n      gene_select = \"fraction\",\n      fraction = 0.05,\n      wgcna_name = \"pseudobulk\"\n    )\n    \n    message(\"Selected genes: \", length(GetWGCNAGenes(seurat_obj)))\n    \n    # log2CPM normalization\n    cpm &lt;- t(apply(sc_data, 1, function(x) {\n      y &lt;- x / sum(x) * 1e6\n      log2(y + 1)\n    }))\n    \n    seurat_obj &lt;- SetDatExpr(seurat_obj, mat = cpm)\n    seurat_obj@assays$RNA$data &lt;- t(cpm)\n    \n    # Soft thresholding\n    seurat_obj &lt;- TestSoftPowers(seurat_obj)\n    \n    # Save power plot\n    png(file.path(sample_output_dir, \"soft_power.png\"), width = 1000, height = 800)\n    PlotSoftPowers(seurat_obj)\n    dev.off()\n    \n    # Construct network\n    seurat_obj &lt;- ConstructNetwork(\n      seurat_obj,\n      tom_name = \"pseudobulk\",\n      overwrite_tom = TRUE,\n      mergeCutHeight = 0.25\n    )\n    \n    # Dendrogram\n    png(file.path(sample_output_dir, \"dendrogram.png\"), width = 1000, height = 800)\n    PlotDendrogram(seurat_obj, main = \"pseudobulk dendrogram\")\n    dev.off()\n    \n    # Eigengenes and connectivity\n    seurat_obj &lt;- ModuleEigengenes(seurat_obj, npcs = 2)\n    seurat_obj &lt;- ModuleConnectivity(seurat_obj)\n    \n    # DotPlot of MEs\n    MEs &lt;- GetMEs(seurat_obj)\n    mods &lt;- setdiff(colnames(MEs), \"grey\")\n    meta &lt;- seurat_obj@meta.data\n    seurat_obj@meta.data &lt;- cbind(meta, MEs)\n    \n    p_dot &lt;- DotPlot(seurat_obj, features = mods, group.by = \"cell_type\") +\n      RotatedAxis() +\n      scale_color_gradient(high = \"red\", low = \"grey95\") +\n      xlab(\"\") + ylab(\"\")\n    \n    png(file.path(sample_output_dir, \"dotplot_MEs.png\"), width = 1000, height = 800)\n    print(p_dot)\n    dev.off()\n    \n    # Reset metadata\n    seurat_obj@meta.data &lt;- meta\n    \n    # UMAP\n    seurat_obj &lt;- RunModuleUMAP(\n      seurat_obj,\n      n_hubs = 5,\n      n_neighbors = 10,\n      min_dist = 0.4,\n      spread = 3,\n      supervised = TRUE,\n      target_weight = 0.3\n    )\n    \n    umap_df &lt;- GetModuleUMAP(seurat_obj)\n    centroid_df &lt;- umap_df %&gt;%\n      dplyr::group_by(module) %&gt;%\n      dplyr::summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))\n    \n    p_umap &lt;- ggplot(umap_df, aes(x = UMAP1, y = UMAP2)) +\n      geom_point(color = umap_df$color, size = umap_df$kME * 2) +\n      geom_label(data = centroid_df, label = as.character(centroid_df$module),\n                 fontface = \"bold\", size = 2) +\n      umap_theme() +\n      theme(panel.background = element_rect(fill = \"black\"))\n    \n    png(file.path(sample_output_dir, \"umap_modules.png\"), width = 1000, height = 800)\n    print(p_umap)\n    dev.off()\n    \n    # Save the final Seurat object\n    saveRDS(seurat_obj, file = file.path(sample_output_dir, paste0(sample_name, \"_seurat.rds\")))\n    \n    message(\"Finished processing: \", sample_name)\n    \n  }, error = function(e) {\n    message(\"⚠️ Error in sample: \", file)\n    message(\"Details: \", e$message)\n  })\n}\n\n\n\n\n#future_lapply(csv_files, WGCNA_pseudobulk, future.seed = TRUE)\nfor (file in csv_files){\n  WGCNA_pseudobulk(file)\n}\n\n\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load and prepare metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize and merge metadata\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    \n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Correlation of MEs with group.ID\n    cor_results &lt;- apply(MEs, 2, function(module) {\n      cor.test(module, as.numeric(as.factor(A@meta.data$group.ID)), \n               method = \"spearman\", exact = TRUE)\n    })\n    \n    cor_df &lt;- data.frame(\n      module = names(cor_results),\n      cor = sapply(cor_results, function(x) x$estimate),\n      p.value = sapply(cor_results, function(x) x$p.value)\n    )\n    \n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory if not exists\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    \n    sig_modules &lt;- cor_df_sorted$module[cor_df_sorted$p.value &lt; 0.05]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    print(paste0(\"Finished: \", CS))\n    \n  }) # end try\n}\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize sample names\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Ensure sample order matches between MEs and metadata\n    sample_order &lt;- rownames(MEs)\n    # Ensure consistent factor order: Healthy (control), TDP (case)\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, A@meta.data$Sample), \"group.ID\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and calculate fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir,mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(hdWGCNA)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\", \n                           row.names = 1, sep = \"\\t\")\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- gsub(\"-\", \"\\\\.\",rownames(metadata_df))\n    rownames(metadata_df) &lt;- metadata_df$Sample_clean \n    # Filter out FTLD-TDP-C and recode group labels\n    metadata_df &lt;- metadata_df[metadata_df$GROUP != \"FTLD-TDP-C\", ]\n    metadata_df$GROUP &lt;- ifelse(metadata_df$GROUP == \"Control\", \"Healthy\", \"TDP\")\n    \n    samples_to_keep &lt;- intersect(rownames(A@meta.data), metadata_df$Sample_clean)\n    A &lt;- subset(A,cells= samples_to_keep)\n                \n    # Harmonize and merge metadata\n    A@meta.data &lt;- metadata_df\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    samples_in_A &lt;- rownames(A@meta.data)\n    MEs &lt;- MEs[rownames(MEs) %in% samples_in_A, ]\n    sample_order &lt;- rownames(MEs)\n    \n    # Ensure correct group assignment order\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, rownames(A@meta.data)), \"GROUP\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and compute fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    # Compile and sort results\n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\n\n\nCode\n############################## Correlation MEs VS Covariables ###############################\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"long\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n\n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"7BLACK\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"TDP43b\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS_asin_moduletraitcorrelation_tdp43b_tdp/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n#      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n#      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}\n\n\n\n############################## Correlation MEs VS Covariables ###############################\n\n# C9 \n\n# Must change the covariable name for each case.\n\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"X\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n      \n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      # A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      # if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"pTDP43\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/C9/CS_Moduletraitcorrelations_Asin_pTDP43/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n      #      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n      #      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}"
  },
  {
    "objectID": "Methods/Hdwgcna.html#rationale",
    "href": "Methods/Hdwgcna.html#rationale",
    "title": "Gene modules",
    "section": "",
    "text": "While differential expression identifies gene-level changes associated with FTLD, it does not capture the higher-order organization of transcriptional programs or the coordinated dysregulation of functional gene networks. Neurodegenerative diseases—including FTLD-C9 and FTLD-TDP—are characterized by complex regulatory alterations affecting synaptic systems, glial and immune reactivity, metabolic rewiring, and RNA-processing machinery. These processes are best understood at the module (network) level rather than through isolated transcripts.\nTo resolve network-level biology at cell-state resolution, we applied hdWGCNA (Morabito et al. 2023), a scalable adaptation of weighted gene co-expression network analysis (WGCNA) optimized for single-cell and pseudobulk data. By applying hdWGCNA to BayesPrism-derived expression matrices, we reconstructed cell-state–specific co-expression networks, enabling detection of modules associated with disease status, neuropathological markers, and lineage-specific vulnerability."
  },
  {
    "objectID": "Methods/Hdwgcna.html#analytical-strategy",
    "href": "Methods/Hdwgcna.html#analytical-strategy",
    "title": "Gene modules",
    "section": "",
    "text": "For each cohort (Sant Pau FTLD-C9, Sant Pau FTLD-TDP, Menden et al., Pottier et al.), hdWGCNA was performed independently for every cell state inferred by BayesPrism.\nThe input matrices consisted of:\n\nlog2-transformed counts per million (logCPM),\ngene expression estimates for each sample within each cell state,\nonly genes expressed in at least 5% of samples in that state (to reduce network noise and ensure connectivity).\n\nEach cell state was stored as a pseudobulk Seurat object, enabling hdWGCNA’s native functions for network construction and visualization.\n\n\n\nFollowing standard WGCNA principles, hdWGCNA constructs networks that approximate scale-free topology. For each cell state:\n\nSoft-thresholding power (β) was selected using the scale-free topology criterion (pickSoftThreshold), ensuring:\n\n-   high scale-free fit index,\n\n-   sufficient mean connectivity,\n\n-   biologically interpretable network structure.\n\nAn unsigned network was used for all analyses, allowing detection of both positively and negatively co-expressed gene relationships.\n\n\n\n\nA module eigengene (ME)—the first principal component summarizing module expression—was computed for each module.\nFor each cell state and each module:\n\nMEs were compared between FTLD-C9 or FTLD-TDP and controls to identify disease-associated modules using linear models.\n\nMEs were correlated (Spearman) with:\n\n-   **neuropathological markers** (ACSL3, lncRNAs, RNA foci sense/antisense, polyGA, polyGP, polyGR, pTDP-43, STMN2)\n\n-   **diagnostic group**\n\n-   **cell-state proportions**.\nThis yielded marker-associated modules, capturing functional programs linked to pathological burden.\nModules were ranked by:\n\ncorrelation magnitude,\np-value,\nbiological coherence,\nnumber of hub genes.\n\n\n\n\nHub genes for each module were identified using:\n\nkME (module membership),\ncorrelation of each gene with the corresponding eigengene.\n\nGenes with kME ≥ 0.90 were classified as high-confidence hub genes.\nThese anchors define the regulatory core of each transcriptional module.\n\n\n\nFor each significantly disease-associated module:\n\nGene Ontology enrichment was performed using Metascape, restricted to:\n\n-   Biological Process\n\n-   Molecular Function\n\n-    Cellular Component\nBackground sets were defined as:\n\nAll genes expressed in that cell state (from Pineda et al. reference).\n\nThis ensured biologically appropriate enrichment interpretations.\nEnrichment pinpointed:\n\nsynaptic processes,\nimmune and inflammatory pathways,\nRNA metabolism,\napoptotic signaling,\nvascular remodeling,\nglial activation states.\n\n\n\n\nFor module validation:\n\nGene lists from modules identified in Sant Pau cohorts were compared with those obtained from Menden et al. (for FTLD-C9) or Pottier et al. (for FTLD-TDP).\nOverlap statistics were computed using:\n\nGeneOverlap tests,\nJaccard indices,\ndirectionality of eigengene changes.\n\n\nA module was considered validated if:\n\nit showed significant gene overlap (p &lt; 0.05), and\nthe eigengene change direction matched between cohorts."
  },
  {
    "objectID": "Methods/Hdwgcna.html#analytical-goals-of-the-hdwgcna-component",
    "href": "Methods/Hdwgcna.html#analytical-goals-of-the-hdwgcna-component",
    "title": "Gene modules",
    "section": "",
    "text": "The hdWGCNA pipeline was designed to:\n\nIdentify cell-state–specific transcriptional modules that distinguish FTLD-C9, FTLD-TDP, and healthy cortex.\nReveal convergent and divergent network-level changes between genetic and sporadic FTLD subtypes.\nMap disease-associated pathways (synaptic signaling, immune activation, metabolic programs) to their cellular origins.\nIntegrate pathology burden (e.g., pTDP-43, STMN2 loss, DPR accumulation, RNA foci density) with module activities.\nDetect hub genes representing potential mechanistic drivers or biomarkers.\nValidate transcriptional networks across independent external datasets.\nProvide a systems-level framework for interpreting FTLD pathophysiology beyond individual DEGs.\n\n\n\nCode\n# single-cell analysis package\nlibrary(Seurat)\n\n# plotting and data science packages\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(patchwork)\n\n# co-expression network analysis packages:\nlibrary(WGCNA)\nlibrary(hdWGCNA)\n\n# paralel processing\nlibrary(fs)\nlibrary(future.apply)\n\n# Configurar sessio\nplan(multisession, workers = parallel::detectCores() - 1)\ntheme_set(theme_cowplot())\nset.seed(12345)\nenableWGCNAThreads(nThreads = 8)\n\n# Directori d'entrada i sortida\ninput_dir &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/25_09/FC/Rimod_C9/CELL STATE/\"\noutput_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS/\"\n\nif (!dir_exists(output_dir)) dir_create(output_dir)\ncsv_files &lt;- dir_ls(input_dir, glob = \"*.csv\")\n\nWGCNA_pseudobulk &lt;- function(file) {\n  tryCatch({\n    \n    # Obtenir el nom base de l'arxiu sense extensió\n    sample_name &lt;- path_ext_remove(path_file(file))\n    sample_output_dir &lt;- file.path(output_dir, sample_name)\n    \n    if (!dir_exists(sample_output_dir)) dir_create(sample_output_dir)\n    \n    message(\"Processing sample: \", sample_name)\n    \n    # Carregar dades en format CSV\n    sc_data &lt;- read.csv(file, row.names = 1)\n    \n    # Convertir a objecte Seurat\n    seurat_obj &lt;- CreateSeuratObject(counts = t(sc_data))\n    seurat_obj &lt;- SeuratObject::UpdateSeuratObject(seurat_obj)\n    \n    seurat_obj@meta.data$Sample &lt;- rownames(sc_data)\n    seurat_obj@meta.data$cell_type &lt;- sample_name\n    \n    seurat_obj &lt;- SetupForWGCNA(\n      seurat_obj,\n      gene_select = \"fraction\",\n      fraction = 0.05,\n      wgcna_name = \"pseudobulk\"\n    )\n    \n    message(\"Selected genes: \", length(GetWGCNAGenes(seurat_obj)))\n    \n    # log2CPM normalization\n    cpm &lt;- t(apply(sc_data, 1, function(x) {\n      y &lt;- x / sum(x) * 1e6\n      log2(y + 1)\n    }))\n    \n    seurat_obj &lt;- SetDatExpr(seurat_obj, mat = cpm)\n    seurat_obj@assays$RNA$data &lt;- t(cpm)\n    \n    # Soft thresholding\n    seurat_obj &lt;- TestSoftPowers(seurat_obj)\n    \n    # Save power plot\n    png(file.path(sample_output_dir, \"soft_power.png\"), width = 1000, height = 800)\n    PlotSoftPowers(seurat_obj)\n    dev.off()\n    \n    # Construct network\n    seurat_obj &lt;- ConstructNetwork(\n      seurat_obj,\n      tom_name = \"pseudobulk\",\n      overwrite_tom = TRUE,\n      mergeCutHeight = 0.25\n    )\n    \n    # Dendrogram\n    png(file.path(sample_output_dir, \"dendrogram.png\"), width = 1000, height = 800)\n    PlotDendrogram(seurat_obj, main = \"pseudobulk dendrogram\")\n    dev.off()\n    \n    # Eigengenes and connectivity\n    seurat_obj &lt;- ModuleEigengenes(seurat_obj, npcs = 2)\n    seurat_obj &lt;- ModuleConnectivity(seurat_obj)\n    \n    # DotPlot of MEs\n    MEs &lt;- GetMEs(seurat_obj)\n    mods &lt;- setdiff(colnames(MEs), \"grey\")\n    meta &lt;- seurat_obj@meta.data\n    seurat_obj@meta.data &lt;- cbind(meta, MEs)\n    \n    p_dot &lt;- DotPlot(seurat_obj, features = mods, group.by = \"cell_type\") +\n      RotatedAxis() +\n      scale_color_gradient(high = \"red\", low = \"grey95\") +\n      xlab(\"\") + ylab(\"\")\n    \n    png(file.path(sample_output_dir, \"dotplot_MEs.png\"), width = 1000, height = 800)\n    print(p_dot)\n    dev.off()\n    \n    # Reset metadata\n    seurat_obj@meta.data &lt;- meta\n    \n    # UMAP\n    seurat_obj &lt;- RunModuleUMAP(\n      seurat_obj,\n      n_hubs = 5,\n      n_neighbors = 10,\n      min_dist = 0.4,\n      spread = 3,\n      supervised = TRUE,\n      target_weight = 0.3\n    )\n    \n    umap_df &lt;- GetModuleUMAP(seurat_obj)\n    centroid_df &lt;- umap_df %&gt;%\n      dplyr::group_by(module) %&gt;%\n      dplyr::summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))\n    \n    p_umap &lt;- ggplot(umap_df, aes(x = UMAP1, y = UMAP2)) +\n      geom_point(color = umap_df$color, size = umap_df$kME * 2) +\n      geom_label(data = centroid_df, label = as.character(centroid_df$module),\n                 fontface = \"bold\", size = 2) +\n      umap_theme() +\n      theme(panel.background = element_rect(fill = \"black\"))\n    \n    png(file.path(sample_output_dir, \"umap_modules.png\"), width = 1000, height = 800)\n    print(p_umap)\n    dev.off()\n    \n    # Save the final Seurat object\n    saveRDS(seurat_obj, file = file.path(sample_output_dir, paste0(sample_name, \"_seurat.rds\")))\n    \n    message(\"Finished processing: \", sample_name)\n    \n  }, error = function(e) {\n    message(\"⚠️ Error in sample: \", file)\n    message(\"Details: \", e$message)\n  })\n}\n\n\n\n\n#future_lapply(csv_files, WGCNA_pseudobulk, future.seed = TRUE)\nfor (file in csv_files){\n  WGCNA_pseudobulk(file)\n}\n\n\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load and prepare metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize and merge metadata\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    \n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Correlation of MEs with group.ID\n    cor_results &lt;- apply(MEs, 2, function(module) {\n      cor.test(module, as.numeric(as.factor(A@meta.data$group.ID)), \n               method = \"spearman\", exact = TRUE)\n    })\n    \n    cor_df &lt;- data.frame(\n      module = names(cor_results),\n      cor = sapply(cor_results, function(x) x$estimate),\n      p.value = sapply(cor_results, function(x) x$p.value)\n    )\n    \n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory if not exists\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    \n    sig_modules &lt;- cor_df_sorted$module[cor_df_sorted$p.value &lt; 0.05]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    print(paste0(\"Finished: \", CS))\n    \n  }) # end try\n}\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize sample names\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Ensure sample order matches between MEs and metadata\n    sample_order &lt;- rownames(MEs)\n    # Ensure consistent factor order: Healthy (control), TDP (case)\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, A@meta.data$Sample), \"group.ID\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and calculate fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir,mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(hdWGCNA)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\", \n                           row.names = 1, sep = \"\\t\")\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- gsub(\"-\", \"\\\\.\",rownames(metadata_df))\n    rownames(metadata_df) &lt;- metadata_df$Sample_clean \n    # Filter out FTLD-TDP-C and recode group labels\n    metadata_df &lt;- metadata_df[metadata_df$GROUP != \"FTLD-TDP-C\", ]\n    metadata_df$GROUP &lt;- ifelse(metadata_df$GROUP == \"Control\", \"Healthy\", \"TDP\")\n    \n    samples_to_keep &lt;- intersect(rownames(A@meta.data), metadata_df$Sample_clean)\n    A &lt;- subset(A,cells= samples_to_keep)\n                \n    # Harmonize and merge metadata\n    A@meta.data &lt;- metadata_df\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    samples_in_A &lt;- rownames(A@meta.data)\n    MEs &lt;- MEs[rownames(MEs) %in% samples_in_A, ]\n    sample_order &lt;- rownames(MEs)\n    \n    # Ensure correct group assignment order\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, rownames(A@meta.data)), \"GROUP\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and compute fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    # Compile and sort results\n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\n\n\nCode\n############################## Correlation MEs VS Covariables ###############################\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"long\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n\n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"7BLACK\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"TDP43b\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS_asin_moduletraitcorrelation_tdp43b_tdp/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n#      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n#      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}\n\n\n\n############################## Correlation MEs VS Covariables ###############################\n\n# C9 \n\n# Must change the covariable name for each case.\n\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"X\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n      \n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      # A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      # if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"pTDP43\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/C9/CS_Moduletraitcorrelations_Asin_pTDP43/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n      #      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n      #      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}"
  },
  {
    "objectID": "Results/Hdwgcna.html",
    "href": "Results/Hdwgcna.html",
    "title": "Hdwgcna",
    "section": "",
    "text": "Select cell state folder: \n\nSelect module: \n\nGenes in selected module:"
  },
  {
    "objectID": "Results/Hdwgcna.html#sant-pau",
    "href": "Results/Hdwgcna.html#sant-pau",
    "title": "Hdwgcna",
    "section": "",
    "text": "Select cell state folder: \n\nSelect module: \n\nGenes in selected module:"
  },
  {
    "objectID": "Results/Hdwgcna.html#sant-pau-1",
    "href": "Results/Hdwgcna.html#sant-pau-1",
    "title": "Hdwgcna",
    "section": "Sant pau",
    "text": "Sant pau"
  },
  {
    "objectID": "Results/Hdwgcna.html#pottier",
    "href": "Results/Hdwgcna.html#pottier",
    "title": "Hdwgcna",
    "section": "Pottier",
    "text": "Pottier"
  },
  {
    "objectID": "Results/Hdwgcna_TDP_correlation.html",
    "href": "Results/Hdwgcna_TDP_correlation.html",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "",
    "text": "Across the FTLD-TDP dataset, multiple co-expression modules showed significant correlations with STMN2 pathology, revealing convergent alterations in pathways essential for axonal integrity, synaptic architecture, intracellular trafficking, RNA metabolism, and glial–immune activation. While several enriched terms reflected broad cellular processes, many modules captured highly relevant neurobiological dysfunctions that align with the molecular consequences of TDP-43 pathology and STMN2 loss.\nExcitatory Neuron–Associated Modules\nIn the deep-layer excitatory TLE4/CCBE1 population, STMN2-negative correlations highlighted profound impairments in neuronal structural homeostasis. The negatively correlated royalblue module showed enrichment in axon and neuron projection development, microtubule cytoskeleton organization, organelle transport along microtubules, Ras/MAPK signaling, and synaptic structures including both pre- and postsynaptic compartments. These findings indicate that reduced STMN2 expression is tightly linked to defects in axonal transport, microtubule stability, and synaptic connectivity—canonical downstream effects of TDP-43 dysfunction.\nA second negatively correlated module (orange) captured complementary features of neuronal vulnerability, including dysregulation of membrane potential, vesicle-mediated transport, and neuronal cell-body homeostasis. Together, these modules suggest that STMN2 loss in TLE4 neurons coincides with convergent collapse of axonal physiology and intracellular trafficking.\nIn contrast, the positively correlated brown module was enriched for immune receptor signaling, leukocyte activation, and inflammatory effector regulation. Although immunological in nature, such enrichments likely represent neuron-derived stress signals associated with progressive dysfunction, reflecting maladaptive neuron–glia communication in TDP-43-affected cortical circuits.\nIn RORB_LRRK1 neurons—a population known for vulnerability in FTLD-TDP—the positively correlated blue module revealed enrichment for extrinsic apoptotic signaling, lipid storage regulation, pattern-recognition receptor activity, scavenger receptor signaling, and cytokine-mediated responses. The presence of apoptotic and innate-immune pathways suggests early engagement of programmed cell-death signaling and neuron–immune cross-talk as neuronal STMN2 levels fluctuate. Meanwhile, modules negatively correlated with STMN2 lacked strong enrichment but may reflect transcriptomic attrition in more severely affected neurons.\nSimilarly, in RORB_ADGRL4 neurons, a positively correlated blue module highlighted high-voltage calcium channel activity, regulation of excitatory synapses, mRNA splicing pathways, chromatin modification, and cAMP/PKA signal transduction—functions central to synaptic plasticity and RNA metabolism. Their positive correlation with STMN2 indicates that these regulatory mechanisms are better preserved in neurons with less severe TDP-43 pathology.\nGlial and Oligodendroglial Cell States\nIn oligodendrocytes, the positively correlated blue module showed strong enrichment for RNA modification, co-transcriptional RNA processing, spliceosomal function, and methyltransferase activity—hallmarks of pathways disrupted by TDP-43 nuclear depletion. These results suggest that oligodendrocytes with preserved STMN2 expression retain more intact RNA-processing machinery, whereas STMN2 loss aligns with collapse of RNA metabolic pathways crucial for myelinating glia.\nOPCs displayed a positively correlated module enriched for microtubule motor activity, cation-channel regulation, and amide metabolic processes, pointing to preserved axonal support and intracellular transport capacity in STMN2-maintaining progenitor populations.\nThese findings reinforce that RNA processing deficits and cytoskeletal disturbances are not limited to neurons; rather, they represent a broader consequence of TDP-43 dysfunction across multiple glial lineages.\nInhibitory Neuron States\nIn the LAMP5/PMEPA1 inhibitory lineage, several modules negatively correlated with STMN2, enriched for GPCR signaling, calcium-independent cell adhesion, neuromodulatory receptor pathways, and inflammation-associated signaling such as IL-1β regulation and complement activation. These signatures point to a shift from interneuron-specific signaling toward injury-related and neuroimmune phenotypes in STMN2-low individuals.\nConversely, the positively correlated blue module captured functions related to blood vessel morphogenesis, mononuclear cell migration, DNA helicase activity, and immune–synaptic interactions, suggesting compensatory remodeling in interneurons during early or partial preservation of STMN2.\nTogether, these modules suggest that inhibitory interneurons undergo both synaptic dysregulation and immune-associated remodeling in the context of TDP-43 aggregation and STMN2 loss.\nAstroglial and Immune-Related Cell States\nGFAP+ astrocytes displayed a module positively correlated with STMN2 that was enriched for immune receptor activity, adaptive immune signaling, leukocyte activation, and inflammatory effector pathways. This pattern indicates that astroglial reactivity tracks closely with STMN2 status—either as a response to neuronal dysfunction or as an active participant in propagating neuroinflammation in FTLD-TDP.\nAlthough some enrichments reflect generic immune functions, several terms (e.g., immune effector regulation, cytokine-mediated communication, mononuclear cell migration) align with the increasingly appreciated role of astrocytes as drivers of local inflammatory microenvironments surrounding degenerating neurons in TDP-43 proteinopathy.\n\n\nCode\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Path to your file\npath &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/9. CORRELATION MODULES/Summary_Moduletraitcorrelations_TDP.ods\"\n\n# 1) List all sheets (each sheet = one cell type)\nsheets &lt;- ods_sheets(path)\n\n# 2) Read each sheet safely\nall_data &lt;- map_dfr(sheets, function(sheetname) {\n\n  # read each sheet\n  df &lt;- tryCatch(\n    read_ods(path, sheet = sheetname),\n    error = function(e) NULL\n  )\n\n  # skip empty or NULL sheets\n  if (is.null(df) || nrow(df) == 0)\n    return(NULL)\n\n  # add cell type column\n  df %&gt;%\n    mutate(cell_type = sheetname)\n})\n\nall_data &lt;- all_data[,c(7,5,1,6,2,3,4)]\n\nlibrary(DT)\n\ndatatable(\n  all_data,\n  options = list(pageLength = 10, scrollX = TRUE),\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\nA &lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CELL_PROP/FTLD/TDP/significatives_nonparametric_with_means_cs.tsv\")\n\n# Defineix el directori on tens els fitxers\ndirectori &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS/TDP43\"  \n\n# Llista de fitxers (assumint que són .tsv o .csv, adapta segons calgui)\nfitxers &lt;- list.files(path = directori, pattern = \"\\\\.txt$|\\\\.tsv$|\\\\.csv$\", full.names = TRUE)\n\n# Inicialitza una llista per guardar els resultats\nresultats &lt;- data.frame(\n  fitxer = character(),\n  pvalue_significatius = integer(),\n  total_files = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera sobre cada fitxer\nfor (fitxer in fitxers) {\n  # Llegeix el fitxer (ajusta el separador si cal)\n  taula &lt;- read.csv(fitxer, header = TRUE)\n  \n  # Compta les files amb p.value &lt; 0.05\n  significatius &lt;- sum(taula$p.value &lt; 0.05, na.rm = TRUE)\n  \n  # Compta el total de files\n  total &lt;- nrow(taula)\n  \n  # Afegeix a la taula de resultats\n  resultats &lt;- rbind(resultats, data.frame(\n    fitxer = basename(fitxer),\n    pvalue_significatius = significatius,\n    total_files = total,\n    stringsAsFactors = FALSE\n  ))\n}\n\n\n# Defineix el directori on hi ha les carpetes de cell states\ndirectori_base &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS\"  # Canvia això per la teva ruta\n\n# Llista de subcarpetes (cell states)\ncell_states &lt;- list.dirs(path = directori_base, recursive = FALSE, full.names = TRUE)\n\n# Inicialitza la taula de resultats\nresultats &lt;- data.frame(\n  cell_state = character(),\n  pvalue_significatius = integer(),\n  total_moduls = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera per cada carpeta de cell state\nfor (carpeta in cell_states) {\n  fitxer &lt;- file.path(carpeta, \"MODULES/cor_summary.csv\")\n  \n  if (file.exists(fitxer)) {\n    # Llegeix l’arxiu\n    taula &lt;- read.csv(fitxer, header = TRUE)\n    \n    # Compta mòduls significatius\n    significatius &lt;- sum(taula$p.value &lt; 0.05, na.rm = TRUE)\n    \n    # Compta mòduls totals\n    total &lt;- nrow(taula)\n    \n    # Nom del cell state (nom de la carpeta)\n    cell_state_nom &lt;- basename(carpeta)\n    \n    # Afegeix-ho a la taula de resultats\n    resultats &lt;- rbind(resultats, data.frame(\n      cell_state = cell_state_nom,\n      pvalue_significatius = significatius,\n      total_moduls = total,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n# Defineix el directori base amb les carpetes de tipus cel·lular\ndirectori_base &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS\"  # Substitueix amb la ruta correcta\n\n# Llista de subcarpetes (tipus cel·lular)\ncarpetes &lt;- list.dirs(path = directori_base, recursive = FALSE, full.names = TRUE)\n\n# Inicialitza la taula de resultats\nresultats &lt;- data.frame(\n  tipus_cellular = character(),\n  n_positius = integer(),\n  n_negatius = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera per cada carpeta\nfor (carpeta in carpetes) {\n  fitxer &lt;- file.path(carpeta, \"FTLD/results_adj_h.csv\")\n  \n  if (file.exists(fitxer)) {\n    # Llegeix el fitxer\n    taula &lt;- read.csv(fitxer, header = TRUE)\n    \n    # Compta valors 1 i -1 en la columna \"X1.FTLD..1.Control\"\n    positius &lt;- sum(taula$X1.FTLD..1.Control == 1, na.rm = TRUE)\n    negatius &lt;- sum(taula$X1.FTLD..1.Control == -1, na.rm = TRUE)\n    \n    # Nom del tipus cel·lular (nom de la carpeta)\n    nom_cell &lt;- basename(carpeta)\n    \n    # Afegeix a la taula de resultats\n    resultats &lt;- rbind(resultats, data.frame(\n      tipus_cellular = nom_cell,\n      n_positius = positius,\n      n_negatius = negatius,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"STMN2\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^(X|long)\", \"\", cov_df$X)\n\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"TDP43b\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^(X|long)\", \"\", cov_df$X)\n\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Hdwgcna_TDP_correlation.html#tdp",
    "href": "Results/Hdwgcna_TDP_correlation.html#tdp",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "",
    "text": "Across the FTLD-TDP dataset, multiple co-expression modules showed significant correlations with STMN2 pathology, revealing convergent alterations in pathways essential for axonal integrity, synaptic architecture, intracellular trafficking, RNA metabolism, and glial–immune activation. While several enriched terms reflected broad cellular processes, many modules captured highly relevant neurobiological dysfunctions that align with the molecular consequences of TDP-43 pathology and STMN2 loss.\nExcitatory Neuron–Associated Modules\nIn the deep-layer excitatory TLE4/CCBE1 population, STMN2-negative correlations highlighted profound impairments in neuronal structural homeostasis. The negatively correlated royalblue module showed enrichment in axon and neuron projection development, microtubule cytoskeleton organization, organelle transport along microtubules, Ras/MAPK signaling, and synaptic structures including both pre- and postsynaptic compartments. These findings indicate that reduced STMN2 expression is tightly linked to defects in axonal transport, microtubule stability, and synaptic connectivity—canonical downstream effects of TDP-43 dysfunction.\nA second negatively correlated module (orange) captured complementary features of neuronal vulnerability, including dysregulation of membrane potential, vesicle-mediated transport, and neuronal cell-body homeostasis. Together, these modules suggest that STMN2 loss in TLE4 neurons coincides with convergent collapse of axonal physiology and intracellular trafficking.\nIn contrast, the positively correlated brown module was enriched for immune receptor signaling, leukocyte activation, and inflammatory effector regulation. Although immunological in nature, such enrichments likely represent neuron-derived stress signals associated with progressive dysfunction, reflecting maladaptive neuron–glia communication in TDP-43-affected cortical circuits.\nIn RORB_LRRK1 neurons—a population known for vulnerability in FTLD-TDP—the positively correlated blue module revealed enrichment for extrinsic apoptotic signaling, lipid storage regulation, pattern-recognition receptor activity, scavenger receptor signaling, and cytokine-mediated responses. The presence of apoptotic and innate-immune pathways suggests early engagement of programmed cell-death signaling and neuron–immune cross-talk as neuronal STMN2 levels fluctuate. Meanwhile, modules negatively correlated with STMN2 lacked strong enrichment but may reflect transcriptomic attrition in more severely affected neurons.\nSimilarly, in RORB_ADGRL4 neurons, a positively correlated blue module highlighted high-voltage calcium channel activity, regulation of excitatory synapses, mRNA splicing pathways, chromatin modification, and cAMP/PKA signal transduction—functions central to synaptic plasticity and RNA metabolism. Their positive correlation with STMN2 indicates that these regulatory mechanisms are better preserved in neurons with less severe TDP-43 pathology.\nGlial and Oligodendroglial Cell States\nIn oligodendrocytes, the positively correlated blue module showed strong enrichment for RNA modification, co-transcriptional RNA processing, spliceosomal function, and methyltransferase activity—hallmarks of pathways disrupted by TDP-43 nuclear depletion. These results suggest that oligodendrocytes with preserved STMN2 expression retain more intact RNA-processing machinery, whereas STMN2 loss aligns with collapse of RNA metabolic pathways crucial for myelinating glia.\nOPCs displayed a positively correlated module enriched for microtubule motor activity, cation-channel regulation, and amide metabolic processes, pointing to preserved axonal support and intracellular transport capacity in STMN2-maintaining progenitor populations.\nThese findings reinforce that RNA processing deficits and cytoskeletal disturbances are not limited to neurons; rather, they represent a broader consequence of TDP-43 dysfunction across multiple glial lineages.\nInhibitory Neuron States\nIn the LAMP5/PMEPA1 inhibitory lineage, several modules negatively correlated with STMN2, enriched for GPCR signaling, calcium-independent cell adhesion, neuromodulatory receptor pathways, and inflammation-associated signaling such as IL-1β regulation and complement activation. These signatures point to a shift from interneuron-specific signaling toward injury-related and neuroimmune phenotypes in STMN2-low individuals.\nConversely, the positively correlated blue module captured functions related to blood vessel morphogenesis, mononuclear cell migration, DNA helicase activity, and immune–synaptic interactions, suggesting compensatory remodeling in interneurons during early or partial preservation of STMN2.\nTogether, these modules suggest that inhibitory interneurons undergo both synaptic dysregulation and immune-associated remodeling in the context of TDP-43 aggregation and STMN2 loss.\nAstroglial and Immune-Related Cell States\nGFAP+ astrocytes displayed a module positively correlated with STMN2 that was enriched for immune receptor activity, adaptive immune signaling, leukocyte activation, and inflammatory effector pathways. This pattern indicates that astroglial reactivity tracks closely with STMN2 status—either as a response to neuronal dysfunction or as an active participant in propagating neuroinflammation in FTLD-TDP.\nAlthough some enrichments reflect generic immune functions, several terms (e.g., immune effector regulation, cytokine-mediated communication, mononuclear cell migration) align with the increasingly appreciated role of astrocytes as drivers of local inflammatory microenvironments surrounding degenerating neurons in TDP-43 proteinopathy.\n\n\nCode\nlibrary(readODS)\nlibrary(dplyr)\nlibrary(purrr)\n\n# Path to your file\npath &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/9. CORRELATION MODULES/Summary_Moduletraitcorrelations_TDP.ods\"\n\n# 1) List all sheets (each sheet = one cell type)\nsheets &lt;- ods_sheets(path)\n\n# 2) Read each sheet safely\nall_data &lt;- map_dfr(sheets, function(sheetname) {\n\n  # read each sheet\n  df &lt;- tryCatch(\n    read_ods(path, sheet = sheetname),\n    error = function(e) NULL\n  )\n\n  # skip empty or NULL sheets\n  if (is.null(df) || nrow(df) == 0)\n    return(NULL)\n\n  # add cell type column\n  df %&gt;%\n    mutate(cell_type = sheetname)\n})\n\nall_data &lt;- all_data[,c(7,5,1,6,2,3,4)]\n\nlibrary(DT)\n\ndatatable(\n  all_data,\n  options = list(pageLength = 10, scrollX = TRUE),\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\nA &lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CELL_PROP/FTLD/TDP/significatives_nonparametric_with_means_cs.tsv\")\n\n# Defineix el directori on tens els fitxers\ndirectori &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS/TDP43\"  \n\n# Llista de fitxers (assumint que són .tsv o .csv, adapta segons calgui)\nfitxers &lt;- list.files(path = directori, pattern = \"\\\\.txt$|\\\\.tsv$|\\\\.csv$\", full.names = TRUE)\n\n# Inicialitza una llista per guardar els resultats\nresultats &lt;- data.frame(\n  fitxer = character(),\n  pvalue_significatius = integer(),\n  total_files = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera sobre cada fitxer\nfor (fitxer in fitxers) {\n  # Llegeix el fitxer (ajusta el separador si cal)\n  taula &lt;- read.csv(fitxer, header = TRUE)\n  \n  # Compta les files amb p.value &lt; 0.05\n  significatius &lt;- sum(taula$p.value &lt; 0.05, na.rm = TRUE)\n  \n  # Compta el total de files\n  total &lt;- nrow(taula)\n  \n  # Afegeix a la taula de resultats\n  resultats &lt;- rbind(resultats, data.frame(\n    fitxer = basename(fitxer),\n    pvalue_significatius = significatius,\n    total_files = total,\n    stringsAsFactors = FALSE\n  ))\n}\n\n\n# Defineix el directori on hi ha les carpetes de cell states\ndirectori_base &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS\"  # Canvia això per la teva ruta\n\n# Llista de subcarpetes (cell states)\ncell_states &lt;- list.dirs(path = directori_base, recursive = FALSE, full.names = TRUE)\n\n# Inicialitza la taula de resultats\nresultats &lt;- data.frame(\n  cell_state = character(),\n  pvalue_significatius = integer(),\n  total_moduls = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera per cada carpeta de cell state\nfor (carpeta in cell_states) {\n  fitxer &lt;- file.path(carpeta, \"MODULES/cor_summary.csv\")\n  \n  if (file.exists(fitxer)) {\n    # Llegeix l’arxiu\n    taula &lt;- read.csv(fitxer, header = TRUE)\n    \n    # Compta mòduls significatius\n    significatius &lt;- sum(taula$p.value &lt; 0.05, na.rm = TRUE)\n    \n    # Compta mòduls totals\n    total &lt;- nrow(taula)\n    \n    # Nom del cell state (nom de la carpeta)\n    cell_state_nom &lt;- basename(carpeta)\n    \n    # Afegeix-ho a la taula de resultats\n    resultats &lt;- rbind(resultats, data.frame(\n      cell_state = cell_state_nom,\n      pvalue_significatius = significatius,\n      total_moduls = total,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n# Defineix el directori base amb les carpetes de tipus cel·lular\ndirectori_base &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS\"  # Substitueix amb la ruta correcta\n\n# Llista de subcarpetes (tipus cel·lular)\ncarpetes &lt;- list.dirs(path = directori_base, recursive = FALSE, full.names = TRUE)\n\n# Inicialitza la taula de resultats\nresultats &lt;- data.frame(\n  tipus_cellular = character(),\n  n_positius = integer(),\n  n_negatius = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera per cada carpeta\nfor (carpeta in carpetes) {\n  fitxer &lt;- file.path(carpeta, \"FTLD/results_adj_h.csv\")\n  \n  if (file.exists(fitxer)) {\n    # Llegeix el fitxer\n    taula &lt;- read.csv(fitxer, header = TRUE)\n    \n    # Compta valors 1 i -1 en la columna \"X1.FTLD..1.Control\"\n    positius &lt;- sum(taula$X1.FTLD..1.Control == 1, na.rm = TRUE)\n    negatius &lt;- sum(taula$X1.FTLD..1.Control == -1, na.rm = TRUE)\n    \n    # Nom del tipus cel·lular (nom de la carpeta)\n    nom_cell &lt;- basename(carpeta)\n    \n    # Afegeix a la taula de resultats\n    resultats &lt;- rbind(resultats, data.frame(\n      tipus_cellular = nom_cell,\n      n_positius = positius,\n      n_negatius = negatius,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"STMN2\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^(X|long)\", \"\", cov_df$X)\n\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\n# ============================================================\n# INTERACTIVE SCATTERPLOTS – MODULE EIGENGENES vs COVARIABLE\n# ============================================================\n\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(plotly)\n\n# ---- Safe Spearman correlation ----\nsafe_cor &lt;- function(x, y){\n  tryCatch({\n    if(all(is.na(x)) | all(is.na(y))) return(list(estimate = NA, p.value = NA))\n    res &lt;- cor.test(x, y, method = \"spearman\")\n    list(estimate = as.numeric(res$estimate), p.value = res$p.value)\n  }, error = function(e) list(estimate = NA, p.value = NA))\n}\n\n# ============================================================\n# ---- LOAD DATA ------------------------------------------------\n# ============================================================\n\nExpression_per_cell_directory &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\"\n\n# Covariables table (must contain column X = sampleID and STMN2 or pTDP43)\nOG_Covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\nOG_Covariables$X &lt;- gsub(\"^X\", \"\", OG_Covariables$X)\n\n# Set covariable to use in the scatterplot:\ncovariable_to_use &lt;- \"TDP43b\"     # Change here if needed\n\n# Find all subfolders\nall_dirs &lt;- list.dirs(Expression_per_cell_directory, full.names = TRUE, recursive = FALSE)\n\n# Keep only those containing a matching *_seurat.rds file\ncells &lt;- basename(all_dirs[\n  sapply(all_dirs, function(dir) {\n    cell_name &lt;- basename(dir)\n    file.exists(file.path(dir, paste0(cell_name, \"_seurat.rds\")))\n  })\n])\n\n# ============================================================\n# ---- COMPUTE CORRELATIONS: MODULE vs COVARIABLE --------------\n# ============================================================\n\nresults &lt;- data.frame(Cell = character(),\n                      Module = character(),\n                      Covariable = character(),\n                      Spearman = numeric(),\n                      p_value = numeric(),\n                      stringsAsFactors = FALSE)\n\nfor (cell in cells) {\n  \n  file_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(file_path)) next\n  \n  seurat_obj &lt;- readRDS(file_path)\n  \n  # ---- Extract module eigengenes ----\n  if (!(\"pseudobulk\" %in% names(seurat_obj@misc))) next\n  if (!(\"MEs\" %in% names(seurat_obj@misc$pseudobulk))) next\n  \n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  modules &lt;- colnames(data)\n  \n  for (module in modules) {\n    \n    common_ids &lt;- intersect(rownames(data), OG_Covariables$X)\n    if (length(common_ids) &lt; 3) next\n    \n    module_values &lt;- data[common_ids, module]\n    cov_values &lt;- OG_Covariables[match(common_ids, OG_Covariables$X), covariable_to_use]\n    \n    result_corr &lt;- safe_cor(module_values, cov_values)\n    \n    results &lt;- rbind(results,\n                     data.frame(Cell = cell,\n                                Module = module,\n                                Covariable = covariable_to_use,\n                                Spearman = result_corr$estimate,\n                                p_value = result_corr$p.value))\n  }\n}\n\nresults &lt;- results %&gt;% drop_na(Spearman)\n\n# ============================================================\n# ---- BUILD SCATTER DATA (per trace) -------------------------\n# ============================================================\n\nall_traces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), Cell = character(), Module = character())\ntrace_index &lt;- 0\n\nfor (cell in unique(results$Cell)) {\n  \n  expr_path &lt;- file.path(Expression_per_cell_directory, cell, paste0(cell, \"_seurat.rds\"))\n  if (!file.exists(expr_path)) next\n  \n  seurat_obj &lt;- readRDS(expr_path)\n  data &lt;- seurat_obj@misc$pseudobulk$MEs\n  rownames(data) &lt;- gsub(\"^X\", \"\", rownames(data))\n  \n  cov_df &lt;- OG_Covariables[, c(\"X\", covariable_to_use)]\n  cov_df$X &lt;- gsub(\"^(X|long)\", \"\", cov_df$X)\n\n  \n  for (module in unique(results$Module)) {\n    if (!(module %in% colnames(data))) next\n    \n    common_ids &lt;- intersect(rownames(data), cov_df$X)\n    if (length(common_ids) &lt; 3) next\n    \n    df &lt;- tibble(\n      sample = common_ids,\n      x = cov_df[match(common_ids, cov_df$X), covariable_to_use],\n      y = data[common_ids, module]\n    ) %&gt;% drop_na()\n    \n    if (nrow(df) &lt; 3 || sd(df$x) == 0 || sd(df$y) == 0) next\n    \n    rho  &lt;- suppressWarnings(cor(df$x, df$y, method = \"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method = \"spearman\")$p.value)\n    \n    lmfit &lt;- lm(y ~ x, data = df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out = 100))\n    line_df$y &lt;- predict(lmfit, newdata = line_df)\n    \n    # Scatter\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"markers\",\n      x = df$x,\n      y = df$y,\n      name = paste(cell, module),\n      text = paste0(\"&lt;b&gt;\", module, \"&lt;/b&gt; in \", cell,\n                    \"&lt;br&gt;ρ = \", round(rho, 3),\n                    \"&lt;br&gt;p = \", signif(pval, 3)),\n      hoverinfo = \"text\",\n      marker = list(size = 7, opacity = 0.8),\n      visible = FALSE\n    )\n    \n    # Regression line\n    trace_index &lt;- trace_index + 1\n    all_traces[[trace_index]] &lt;- list(\n      type = \"scatter\",\n      mode = \"lines\",\n      x = line_df$x, y = line_df$y,\n      line = list(width = 2),\n      hoverinfo = \"none\",\n      visible = FALSE\n    )\n    \n    meta &lt;- add_row(meta, trace_id = trace_index - 1,\n                    Cell = cell, Module = module)\n  }\n}\n\n# ============================================================\n# ---- VISIBILITY HELPER -------------------------------------\n# ============================================================\n\nmake_vis &lt;- function(cell_sel, module_sel) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  combo &lt;- which(meta$Cell == cell_sel & meta$Module == module_sel)\n  if (length(combo) == 1) {\n    idx &lt;- (combo - 1) * 2 + 1\n    vis[idx:(idx + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ============================================================\n# ---- DROPDOWNS: CELL + MODULE ------------------------------\n# ============================================================\n\ncells_list   &lt;- unique(meta$Cell)\nmodules_list &lt;- unique(meta$Module)\n\nbuttons_cell &lt;- lapply(cells_list, function(c) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(c, modules_list[1])),\n                   list(title = paste(\"Cell:\", c))),\n       label = c)\n})\n\nbuttons_module &lt;- lapply(modules_list, function(m) {\n  list(method = \"update\",\n       args = list(list(visible = make_vis(cells_list[1], m)),\n                   list(title = paste(\"Module:\", m))),\n       label = m)\n})\n\n# ============================================================\n# ---- INITIAL VISIBILITY -------------------------------------\n# ============================================================\n\nvis_init &lt;- make_vis(cells_list[1], modules_list[1])\nfor (k in seq_along(all_traces)) all_traces[[k]]$visible &lt;- vis_init[k]\n\n# ============================================================\n# ---- BUILD FIGURE ------------------------------------------\n# ============================================================\n\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type      = tr$type,\n    mode      = tr$mode,\n    x         = tr$x,\n    y         = tr$y,\n    name      = tr$name,\n    text      = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker    = tr$marker,\n    line      = tr$line,\n    visible   = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = list(text = paste(\"Correlation:\", covariable_to_use, \"vs Module Eigengene\"), x = 0.05),\n    xaxis = list(title = covariable_to_use),\n    yaxis = list(title = \"Module Eigengene\"),\n    showlegend = FALSE,\n    updatemenus = list(\n      list(y = 1.15, x = 0.00, buttons = buttons_cell,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Cell State\")),\n      list(y = 1.15, x = 0.33, buttons = buttons_module,\n           direction = \"down\", showactive = TRUE,\n           xanchor = \"left\", yanchor = \"top\",\n           title = list(text = \"Module\"))\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Methods/Bayesprism.html",
    "href": "Methods/Bayesprism.html",
    "title": "Bayesprism",
    "section": "",
    "text": "Bulk RNA-sequencing provides a high-throughput snapshot of gene expression in brain tissue but masks the substantial cellular heterogeneity of the human cortex. FTLD pathology affects specific neuronal populations—particularly RORB-expressing excitatory neurons—as well as diverse non-neuronal cell classes including astrocytes, microglia, oligodendrocytes, vascular cells, and infiltrating immune cells. As a result, interpreting bulk transcriptomic changes requires methods capable of deconvolving mixed-cell signals into cell-type–specific expression profiles and cell-state proportions.\nBayesian deconvolution methods, such as BayesPrism (Chu et al. 2022) , offer major advantages over traditional regression or matrix factorization approaches by explicitly modeling biological variability and uncertainty. Using a high-resolution single-nucleus RNA-seq reference—such as the dataset from Pineda et al. (Synapse ID: syn51105515)—BayesPrism integrates single-cell information with bulk counts to infer, for each sample:\n\nCell-type and cell-state fractions, representing the estimated proportion of each transcriptional state in the tissue.\nCell-type–specific expression estimates, reconstructing a matrix of gene expression for each cell state within each patient.\n\nThis dual output allows downstream cell-state–resolved differential expression, co-expression network analysis (hdWGCNA), and correlations with neuropathological markers.\n\n\n\nThe Bayesian deconvolution approach consisted of the following steps:\n\n\nThe reference atlas from Pineda et al. contained 19 major cell classes and 44 transcriptionally distinct cell states derived from human frontal cortex single-nucleus RNA-seq containing 36503 genes. The reference was preprocessed to:\n\nexclude genes with low expression,\nremove mitochondrial, ribosomal, and sex-chromosome transcripts,\nretain only protein-coding genes expressed in ≥5 nuclei.\n\nAfter filtration there were 16564 genes keept for the reference dataset. This produced a biologically curated transcriptional reference ideal for Bayesian modeling of cortical cell populations.\n\n\n\nBulk RNA-seq counts from all four cohorts (two Sant Pau, Menden et al., Pottier et al.) were matched to the gene identifiers in the reference.\nCounts were log-transformed where appropriate, and samples were retained only if sequencing quality and pathological classification were robust.\n\n\n\nA BayesPrism object was created using the filtered single-cell matrix as the reference component and the raw bulk count matrix as the mixture component. The algorithm:\n\nidentifies outlier genes (cutoff = 0.01),\nperforms Gibbs sampling to estimate posterior distributions for each sample,\ninfers cell-type fractions (θ) and cell-type–specific expression matrices (φ) simultaneously.\n\nPosterior estimates were extracted after convergence diagnostics ensured stable sampling across chains.\n\n\n\nFor each sample, BayesPrism returned:\n\nPosterior-estimated cell-state proportions, enabling comparisons between FTLD-C9, FTLD-TDP, and controls.\nCell-state–specific expression matrices, which served as the basis for:\n\nedgeR-based cell-state differential expression.\nconstruction of pseudobulk Seurat objects,\nhdWGCNA module detection,\ncorrelation analysis with neuropathology (ACSL3, lncRNAs, RNA foci, DPRs, pTDP-43, STMN2).\n\n\n\n\n\nAll steps—from reference alignment, through BayesPrism modeling, to extraction of posterior values—were performed identically in:\n\nSant Pau FTLD-C9\nSant Pau FTLD-TDP\nMenden et al. FTLD-C9\nPottier et al. FTLD-TDP\n\nThis standardized pipeline enabled robust cross-cohort comparison of:\n\ncell-state proportions,\ncell-type–specific differential expression.\nco-expression networks,\npathological-marker correlations.\n\n\n\n\n\nBayesPrism was employed to achieve the following methodological goals:\n\nResolve bulk RNA-seq into cell-type and cell-state contributions to uncover FTLD-associated alterations hidden in tissue-level averages.\nEnable differential expression analysis at single-cell resolution, identifying the precise neuronal and glial subtypes driving FTLD-C9 and FTLD-TDP transcriptional changes.\nQuantify disease-related changes in cell-state composition, including excitatory/inhibitory neuron loss and reactive glial expansion.\nMap neuropathological burden (RNA foci, DPRs, pTDP-43, STMN2) to transcriptional changes within specific cell states.\nGenerate high-dimensional transcriptional networks (hdWGCNA) to identify disease-relevant modules that would otherwise be unresolvable in bulk data.\nValidate findings across independent datasets using a unified Bayesian framework to ensure reproducibility and generalizability.\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_original.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\")\n###############################################################################\n#Set colnames and rownames\nbk.dat&lt;-bk.dat[, -c(1,2,3,4,5,7)]\nbk.dat &lt;- aggregate(. ~ GeneName, data = bk.dat, FUN = sum) # Aggregate rows with same gene\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n# El matrix es el que dona problemes!!!!!!\n#sc.dat &lt;- t(as.matrix(merged@assays$Assay_name$counts))\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n\n# Update metadata to take into account DGE groups.\n\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50,)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\nbp.res.update &lt;- update.theta (bp = bp.res.initial)\nsave(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}"
  },
  {
    "objectID": "Methods/Bayesprism.html#rationale",
    "href": "Methods/Bayesprism.html#rationale",
    "title": "Bayesprism",
    "section": "",
    "text": "Bulk RNA-sequencing provides a high-throughput snapshot of gene expression in brain tissue but masks the substantial cellular heterogeneity of the human cortex. FTLD pathology affects specific neuronal populations—particularly RORB-expressing excitatory neurons—as well as diverse non-neuronal cell classes including astrocytes, microglia, oligodendrocytes, vascular cells, and infiltrating immune cells. As a result, interpreting bulk transcriptomic changes requires methods capable of deconvolving mixed-cell signals into cell-type–specific expression profiles and cell-state proportions.\nBayesian deconvolution methods, such as BayesPrism (Chu et al. 2022) , offer major advantages over traditional regression or matrix factorization approaches by explicitly modeling biological variability and uncertainty. Using a high-resolution single-nucleus RNA-seq reference—such as the dataset from Pineda et al. (Synapse ID: syn51105515)—BayesPrism integrates single-cell information with bulk counts to infer, for each sample:\n\nCell-type and cell-state fractions, representing the estimated proportion of each transcriptional state in the tissue.\nCell-type–specific expression estimates, reconstructing a matrix of gene expression for each cell state within each patient.\n\nThis dual output allows downstream cell-state–resolved differential expression, co-expression network analysis (hdWGCNA), and correlations with neuropathological markers."
  },
  {
    "objectID": "Methods/Bayesprism.html#analytical-strategy",
    "href": "Methods/Bayesprism.html#analytical-strategy",
    "title": "Bayesprism",
    "section": "",
    "text": "The Bayesian deconvolution approach consisted of the following steps:\n\n\nThe reference atlas from Pineda et al. contained 19 major cell classes and 44 transcriptionally distinct cell states derived from human frontal cortex single-nucleus RNA-seq containing 36503 genes. The reference was preprocessed to:\n\nexclude genes with low expression,\nremove mitochondrial, ribosomal, and sex-chromosome transcripts,\nretain only protein-coding genes expressed in ≥5 nuclei.\n\nAfter filtration there were 16564 genes keept for the reference dataset. This produced a biologically curated transcriptional reference ideal for Bayesian modeling of cortical cell populations.\n\n\n\nBulk RNA-seq counts from all four cohorts (two Sant Pau, Menden et al., Pottier et al.) were matched to the gene identifiers in the reference.\nCounts were log-transformed where appropriate, and samples were retained only if sequencing quality and pathological classification were robust.\n\n\n\nA BayesPrism object was created using the filtered single-cell matrix as the reference component and the raw bulk count matrix as the mixture component. The algorithm:\n\nidentifies outlier genes (cutoff = 0.01),\nperforms Gibbs sampling to estimate posterior distributions for each sample,\ninfers cell-type fractions (θ) and cell-type–specific expression matrices (φ) simultaneously.\n\nPosterior estimates were extracted after convergence diagnostics ensured stable sampling across chains.\n\n\n\nFor each sample, BayesPrism returned:\n\nPosterior-estimated cell-state proportions, enabling comparisons between FTLD-C9, FTLD-TDP, and controls.\nCell-state–specific expression matrices, which served as the basis for:\n\nedgeR-based cell-state differential expression.\nconstruction of pseudobulk Seurat objects,\nhdWGCNA module detection,\ncorrelation analysis with neuropathology (ACSL3, lncRNAs, RNA foci, DPRs, pTDP-43, STMN2).\n\n\n\n\n\nAll steps—from reference alignment, through BayesPrism modeling, to extraction of posterior values—were performed identically in:\n\nSant Pau FTLD-C9\nSant Pau FTLD-TDP\nMenden et al. FTLD-C9\nPottier et al. FTLD-TDP\n\nThis standardized pipeline enabled robust cross-cohort comparison of:\n\ncell-state proportions,\ncell-type–specific differential expression.\nco-expression networks,\npathological-marker correlations."
  },
  {
    "objectID": "Methods/Bayesprism.html#objectives-of-applying-bayesprism",
    "href": "Methods/Bayesprism.html#objectives-of-applying-bayesprism",
    "title": "Bayesprism",
    "section": "",
    "text": "BayesPrism was employed to achieve the following methodological goals:\n\nResolve bulk RNA-seq into cell-type and cell-state contributions to uncover FTLD-associated alterations hidden in tissue-level averages.\nEnable differential expression analysis at single-cell resolution, identifying the precise neuronal and glial subtypes driving FTLD-C9 and FTLD-TDP transcriptional changes.\nQuantify disease-related changes in cell-state composition, including excitatory/inhibitory neuron loss and reactive glial expansion.\nMap neuropathological burden (RNA foci, DPRs, pTDP-43, STMN2) to transcriptional changes within specific cell states.\nGenerate high-dimensional transcriptional networks (hdWGCNA) to identify disease-relevant modules that would otherwise be unresolvable in bulk data.\nValidate findings across independent datasets using a unified Bayesian framework to ensure reproducibility and generalizability.\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_original.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\")\n###############################################################################\n#Set colnames and rownames\nbk.dat&lt;-bk.dat[, -c(1,2,3,4,5,7)]\nbk.dat &lt;- aggregate(. ~ GeneName, data = bk.dat, FUN = sum) # Aggregate rows with same gene\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n# El matrix es el que dona problemes!!!!!!\n#sc.dat &lt;- t(as.matrix(merged@assays$Assay_name$counts))\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n\n# Update metadata to take into account DGE groups.\n\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50,)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\nbp.res.update &lt;- update.theta (bp = bp.res.initial)\nsave(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\n\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}"
  },
  {
    "objectID": "Validation/Bulk_validation.html",
    "href": "Validation/Bulk_validation.html",
    "title": "Validation: Bulk analysis",
    "section": "",
    "text": "Code\nlibrary(\"DT\")\ndata &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/10. VALIDATION/C9_Validation_results_bulk.csv\")\n\ndatatable(\ndata,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nscrollX = TRUE\n)\n)\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(\"DT\")\ndata &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/10. VALIDATION/TDP43_Validation_results_bulk.csv\")\n\ndatatable(\ndata,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "Validation/Bulk_validation.html#c9",
    "href": "Validation/Bulk_validation.html#c9",
    "title": "Validation: Bulk analysis",
    "section": "",
    "text": "Code\nlibrary(\"DT\")\ndata &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/10. VALIDATION/C9_Validation_results_bulk.csv\")\n\ndatatable(\ndata,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "Validation/Bulk_validation.html#tdp",
    "href": "Validation/Bulk_validation.html#tdp",
    "title": "Validation: Bulk analysis",
    "section": "",
    "text": "Code\nlibrary(\"DT\")\ndata &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/10. VALIDATION/TDP43_Validation_results_bulk.csv\")\n\ndatatable(\ndata,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the project analysis of FTLD"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FTLD RNAseq Analysis",
    "section": "",
    "text": "This page contains the complete analysis of FTLD transcriptomics performed for the paper _______________ .\n\n\nFrontotemporal lobar degeneration (FTLD) encompasses molecularly and clinically heterogeneous entities, most frequently associated with TDP-43 pathology and C9orf72 repeat expansions.\nAlthough shared pathological hallmarks suggest convergent mechanisms, the cell-type-specific transcriptional differences between FTLD-C9 and FTLD-TDP remain incompletely defined.\nWe performed a multi-level transcriptomic analysis of bulk RNA-seq from the Sant Pau FTLD cohort, integrating Bayesian single-cell deconvolution (BayesPrism), cell-state differential expression, and high-dimensional co-expression network analysis (hdWGCNA).\nResults were validated using two independent bulk RNA-seq datasets from the Rimod-FTLD and Pottier et al. cohorts. A merged human cortical single-cell reference served as the prior for deconvolution.\nStatistical analyses were performed using edgeR (LRT) for differential expression, non-parametric tests for cell composition, and Spearman correlations to link transcriptional and neuropathological markers. Bulk analyses identified 424 differentially expressed genes (DEGs) in FTLD-C9 and 14 in FTLD-TDP (FDR &lt; 0.05).\nFTLD-C9 showed broad immune, complement, and extracellular matrix activation, whereas FTLD-TDP displayed astroglial stress and proteostasis imbalance.\nBayesian deconvolution revealed increased GFAP⁺ astrocytes and T-cell fractions, with reductions in RORB- and PVALB-defined neurons, indicating coordinated glial expansion and neuronal loss.\nCell-state-specific differential expression confirmed upregulation of CHI3L1, CHI3L2, and SPP1, and repression of STMN2 and synaptic genes. hdWGCNA uncovered anti-correlated neuronal and glial modules conserved across subtypes and cohorts, linking neuronal downregulation with astrocytic and vascular activation.\nValidation analyses demonstrated reproducible DEGs and module preservation (module Z &gt; 6, directional concordance &gt; 60%).\nBoth FTLD-C9 and FTLD-TDP converge on a shared network architecture characterized by astroglial–neuronal anticorrelation, synaptic repression, and inflammatory activation, despite distinct genetic triggers.\nThese results highlight STMN2 loss and CHI3L1/CHI3L2 upregulation as central molecular signatures linking RNA dysregulation, glial reactivity, and network failure in FTLD.\nThe dataset integration and open analytical pipeline provide a reproducible framework for cell-type-resolved transcriptomic analysis in neurodegeneration."
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "FTLD RNAseq Analysis",
    "section": "",
    "text": "Frontotemporal lobar degeneration (FTLD) encompasses molecularly and clinically heterogeneous entities, most frequently associated with TDP-43 pathology and C9orf72 repeat expansions.\nAlthough shared pathological hallmarks suggest convergent mechanisms, the cell-type-specific transcriptional differences between FTLD-C9 and FTLD-TDP remain incompletely defined.\nWe performed a multi-level transcriptomic analysis of bulk RNA-seq from the Sant Pau FTLD cohort, integrating Bayesian single-cell deconvolution (BayesPrism), cell-state differential expression, and high-dimensional co-expression network analysis (hdWGCNA).\nResults were validated using two independent bulk RNA-seq datasets from the Rimod-FTLD and Pottier et al. cohorts. A merged human cortical single-cell reference served as the prior for deconvolution.\nStatistical analyses were performed using edgeR (LRT) for differential expression, non-parametric tests for cell composition, and Spearman correlations to link transcriptional and neuropathological markers. Bulk analyses identified 424 differentially expressed genes (DEGs) in FTLD-C9 and 14 in FTLD-TDP (FDR &lt; 0.05).\nFTLD-C9 showed broad immune, complement, and extracellular matrix activation, whereas FTLD-TDP displayed astroglial stress and proteostasis imbalance.\nBayesian deconvolution revealed increased GFAP⁺ astrocytes and T-cell fractions, with reductions in RORB- and PVALB-defined neurons, indicating coordinated glial expansion and neuronal loss.\nCell-state-specific differential expression confirmed upregulation of CHI3L1, CHI3L2, and SPP1, and repression of STMN2 and synaptic genes. hdWGCNA uncovered anti-correlated neuronal and glial modules conserved across subtypes and cohorts, linking neuronal downregulation with astrocytic and vascular activation.\nValidation analyses demonstrated reproducible DEGs and module preservation (module Z &gt; 6, directional concordance &gt; 60%).\nBoth FTLD-C9 and FTLD-TDP converge on a shared network architecture characterized by astroglial–neuronal anticorrelation, synaptic repression, and inflammatory activation, despite distinct genetic triggers.\nThese results highlight STMN2 loss and CHI3L1/CHI3L2 upregulation as central molecular signatures linking RNA dysregulation, glial reactivity, and network failure in FTLD.\nThe dataset integration and open analytical pipeline provide a reproducible framework for cell-type-resolved transcriptomic analysis in neurodegeneration."
  },
  {
    "objectID": "Introduction/Background.html",
    "href": "Introduction/Background.html",
    "title": "Background",
    "section": "",
    "text": "Frontotemporal lobar degeneration (FTLD) comprises a group of neurodegenerative disorders characterized by progressive atrophy of the frontal and temporal lobes, leading to profound changes in personality, behaviour, language, and executive function. It represents the most common cause of dementia under 65 years of age and exhibits substantial clinical, genetic, and neuropathological heterogeneity. From a pathological standpoint, FTLD is primarily classified according to the molecular identity of the protein aggregates present in neurons and glia, most commonly TDP-43, tau, or FUS. Among these, FTLD-TDP accounts for ~50% of cases and represents the major pathological subtype associated with both sporadic disease and several genetic forms.\nAt the molecular level, FTLD is increasingly understood as a disorder of RNA metabolism, proteostasis, synaptic function, and neuroimmune interactions, with convergent disruptions across multiple cell types. Early transcriptomic studies in bulk cortical tissue identified dysregulation in synaptic signalling, immune activation, vesicle trafficking, and RNA-processing pathways. More recently, single-nucleus RNA sequencing has shown that FTLD pathology arises through cell-type–specific vulnerabilities, affecting both excitatory and inhibitory neurons, glial populations, vascular cells, and immune-infiltrating populations. This cell-type specificity is essential to understanding how different FTLD subtypes converge or diverge in pathophysiology, particularly in the most prevalent forms: FTLD due to C9orf72 repeat expansion (FTLD-C9) and sporadic FTLD-TDP.\n\n\nThe C9orf72 hexanucleotide repeat expansion (HRE) is the most common genetic cause of both FTLD and amyotrophic lateral sclerosis (ALS). The pathogenic expansion of GGGGCC (G4C2) repeats leads to at least three convergent mechanisms:\n\nHaploinsufficiency of C9orf72, reducing levels of a protein involved in autophagy–lysosomal function and endosomal trafficking.\nReferences: PMC3430713; Nature 2019 reviews.\nRNA toxicity, where expanded sense and antisense repeat-containing transcripts accumulate in the nucleus, forming RNA foci that sequester numerous RNA-binding proteins and disrupt splicing and RNA homeostasis.\nReferences: Nature Neuroscience; Acta Neuropathologica 2018.\nDipeptide repeat proteins (DPRs) produced by repeat-associated non-AUG (RAN) translation, including poly-GA, poly-GP, poly-GR, poly-PA, and poly-PR, which accumulate in cytoplasmic inclusions and disrupt nucleocytoplasmic transport, ribosomal function, and proteostasis.\nReferences: Cell 2015; Nature Genetics 2013; Acta Neuropathol 2018.\n\nNeuropathologically, FTLD-C9 is characterized by:\n\nAbundant DPR inclusions (poly-GA &gt; poly-GP &gt; poly-GR),\nWidespread RNA foci (sense and antisense),\nVariable TDP-43 pathology (usually FTLD-TDP type B),\nMarked vulnerability of extratelencephalic pathways, including corticospinal tracts and cerebellum,\nPronounced neuroinflammation and glial activation.\n\nTranscriptomic studies reveal a consistent pattern of synaptic dysfunction, altered neuronal excitability, astrocytic and microglial activation, vesicular trafficking deficits, and downregulation of STMN2 due to TDP-43 dysfunction. Single-cell analyses demonstrate that specific excitatory neuron populations (e.g., RORB-positive L4/5 neurons) are highly vulnerable, while glial populations show diverse inflammatory signatures.\nThe combination of RNA foci, DPR toxicity, and TDP-43 dyshomeostasis creates a multifactorial, cell-type-dependent cascade culminating in widespread cortical degeneration.\n\n\n\nSporadic FTLD-TDP comprises the largest cluster of FTLD cases and is defined by the intracellular accumulation of phosphorylated, ubiquitinated, and cleaved forms of TDP-43, a ubiquitously expressed RNA-binding protein essential for splicing repression, cryptic exon suppression, stress-granule dynamics, and mRNA transport.\nLoss of nuclear TDP-43 function leads to:\n\nCryptic exon inclusion in critical neuronal genes (e.g., STMN2, UNC13A)\nReferences: Brown et al., 2022; Pasquini et al., 2024.\nImpaired RNA metabolism across thousands of transcripts\nDisruption of synaptic vesicle cycling and axonal maintenance\nWidespread transcriptional deregulation in vulnerable neurons\n\nConcomitantly, cytoplasmic gain-of-function mechanisms contribute to toxicity:\n\nAberrant TDP-43 aggregation\nDysregulated stress granules\nSequestration of RNA-binding proteins\nImpairment of nucleocytoplasmic transport\nReferences: Sirkis et al., 2019; Grossman et al., 2023.\n\nNeuropathologically, FTLD-TDP is subdivided into four major patterns (types A–D) based on laminar distribution and morphology of TDP-43 inclusions. The type B pattern is the most common in sporadic disease and in C9orf72 expansion carriers.\nTranscriptomic studies consistently show:\n\nDownregulation of neuronal and synaptic programs\nUpregulation of immune and inflammatory pathways (CHI3L1/CHI3L2, SPP1, complement)\nSelective vulnerability of excitatory neurons and layer-specific cortical circuits\nAstroglial and microglial activation\nAltered oligodendrocyte function\n\nRecent single-nucleus studies have identified STMN2 loss as a central molecular hallmark linked directly to TDP-43 nuclear depletion, with strong correlation to disease severity.\n\n\n\nBelow is a concise table summarizing the key FTLD neuropathological markers relevant for your study (ACSL3, lncRNA, DPRs, RNA foci, pTDP-43, STMN2), their origin, and pathological impact.\n\n\n\n\n\n\n\n\nMarker\nOrigin / Biological Basis\nPathological Impact\n\n\n\n\nACSL3\nEnzyme involved in long-chain fatty-acid metabolism; upregulated in C9orf72 HRE brains.\nReflects metabolic reprogramming; associated with glial activation and neuronal stress.\n\n\nlncRNAs\nLong non-coding RNAs transcribed from expanded sense/antisense C9orf72 repeat sequences.\nContribute to RNA toxicity; sequester splicing factors; correlate with disease severity.\n\n\nRNA foci (sense & antisense)\nNuclear aggregates of expanded G4C2/G2C4 transcripts.\nSequester RBPs; disrupt splicing and RNA metabolism; correlate with neuronal vulnerability.\n\n\npolyGA\nDipeptide repeat protein generated by RAN translation (sense transcript).\nMost abundant DPR; impairs proteostasis and protein clearance pathways; forms large cytoplasmic inclusions.\n\n\npolyGP\nDPR generated from both sense and antisense RAN translation.\nLess toxic; strong biofluid biomarker of repeat expansion activity.\n\n\npolyGR\nArginine-rich DPR with high nucleolar and ribosomal toxicity.\nHighly toxic; disrupts ribosomes, translation, stress granules, and nucleocytoplasmic transport.\n\n\npTDP-43\nPhosphorylated, cleaved, cytoplasmic TDP-43 aggregates.\nHallmark of FTLD-TDP; indicates nuclear TDP-43 loss-of-function and cytoplasmic gain-of-function toxicity.\n\n\nSTMN2\nAxonal maintenance gene aberrantly spliced due to TDP-43 nuclear depletion.\nSensitive marker of TDP-43 dysfunction; its reduction correlates with disease severity and neuronal loss."
  },
  {
    "objectID": "Introduction/Background.html#c9",
    "href": "Introduction/Background.html#c9",
    "title": "Background",
    "section": "",
    "text": "The C9orf72 hexanucleotide repeat expansion (HRE) is the most common genetic cause of both FTLD and amyotrophic lateral sclerosis (ALS). The pathogenic expansion of GGGGCC (G4C2) repeats leads to at least three convergent mechanisms:\n\nHaploinsufficiency of C9orf72, reducing levels of a protein involved in autophagy–lysosomal function and endosomal trafficking.\nReferences: PMC3430713; Nature 2019 reviews.\nRNA toxicity, where expanded sense and antisense repeat-containing transcripts accumulate in the nucleus, forming RNA foci that sequester numerous RNA-binding proteins and disrupt splicing and RNA homeostasis.\nReferences: Nature Neuroscience; Acta Neuropathologica 2018.\nDipeptide repeat proteins (DPRs) produced by repeat-associated non-AUG (RAN) translation, including poly-GA, poly-GP, poly-GR, poly-PA, and poly-PR, which accumulate in cytoplasmic inclusions and disrupt nucleocytoplasmic transport, ribosomal function, and proteostasis.\nReferences: Cell 2015; Nature Genetics 2013; Acta Neuropathol 2018.\n\nNeuropathologically, FTLD-C9 is characterized by:\n\nAbundant DPR inclusions (poly-GA &gt; poly-GP &gt; poly-GR),\nWidespread RNA foci (sense and antisense),\nVariable TDP-43 pathology (usually FTLD-TDP type B),\nMarked vulnerability of extratelencephalic pathways, including corticospinal tracts and cerebellum,\nPronounced neuroinflammation and glial activation.\n\nTranscriptomic studies reveal a consistent pattern of synaptic dysfunction, altered neuronal excitability, astrocytic and microglial activation, vesicular trafficking deficits, and downregulation of STMN2 due to TDP-43 dysfunction. Single-cell analyses demonstrate that specific excitatory neuron populations (e.g., RORB-positive L4/5 neurons) are highly vulnerable, while glial populations show diverse inflammatory signatures.\nThe combination of RNA foci, DPR toxicity, and TDP-43 dyshomeostasis creates a multifactorial, cell-type-dependent cascade culminating in widespread cortical degeneration."
  },
  {
    "objectID": "Introduction/Background.html#sporadic-tdp",
    "href": "Introduction/Background.html#sporadic-tdp",
    "title": "Background",
    "section": "",
    "text": "Sporadic FTLD-TDP comprises the largest cluster of FTLD cases and is defined by the intracellular accumulation of phosphorylated, ubiquitinated, and cleaved forms of TDP-43, a ubiquitously expressed RNA-binding protein essential for splicing repression, cryptic exon suppression, stress-granule dynamics, and mRNA transport.\nLoss of nuclear TDP-43 function leads to:\n\nCryptic exon inclusion in critical neuronal genes (e.g., STMN2, UNC13A)\nReferences: Brown et al., 2022; Pasquini et al., 2024.\nImpaired RNA metabolism across thousands of transcripts\nDisruption of synaptic vesicle cycling and axonal maintenance\nWidespread transcriptional deregulation in vulnerable neurons\n\nConcomitantly, cytoplasmic gain-of-function mechanisms contribute to toxicity:\n\nAberrant TDP-43 aggregation\nDysregulated stress granules\nSequestration of RNA-binding proteins\nImpairment of nucleocytoplasmic transport\nReferences: Sirkis et al., 2019; Grossman et al., 2023.\n\nNeuropathologically, FTLD-TDP is subdivided into four major patterns (types A–D) based on laminar distribution and morphology of TDP-43 inclusions. The type B pattern is the most common in sporadic disease and in C9orf72 expansion carriers.\nTranscriptomic studies consistently show:\n\nDownregulation of neuronal and synaptic programs\nUpregulation of immune and inflammatory pathways (CHI3L1/CHI3L2, SPP1, complement)\nSelective vulnerability of excitatory neurons and layer-specific cortical circuits\nAstroglial and microglial activation\nAltered oligodendrocyte function\n\nRecent single-nucleus studies have identified STMN2 loss as a central molecular hallmark linked directly to TDP-43 nuclear depletion, with strong correlation to disease severity."
  },
  {
    "objectID": "Introduction/Background.html#neuropathologycal-markers",
    "href": "Introduction/Background.html#neuropathologycal-markers",
    "title": "Background",
    "section": "",
    "text": "Below is a concise table summarizing the key FTLD neuropathological markers relevant for your study (ACSL3, lncRNA, DPRs, RNA foci, pTDP-43, STMN2), their origin, and pathological impact.\n\n\n\n\n\n\n\n\nMarker\nOrigin / Biological Basis\nPathological Impact\n\n\n\n\nACSL3\nEnzyme involved in long-chain fatty-acid metabolism; upregulated in C9orf72 HRE brains.\nReflects metabolic reprogramming; associated with glial activation and neuronal stress.\n\n\nlncRNAs\nLong non-coding RNAs transcribed from expanded sense/antisense C9orf72 repeat sequences.\nContribute to RNA toxicity; sequester splicing factors; correlate with disease severity.\n\n\nRNA foci (sense & antisense)\nNuclear aggregates of expanded G4C2/G2C4 transcripts.\nSequester RBPs; disrupt splicing and RNA metabolism; correlate with neuronal vulnerability.\n\n\npolyGA\nDipeptide repeat protein generated by RAN translation (sense transcript).\nMost abundant DPR; impairs proteostasis and protein clearance pathways; forms large cytoplasmic inclusions.\n\n\npolyGP\nDPR generated from both sense and antisense RAN translation.\nLess toxic; strong biofluid biomarker of repeat expansion activity.\n\n\npolyGR\nArginine-rich DPR with high nucleolar and ribosomal toxicity.\nHighly toxic; disrupts ribosomes, translation, stress granules, and nucleocytoplasmic transport.\n\n\npTDP-43\nPhosphorylated, cleaved, cytoplasmic TDP-43 aggregates.\nHallmark of FTLD-TDP; indicates nuclear TDP-43 loss-of-function and cytoplasmic gain-of-function toxicity.\n\n\nSTMN2\nAxonal maintenance gene aberrantly spliced due to TDP-43 nuclear depletion.\nSensitive marker of TDP-43 dysfunction; its reduction correlates with disease severity and neuronal loss."
  },
  {
    "objectID": "Discussion/Discussion.html#differences-in-c9-and-tdp-differencial-expression",
    "href": "Discussion/Discussion.html#differences-in-c9-and-tdp-differencial-expression",
    "title": "Discussion",
    "section": "Differences in C9 and TDP differencial expression",
    "text": "Differences in C9 and TDP differencial expression"
  },
  {
    "objectID": "Discussion/Discussion.html#potential-target-genes",
    "href": "Discussion/Discussion.html#potential-target-genes",
    "title": "Discussion",
    "section": "Potential target genes",
    "text": "Potential target genes\n\nNPTX2"
  },
  {
    "objectID": "Discussion/Discussion.html#differences-in-c9-and-tdp-gene-modules-correlation",
    "href": "Discussion/Discussion.html#differences-in-c9-and-tdp-gene-modules-correlation",
    "title": "Discussion",
    "section": "Differences in C9 and TDP gene modules correlation",
    "text": "Differences in C9 and TDP gene modules correlation\n\nC9\nAcross cell states, pathology-associated modules converge on several neurobiologically coherent themes:\n\nSynaptic dysfunction\n\npostsynaptic specialization\ndendritic architecture\ndopaminergic synapse\nmossy-fiber → CA3 circuit impairment\nvoltage-gated ion channel activity\nThese align with well-established signatures of FTLD-C9 involving synaptic weakening and circuit disintegration. (Starr and Sattler 2018)\n\nNeuronal metabolic impairment\n\nmitochondrial complex III\naerobic respiration\npyruvate metabolism\nConsistent with emerging literature showing mitochondrial collapse downstream of C9orf72-related toxicity. (Wang et al. 2021)\n\nNeuroimmune dysregulation\n\nleukocyte and microglial activation\nIL-10 pathway regulation\nantimicrobial peptide signaling\ncytokine binding\nMatching known findings that FTLD-C9 evokes aberrant neuroinflammatory programs. (Lall and Baloh 2017)\n\nNeurovascular dysfunction\n\npericyte mitochondrial regulation\nligand-gated channel activity\nsensory/chemical detection in vascular cells\nglial migration + vascular patterning pathways\nHighlighting mechanisms increasingly recognized in C9orf72-related pathology. (Aragón-González et al. 2024)\n\n\nTDP\nAcross cell states, pathology-associated modules converge on key neurobiological mechanisms central to FTLD-TDP:\n\nAxonal and cytoskeletal breakdown\n\nimpaired axon projection and microtubule organization\ndisrupted organelle transport\naltered membrane potential and vesicle cycling\nReflecting loss of the STMN2-dependent axonal maintenance program. (Baughn et al. 2023)\n\nSynaptic disintegration\n\ndysfunction of excitatory synapses\nimpaired pre/post-synaptic architecture\ndysregulated GPCR and calcium-channel signaling\nConsistent with early circuit-level deficits in FTLD-TDP. (Cheemala et al. 2025)\n\nRNA metabolic failure\n\ncompromised splicing, RNA modification, and co-transcriptional processing\nloss of chromatin regulatory functions\nParalleling hallmark TDP-43 nuclear loss-of-function. (Sirkis et al. 2019)\n\nGlial reactivity and neuroimmune remodeling\n\nastrocytic and neuronal cytokine signaling\nmicroglia-interacting receptor pathways\nleukocyte recruitment and immune effector activation\nMatching well-established inflammatory signatures in FTLD-TDP. (https://pmc.ncbi.nlm.nih.gov/articles/PMC8025661/?utm_source=chatgpt.com)\n\nVascular and neuroimmune signaling disturbances\n\nendothelial and leukocyte adhesion pathways\nneuron–vascular cytokine cross-talk\nSuggesting neurovascular involvement in the cortical response to TDP-43 pathology. (Arribas et al. 2024)"
  },
  {
    "objectID": "Introduction/Introduction.html",
    "href": "Introduction/Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Frontotemporal lobar degeneration (FTLD) comprises a heterogeneous group of neurodegenerative disorders marked by progressive impairment in behaviour, language, and executive functions. Among its molecular subtypes, FTLD with TDP-43 pathology (FTLD-TDP) and FTLD caused by C9orf72 hexanucleotide repeat expansions (FTLD-C9) represent the most frequent forms. Although these subtypes share TDP-43 dysregulation as a pathological hallmark, they differ substantially in their upstream disease mechanisms: RNA foci and dipeptide repeat (DPR) toxicity in FTLD-C9 versus primary TDP-43 mislocalization and aggregation in sporadic FTLD-TDP.\nBulk RNA-seq studies have shown broad alterations in synaptic, inflammatory, metabolic, and RNA-processing pathways in FTLD. Yet, bulk tissue obscures the cell-type specificity of these changes—an essential dimension given the layer-specific vulnerability of excitatory neurons, the selective involvement of interneurons, and the diverse responses of astrocytes, microglia, oligodendrocytes, and vascular cells. Recent single-nucleus sequencing studies underscore the importance of cell-type and cell-state–specific transcriptional programs, but comprehensive integrative analyses across disease subtypes and neuropathological markers remain lacking.\nThe emergence of Bayesian deconvolution frameworks, combined with high-resolution snRNA-seq references such as Pineda et al. (Synapse ID: syn51105515), now enables cell-state–resolved inference from bulk data. Such approaches provide an unprecedented opportunity to map FTLD-associated transcriptional dysregulation to specific neuronal and non-neuronal compartments, and to integrate these changes with quantitative neuropathological measures such as pTDP-43 burden, STMN2 loss, RNA foci density, and DPR pathology.\nBy leveraging four independent bulk RNA-seq cohorts—including two newly generated datasets from Sant Pau and two large external datasets—it becomes possible to identify reproducible, cell-type–specific features of FTLD-C9 and FTLD-TDP, and to uncover convergent and divergent disease mechanisms across subtypes."
  },
  {
    "objectID": "Introduction/Introduction.html#hypothesis",
    "href": "Introduction/Introduction.html#hypothesis",
    "title": "Introduction",
    "section": "Hypothesis",
    "text": "Hypothesis\nWe hypothesized that:\n\nFTLD-C9 and sporadic FTLD-TDP exhibit distinct and cell-type–specific transcriptional alterations, particularly within excitatory neurons and glial populations, reflecting their divergent upstream mechanisms (repeat-associated toxicity vs. primary TDP-43 dysfunction).\nBayesian deconvolution using the Pineda et al. single-nucleus reference can resolve these subtype-specific differences at both cell type and cell state resolution, revealing transcriptional programs obscured in bulk analyses.\nNeuropathological markers—including RNA foci (sense/antisense), dipeptide repeat proteins (polyGA, polyGP, polyGR), ACSL3, lncRNAs, pTDP-43, and STMN2 levels—correlate with discrete transcriptional signatures within specific cell states, reflecting coordinated pathological processes rather than global tissue-level effects.\nThese cell-type–specific signatures and their associated co-expression modules are reproducible across independent external datasets (Menden et al. and Pottier et al.), supporting their generality as molecular hallmarks of FTLD-C9 and FTLD-TDP."
  },
  {
    "objectID": "Introduction/Introduction.html#objectives",
    "href": "Introduction/Introduction.html#objectives",
    "title": "Introduction",
    "section": "Objectives",
    "text": "Objectives\nTo test these hypotheses, we pursued the following objectives:\n\n1. Characterize cell-type–specific transcriptional alterations in FTLD-C9 and FTLD-TDP\n\nPerform bulk differential gene expression analyses in newly sequenced Sant Pau FTLD-C9 and FTLD-TDP cohorts.\nApply BayesPrism deconvolution using the Pineda et al. single-cell reference to derive cell-type– and cell-state–specific expression matrices.\n\n\n\n2. Quantify disease-associated alterations in inferred cell-state composition\n\nCompare arcsin-transformed cellular proportions between FTLD cases and healthy controls.\nIdentify specific neuronal, glial, vascular, and immune cell states enriched or depleted in each FTLD subtype.\n\n\n\n3. Link transcriptional changes and cell-state proportions to neuropathological markers\n\nCorrelate cell-state proportions and gene expression with ACSL3, lncRNAs, DPR burden (polyGA, polyGP, polyGR), RNA foci, pTDP-43 levels, and STMN2 expression.\nDetermine subtype-specific molecular markers of disease progression and vulnerability.\n\n\n\n4. Identify and functionally annotate cell-state–specific co-expression modules\n\nConstruct hdWGCNA networks from deconvolved expression profiles.\nIdentify modules associated with disease status and neuropathological markers.\nCharacterize enriched GO pathways across excitatory, inhibitory, glial, vascular, and immune cell states.\n\n\n\n5. Validate findings across two independent external datasets\n\nReplicate differential expression, cell-state composition alterations, and module-level changes in the Menden et al. and Pottier et al. cohorts.\nAssess reproducibility using overlap statistics (Jaccard index, GeneOverlap) and module gene preservation."
  },
  {
    "objectID": "References/References.html",
    "href": "References/References.html",
    "title": "References",
    "section": "",
    "text": "The following references are used throughout this website.\nYou can cite them from any page using, for example, [@pottier2018].\nClicking a citation opens the linked DOI or PubMed page.\n\n\n\nPottier et al. (2018) (Pottier et al. 2018)\nMenden et al. (2023) — multi-omics dataset for genetic FTLD subtypes (RiMod-FTD) (Menden et al. 2023)\nPineda et al. — single-cell atlas of motor and prefrontal cortex in ALS and FTLD (Synapse ID: syn51105515) (Pineda et al. 2024)\n\nSirkis et al. (2019) (D. W. Sirkis et al. 2019)\n\nGrossman et al. (2023) (Grossman et al. 2023)\n\nPasquini et al. (2024) (Pasquini et al. 2024)\n\nBrown et al. — STMN2 regulation (Brown et al. 2020)\n\nStarr & Sattler (2018) — synaptic dysfunction and altered excitability in C9 ALS/FTD (Starr and Sattler 2018)\nWang et al. (2021) — C9orf72 regulation of mitochondrial complex I and energy homeostasis (Wang et al. 2021)\nLall & Baloh (2017) — C9orf72, microglia and neuroinflammation in ALS/FTD (Lall and Baloh 2017)\nAragón-González et al. (2024) — C9ORF72 patient-derived endothelial cells and BBB disruption (Aragón-González et al. 2024)\nBaughn et al. (2023) — mechanism and rescue of STMN2 cryptic splice-polyadenylation in TDP-43 proteinopathies (Baughn et al. 2023)\nCheemala et al. (2025) — ALS/FTD mutation, endothelial TDP-43 loss and blood–brain barrier defects (Cheemala et al. 2025)\nSirkis et al. (2019) — immunological signatures in frontotemporal lobar degeneration (Daniel W. Sirkis et al. 2019)\nArribas et al. (2024) — endothelial TDP-43 in sprouting angiogenesis, barrier integrity and neuroinflammation (Arribas et al. 2024)"
  },
  {
    "objectID": "References/References.html#key-ftld-tdp-literature",
    "href": "References/References.html#key-ftld-tdp-literature",
    "title": "References",
    "section": "",
    "text": "Pottier et al. (2018) (Pottier et al. 2018)\nMenden et al. (2023) — multi-omics dataset for genetic FTLD subtypes (RiMod-FTD) (Menden et al. 2023)\nPineda et al. — single-cell atlas of motor and prefrontal cortex in ALS and FTLD (Synapse ID: syn51105515) (Pineda et al. 2024)\n\nSirkis et al. (2019) (D. W. Sirkis et al. 2019)\n\nGrossman et al. (2023) (Grossman et al. 2023)\n\nPasquini et al. (2024) (Pasquini et al. 2024)\n\nBrown et al. — STMN2 regulation (Brown et al. 2020)\n\nStarr & Sattler (2018) — synaptic dysfunction and altered excitability in C9 ALS/FTD (Starr and Sattler 2018)\nWang et al. (2021) — C9orf72 regulation of mitochondrial complex I and energy homeostasis (Wang et al. 2021)\nLall & Baloh (2017) — C9orf72, microglia and neuroinflammation in ALS/FTD (Lall and Baloh 2017)\nAragón-González et al. (2024) — C9ORF72 patient-derived endothelial cells and BBB disruption (Aragón-González et al. 2024)\nBaughn et al. (2023) — mechanism and rescue of STMN2 cryptic splice-polyadenylation in TDP-43 proteinopathies (Baughn et al. 2023)\nCheemala et al. (2025) — ALS/FTD mutation, endothelial TDP-43 loss and blood–brain barrier defects (Cheemala et al. 2025)\nSirkis et al. (2019) — immunological signatures in frontotemporal lobar degeneration (Daniel W. Sirkis et al. 2019)\nArribas et al. (2024) — endothelial TDP-43 in sprouting angiogenesis, barrier integrity and neuroinflammation (Arribas et al. 2024)"
  },
  {
    "objectID": "References/References.html#table-1-main-genes-and-supporting-references",
    "href": "References/References.html#table-1-main-genes-and-supporting-references",
    "title": "References",
    "section": "Table 1: Main Genes and Supporting References",
    "text": "Table 1: Main Genes and Supporting References\n\n\nCode\nlibrary(knitr)\nlibrary(kableExtra)\n\ngene_refs1 &lt;- data.frame(\n  Gene = c(\"C9orf72\",\"CHI3L1\",\"SPP1\",\"NPTX2\",\"HBA1\",\"HBA2\",\"HBB\",\"SV2C\",\n           \"CXCL10\",\"CX3CR1\",\"CHI3L2\",\"SERPINA5\",\"CXCL11\",\"CBLN2\",\"TTBK1\"),\n  Reference = c(\n    \"PMCID: PMC3430713\",\n    \"PMID: 32344399\",\n    \"PMCID: PMC9720732\",\n    \"PMCID: PMC7279197\",\n    \"PMCID: PMC5786544\",\n    \"PMCID: PMC5786544\",\n    \"PMCID: PMC5786544\",\n    \"PMCID: PMC11224618\",\n    '&lt;a href=\"https://www.frontiersin.org/journals/cellular-neuroscience/articles/10.3389/fncel.2023.1179796/full\" target=\"_blank\"&gt;Frontiers 2023&lt;/a&gt;',\n    '&lt;a href=\"https://www.frontiersin.org/journals/cellular-neuroscience/articles/10.3389/fncel.2023.1179796/full\" target=\"_blank\"&gt;Frontiers 2023&lt;/a&gt;',\n    \"PMCID: PMC7267218\",\n    \"PMCID: PMC7267218\",\n    \"PMCID: PMC7267218\",\n    '&lt;a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC10635220/\" target=\"_blank\"&gt;PMC 2023&lt;/a&gt;',\n    '&lt;a href=\"https://journals.plos.org/plosgenetics/article?id=10.1371%2Fjournal.pgen.1004803\" target=\"_blank\"&gt;PLOS Genetics&lt;/a&gt;'\n  )\n)\n\nkable(gene_refs1, escape = FALSE) %&gt;%\n  kable_styling(full_width = FALSE)\n\n\n\n\n\nGene\nReference\n\n\n\n\nC9orf72\nPMCID: PMC3430713\n\n\nCHI3L1\nPMID: 32344399\n\n\nSPP1\nPMCID: PMC9720732\n\n\nNPTX2\nPMCID: PMC7279197\n\n\nHBA1\nPMCID: PMC5786544\n\n\nHBA2\nPMCID: PMC5786544\n\n\nHBB\nPMCID: PMC5786544\n\n\nSV2C\nPMCID: PMC11224618\n\n\nCXCL10\n&lt;a href=\"https://www.frontiersin.org/journals/cellular-neuroscience/articles/10.3389/fncel.2023.1179796/full\" target=\"_blank\"&gt;Frontiers 2023&lt;/a&gt;\n\n\nCX3CR1\n&lt;a href=\"https://www.frontiersin.org/journals/cellular-neuroscience/articles/10.3389/fncel.2023.1179796/full\" target=\"_blank\"&gt;Frontiers 2023&lt;/a&gt;\n\n\nCHI3L2\nPMCID: PMC7267218\n\n\nSERPINA5\nPMCID: PMC7267218\n\n\nCXCL11\nPMCID: PMC7267218\n\n\nCBLN2\n&lt;a href=\"https://pmc.ncbi.nlm.nih.gov/articles/PMC10635220/\" target=\"_blank\"&gt;PMC 2023&lt;/a&gt;\n\n\nTTBK1\n&lt;a href=\"https://journals.plos.org/plosgenetics/article?id=10.1371%2Fjournal.pgen.1004803\" target=\"_blank\"&gt;PLOS Genetics&lt;/a&gt;"
  },
  {
    "objectID": "Results/Genes_FTLD_summary.html",
    "href": "Results/Genes_FTLD_summary.html",
    "title": "Genes_FTLD_summary",
    "section": "",
    "text": "Code\nlibrary(DT)\nlibrary(readr)\nlibrary(dplyr)\n\nc9 &lt;- read_csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/C9_Pval_gens_URI.csv\")\n\ndatatable(\nc9,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nautoWidth = TRUE,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "Results/Genes_FTLD_summary.html#c9",
    "href": "Results/Genes_FTLD_summary.html#c9",
    "title": "Genes_FTLD_summary",
    "section": "",
    "text": "Code\nlibrary(DT)\nlibrary(readr)\nlibrary(dplyr)\n\nc9 &lt;- read_csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/C9_Pval_gens_URI.csv\")\n\ndatatable(\nc9,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nautoWidth = TRUE,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "Results/Genes_FTLD_summary.html#tdp",
    "href": "Results/Genes_FTLD_summary.html#tdp",
    "title": "Genes_FTLD_summary",
    "section": "TDP",
    "text": "TDP\n\n\nCode\ntdp &lt;- read_csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/TDP_Pval_gens_URI.csv\")\n\ndatatable(\ntdp,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nautoWidth = TRUE,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "Validation/Sc_validation.html",
    "href": "Validation/Sc_validation.html",
    "title": "Validation: Single cell analysis",
    "section": "",
    "text": "On the validation dataset 16 cell types exhibited significative compositon proportions differences in FTLD-C9 compared wihth Healthy controls . This results remark the findings comented before by showing 5 previously identyfied cell types . T cell is not found on the verification dataset as a cell type with significative changes due to the C9 effects. For TDP, in Pottier validation dataset, we found 21 cell proportions with significative changes compared with healthy controls. Among those we find GFAP +, PVALV/PTHLH, LAMP5/PMEPA1, PVALB/CEMIP which are identifyed on Sant Pau’s FTLD-TDP cell compositon analysis."
  },
  {
    "objectID": "Validation/Sc_validation.html#cell-composition",
    "href": "Validation/Sc_validation.html#cell-composition",
    "title": "Validation: Single cell analysis",
    "section": "",
    "text": "On the validation dataset 16 cell types exhibited significative compositon proportions differences in FTLD-C9 compared wihth Healthy controls . This results remark the findings comented before by showing 5 previously identyfied cell types . T cell is not found on the verification dataset as a cell type with significative changes due to the C9 effects. For TDP, in Pottier validation dataset, we found 21 cell proportions with significative changes compared with healthy controls. Among those we find GFAP +, PVALV/PTHLH, LAMP5/PMEPA1, PVALB/CEMIP which are identifyed on Sant Pau’s FTLD-TDP cell compositon analysis."
  },
  {
    "objectID": "Validation/Sc_validation.html#single-cell-dea",
    "href": "Validation/Sc_validation.html#single-cell-dea",
    "title": "Validation: Single cell analysis",
    "section": "Single cell dea",
    "text": "Single cell dea\nTo validate our FTLD-C9 findings, differentially expressed genes (DEGs) from the Sant Pau FTLD-TDP dataset were compared with the Rimod dataset at single-cell resolution. Overlap between datasets was evaluated using both the Jaccard index and GeneOverlap statistics to assess reproducibility. Several populations showed notable transcriptional activity. Smooth muscle cells (SMCs) exhibited 79 upregulated and 191 downregulated genes in FTLD-C9, compared to 106 upregulated and 25 downregulated genes in Rimod.\nDespite a small number of overlapping genes (3 down), these changes were statistically significant, with Jaccard indice 0.014 and GeneOverlap p-value of 2.88 e-3 , indicating a modest but meaningful transcriptional concordance. GFAP - astrocytes displayed 51 upregulated and 115 downregulated genes in FTLD-C9, with 3 downregulated genes overlapping with Rimod. This produced a low Jaccard indice 0.025 and GeneOverlap p-value of 6.42e-6 suggesting a reproducible signal in this glial subtype.\nExcitatory neurons, particularly, were among the most transcriptionally active. CUX2/RASGRF2 (36 up, 87 down) and RORB/LRRK1 (81 up, 182 down), showed moderate overlap with Rimod downregulated genes, with Jaccard indices 0.01 for RORB/LRRK1 and 0.028 for CUX2/RASGRF2 and GeneOverlap p-values suggesting a mix of significant (CUX2/RASGRF2 up: p = 0.00014) and less robust overlaps (RORB/LRRK1 down: p = 0.02). Other neuron-enriched populations, such as RORB/POU3F2 with 147 upregulated and 286 downregulated genes in FTLD-C9, overlapping with 2 downregulated genes in Rimod. Jaccard indice of 0.0065 , along with almost significant GeneOverlap p-value 0,054. Oligodendrocytes displayed 122 upregulated and 226 downregulated genes, overlapping with 1 downregulated genes in Rimod. The Jaccard indice was low 0,004 and the GeneOverlap p-value for downregulated genes 0,10 suggests strong reproducibility for this lineage but is not significative.\nSmaller populations like T cells, had limited overlap with a jaccard index of 0,033 but showed significant GeneOverlap (p = 0.009 for T cells downregulation), reflecting discrete but consistent transcriptional shifts. Many rare or transcriptionally quiet populations—including arterial (jaccard = 0,038 p = 0,0004), capillary (jaccard = 0,0178,p= 0,02), and various interneurons—showed negligible overlap, consistent with their low baseline activity. In summary, while global transcriptomic concordance between FTLD-C9 and Rimod datasets is modest, SMCs, GFAP - astrocytes, and excitatory neurons (especially CUX2/RASGRF2) show reproducible transcriptional signatures, highlighting specific cell types with robust and conserved gene expression alterations in FTLD-C9.\nTo investigate the robustness of our FTLD-TDP findings, we compared the differentially expressed genes (DEGs) identified in the Sant Pau FTLD-TDP dataset with an independent dataset from Pottier et al. Differential expression analyses were performed at the single-cell level, and overlap between datasets was systematically evaluated using the Jaccard index and GeneOverlap statistics.\nAcross the validation dataset, transcriptional activity was generally low in most populations, with only a few cell types exhibiting any significant changes. Among the most transcriptionally responsive populations, smooth muscle cells (SMCs) displayed a modest number of validated genes (n = 5), with 3 upregulated and 3 downregulated transcripts in Sant Pau compared to 1,468 upregulated and 1,535 downregulated genes in Pottier. The small overlap of 3 upregulated and 2 downregulated genes yielded low Jaccard indices (0.002 for upregulated and 0.0013 for downregulated) and significant GeneOverlap values (p = 0,0007 for upregulated; p = 0.024 for downregulated), indicating a limited but statistically meaningful concordance between datasets. GFAP - astrocytes also showed minimal validated transcriptional changes (n = 2), with a single upregulated and downregulated gene overlapping between datasets.\nThe Jaccard indices were very low (0.0009 for upregulated; 0.0007 for downregulated), but the GeneOverlap p-values (0.065 and 0.085, respectively) are not significant, only suggesting these changes may reflect a reproducible transcriptional signal in this glial subset. Excitatory neuron populations such as RORB/POU3F2 showed slightly higher transcriptional overlap, with 1 common upregulated and 3 downregulated genes, resulting in Jaccard indices of 0.0035 and 0.0057, respectively. GeneOverlap analyses confirmed the significance for both up- and downregulated transcripts (p = 0.049 and p = 0,00029), pointing to subtle but conserved transcriptional alterations in this excitatory lineage. Other cell populations—including RORB/LRRK1, oligodendrocytes, and microglia—showed no overlap, with zero shared DEGs and consequently Jaccard indices of 0.\nOverall, this analysis highlights that while global transcriptional concordance between the Sant Pau and Pottier datasets is limited, certain populations—SMCs, GFAP - astrocytes, and RORB/POU3F2 neurons—exhibit reproducible signals. These results underscore the challenges of cross-cohort validation in FTLD-TDP, especially for rare or transcriptionally quiet cell types, but also pinpoint discrete cell types with robust, conserved gene expression changes.\n\nC9\n\n\nCode\nlibrary(\"DT\")\ndata &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/10. VALIDATION/C9_NEW/CS/C9_Validation_results_cs.csv\")\n\ndatatable(\ndata,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nscrollX = TRUE\n)\n)\n\n\n\n\n\n\n\n\nTDP\n\n\nCode\ndata &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/10. VALIDATION/C9_NEW/CS/C9_Validation_results_cs.csv\")\n\ndatatable(\ndata,\nfilter = \"top\",\noptions = list(\npageLength = 25,\nscrollX = TRUE\n)\n)"
  },
  {
    "objectID": "Methods/Bulk_dea.html",
    "href": "Methods/Bulk_dea.html",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "Bulk RNA-sequencing provides a comprehensive measurement of transcriptional activity at the tissue level and remains the foundation for molecular characterization in neurodegenerative disease. In FTLD, bulk analyses have repeatedly identified widespread alterations in synaptic signaling, immune activation, vesicle trafficking, lipid metabolism, and RNA-processing pathways. However, reproducibly detecting these signatures requires rigorous statistical modeling due to subtle but biologically meaningful differences in gene expression, limited sample sizes typical of post-mortem cohorts, and technical variability between sequencing libraries.\nTo ensure robust inference across the four cohorts studied, differential expression was performed using edgeR (Robinson, McCarthy, and Smyth 2010), a negative binomial framework specifically designed for RNA-seq count data . The quasi-likelihood (QL) pipeline implemented in edgeR provides improved control of false positives and greater stability in small cohorts, making it an appropriate choice for FTLD studies where subtle expression changes may reflect early or cell-type–specific pathological processes.\n\n\n\n\n\nRaw gene-level count matrices were generated from poly(A)-selected bulk RNA-sequencing of frontal cortex tissue. Analyses were performed independently for:\n\nSant Pau FTLD-C9 vs. controls\nSant Pau FTLD-TDP vs. control.\nMenden et al. FTLD-C9 vs. controls\nPottier et al. FTLD-TDP vs. controls\n\nTo harmonize analyses, each dataset underwent identical preprocessing:\n\nRemoval of low-quality samples or ambiguous diagnostic classifications.\nFiltering of genes using filterByExpr(), retaining only transcripts with sufficient expression to yield reliable tests.\n\n-   Typical retained genes: **\\~21k** per cohort\n\nConstruction of DGEList objects for each comparison.\n\n\n\n\nSequencing depth and composition biases were corrected using:\n\nTrimmed Mean of M-values (TMM) normalization, generating effective library sizes.\nConversion to log2-counts per million (logCPM) for exploratory diagnostics (PCA, MDS).\n\nTo account for biological and technical variability:\n\nDispersion estimates were obtained using estimateDisp(),\nFollowed by glmFit() to fit negative binomial generalized linear models.\n\nWhere available, surrogate variables (SVs) estimated from the bulk data were included as covariates to control for latent confounders.\n\n\n\nFor each dataset, a design matrix modeled diagnostic group as the primary variable of interest:\n\nFTLD-C9 vs. Healthy\nFTLD-TDP vs. Healthy\n\nControls were defined as the reference level.\nContrast vectors were constructed to explicitly test for group differences.\nThis yielded gene-wise likelihood ratio tests (glmLRT).\n\n\n\nAll p-values were adjusted using the Benjamini–Hochberg FDR procedure.\nGenes were considered significantly differentially expressed when:\n\nFDR &lt; 0.05\n\nFor interpretability, the following statistics were extracted:\n\nFold change (FC)\nlog2 fold change (logFC)\nRaw and adjusted p-values\nMean expression per group\n\n\n\n\nTo assess robustness:\n\nDifferential expression results from the Sant Pau FTLD-C9 cohort were compared with the Menden et al. FTLD-C9 dataset.\nFTLD-TDP results were compared to Pottier et al.\nOverlap significance was evaluated using GeneOverlap tests and Jaccard indices.\n\nThis approach enabled identification of cell-type–agnostic signatures that are reproducible across cohorts and subtype-specific signatures that distinguish FTLD-C9 from FTLD-TDP.\n\n\n\n\nThe bulk RNA-seq analyses were designed to:\n\nIdentify transcriptional signatures distinguishing FTLD-C9, FTLD-TDP, and healthy controls, providing a global overview of disease-associated dysregulation.\nEstablish baseline transcriptomic differences prior to deconvolution, enabling direct comparison with cell-state–resolved results obtained using BayesPrism.\nServe as a foundation for validation, enabling cross-cohort consistency checks with large, published datasets (Menden et al., Pottier et al.).\nGenerate disease-relevant gene lists for downstream functional enrichment, co-expression network analyses (hdWGCNA), and neuropathology correlation analyses.\nProvide independent evidence for known FTLD mechanisms, including:\n\nsynaptic deficits,\nglial and immune activation,\nmetabolic and mitochondrial disruption,\nTDP-43 target dysregulation (e.g., STMN2, UNC13A).\n\n\nBy integrating these bulk findings with cell-type–resolved analyses, we were able to map global transcriptomic alterations to their cellular origins and characterize convergent and divergent molecular pathways across FTLD-C9 and FTLD-TDP.\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\n################################################################################\n# Paths and parameters\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD/TDP_LRT\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"  \n################################################################################\n\n# Load sample metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, sheetIndex = 1)\ncase_legend$sample.ID &lt;- paste0(\"X\", case_legend$sample.ID)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Load bulk count data\nbulk_data &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\n# Make sure rownames (sample IDs) match those in case_legend\nbulk_data &lt;- t(bulk_data)\n\n# Keep only samples in both case_legend and bulk_data\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\n\n# Create output directory\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Process each condition (here just one condition \"TDP\")\nfor (condition in CONDITIONS) {\n  \n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    # Subset metadata for groups of interest\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    # Select bulk samples present in metadata\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    \n    # Replace missing values with small value (if any)\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)  # transpose counts\n    \n    # Filter low expression genes\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes=FALSE]\n    \n    # Normalize\n    y &lt;- calcNormFactors(y)\n    \n    # Plot average log CPM\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    # MD plot\n    plot_filename &lt;- file.path(condition_folder, \"MD_plot.png\")\n    png(file = plot_filename)\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    # Design matrix\n    design &lt;- model.matrix(~ 0 + group)\n    colnames(design) &lt;- levels(group)\n    \n    # Estimate dispersion\n    y &lt;- estimateDisp(y, design)\n    \n    # Fit model\n    fit &lt;- glmFit(y, design)\n    \n    # Contrast\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    \n    # Decide DE\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    # Add adjusted p-values and results\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    \n    # Save results\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    # Histogram plot of AveLogCPM\n    plot_filename &lt;- file.path(condition_folder, \"histogram_plot.png\")\n    png(file = plot_filename)\n    hist(AveLogCPM)\n    dev.off()\n    \n    # BCV plot\n    plot_filename &lt;- file.path(condition_folder, \"BCV_plot.png\")\n    png(file = plot_filename)\n    plotBCV(y)\n    dev.off()\n    \n    # MD plot with DE status (volcano-like)\n    plot_filename &lt;- file.path(condition_folder, \"MD_res_plot.png\")\n    png(file = plot_filename)\n    plotMD(res, status = is.de)\n    dev.off()\n    \n    # Heatmap top DE genes\n    logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n    tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n    o &lt;- order(tr$table$PValue)\n    top_genes &lt;- head(o, 30)\n    logCPM_top &lt;- logCPM[top_genes, ]\n    \n    plot_filename &lt;- file.path(condition_folder, \"Heatmap.png\")\n    png(file = plot_filename)\n    coolmap(logCPM_top, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/NEW_LRT_SVAcorrect/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- gsub(\"-\", \"\\\\.\", rownames(case_legend))\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\", ]\ncase_legend$GROUP[case_legend$GROUP == \"Control\"] &lt;- \"Healthy\"\ncase_legend$GROUP[case_legend$GROUP != \"Healthy\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- factor(case_legend$GROUP)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n\n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n\n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n\n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n\n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n\n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n\n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n\n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n\n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD_C9_sv\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, row.names = 1, sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \",\")\ncase_legend$rn &lt;- rownames(case_legend)\nrownames(surrogate_variables) &lt;- gsub(\"long\", \"\", rownames(surrogate_variables))\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$sample.ID &lt;- case_legend$rn \nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\nrownames(bulk_raw) &lt;- gsub(\"X\", \"\", rownames(bulk_raw))\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/Rimmod_LRT_SV_2/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- rownames(case_legend)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-GRN\", ]\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-MAPT\", ]\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode != \"Healthy\"] &lt;- \"C9orf72\"\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \n\nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1, sep = \",\")\nbulk_raw &lt;-t(bulk_raw)\n#colnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\n\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}"
  },
  {
    "objectID": "Methods/Bulk_dea.html#rationale",
    "href": "Methods/Bulk_dea.html#rationale",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "Bulk RNA-sequencing provides a comprehensive measurement of transcriptional activity at the tissue level and remains the foundation for molecular characterization in neurodegenerative disease. In FTLD, bulk analyses have repeatedly identified widespread alterations in synaptic signaling, immune activation, vesicle trafficking, lipid metabolism, and RNA-processing pathways. However, reproducibly detecting these signatures requires rigorous statistical modeling due to subtle but biologically meaningful differences in gene expression, limited sample sizes typical of post-mortem cohorts, and technical variability between sequencing libraries.\nTo ensure robust inference across the four cohorts studied, differential expression was performed using edgeR (Robinson, McCarthy, and Smyth 2010), a negative binomial framework specifically designed for RNA-seq count data . The quasi-likelihood (QL) pipeline implemented in edgeR provides improved control of false positives and greater stability in small cohorts, making it an appropriate choice for FTLD studies where subtle expression changes may reflect early or cell-type–specific pathological processes."
  },
  {
    "objectID": "Methods/Bulk_dea.html#analytical-strategy",
    "href": "Methods/Bulk_dea.html#analytical-strategy",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "Raw gene-level count matrices were generated from poly(A)-selected bulk RNA-sequencing of frontal cortex tissue. Analyses were performed independently for:\n\nSant Pau FTLD-C9 vs. controls\nSant Pau FTLD-TDP vs. control.\nMenden et al. FTLD-C9 vs. controls\nPottier et al. FTLD-TDP vs. controls\n\nTo harmonize analyses, each dataset underwent identical preprocessing:\n\nRemoval of low-quality samples or ambiguous diagnostic classifications.\nFiltering of genes using filterByExpr(), retaining only transcripts with sufficient expression to yield reliable tests.\n\n-   Typical retained genes: **\\~21k** per cohort\n\nConstruction of DGEList objects for each comparison.\n\n\n\n\nSequencing depth and composition biases were corrected using:\n\nTrimmed Mean of M-values (TMM) normalization, generating effective library sizes.\nConversion to log2-counts per million (logCPM) for exploratory diagnostics (PCA, MDS).\n\nTo account for biological and technical variability:\n\nDispersion estimates were obtained using estimateDisp(),\nFollowed by glmFit() to fit negative binomial generalized linear models.\n\nWhere available, surrogate variables (SVs) estimated from the bulk data were included as covariates to control for latent confounders.\n\n\n\nFor each dataset, a design matrix modeled diagnostic group as the primary variable of interest:\n\nFTLD-C9 vs. Healthy\nFTLD-TDP vs. Healthy\n\nControls were defined as the reference level.\nContrast vectors were constructed to explicitly test for group differences.\nThis yielded gene-wise likelihood ratio tests (glmLRT).\n\n\n\nAll p-values were adjusted using the Benjamini–Hochberg FDR procedure.\nGenes were considered significantly differentially expressed when:\n\nFDR &lt; 0.05\n\nFor interpretability, the following statistics were extracted:\n\nFold change (FC)\nlog2 fold change (logFC)\nRaw and adjusted p-values\nMean expression per group\n\n\n\n\nTo assess robustness:\n\nDifferential expression results from the Sant Pau FTLD-C9 cohort were compared with the Menden et al. FTLD-C9 dataset.\nFTLD-TDP results were compared to Pottier et al.\nOverlap significance was evaluated using GeneOverlap tests and Jaccard indices.\n\nThis approach enabled identification of cell-type–agnostic signatures that are reproducible across cohorts and subtype-specific signatures that distinguish FTLD-C9 from FTLD-TDP."
  },
  {
    "objectID": "Methods/Bulk_dea.html#analytical-goals-of-the-bulk-differential-expression-component",
    "href": "Methods/Bulk_dea.html#analytical-goals-of-the-bulk-differential-expression-component",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "The bulk RNA-seq analyses were designed to:\n\nIdentify transcriptional signatures distinguishing FTLD-C9, FTLD-TDP, and healthy controls, providing a global overview of disease-associated dysregulation.\nEstablish baseline transcriptomic differences prior to deconvolution, enabling direct comparison with cell-state–resolved results obtained using BayesPrism.\nServe as a foundation for validation, enabling cross-cohort consistency checks with large, published datasets (Menden et al., Pottier et al.).\nGenerate disease-relevant gene lists for downstream functional enrichment, co-expression network analyses (hdWGCNA), and neuropathology correlation analyses.\nProvide independent evidence for known FTLD mechanisms, including:\n\nsynaptic deficits,\nglial and immune activation,\nmetabolic and mitochondrial disruption,\nTDP-43 target dysregulation (e.g., STMN2, UNC13A).\n\n\nBy integrating these bulk findings with cell-type–resolved analyses, we were able to map global transcriptomic alterations to their cellular origins and characterize convergent and divergent molecular pathways across FTLD-C9 and FTLD-TDP.\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\n################################################################################\n# Paths and parameters\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD/TDP_LRT\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"  \n################################################################################\n\n# Load sample metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, sheetIndex = 1)\ncase_legend$sample.ID &lt;- paste0(\"X\", case_legend$sample.ID)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Load bulk count data\nbulk_data &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\n# Make sure rownames (sample IDs) match those in case_legend\nbulk_data &lt;- t(bulk_data)\n\n# Keep only samples in both case_legend and bulk_data\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\n\n# Create output directory\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Process each condition (here just one condition \"TDP\")\nfor (condition in CONDITIONS) {\n  \n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    # Subset metadata for groups of interest\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    # Select bulk samples present in metadata\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    \n    # Replace missing values with small value (if any)\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)  # transpose counts\n    \n    # Filter low expression genes\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes=FALSE]\n    \n    # Normalize\n    y &lt;- calcNormFactors(y)\n    \n    # Plot average log CPM\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    # MD plot\n    plot_filename &lt;- file.path(condition_folder, \"MD_plot.png\")\n    png(file = plot_filename)\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    # Design matrix\n    design &lt;- model.matrix(~ 0 + group)\n    colnames(design) &lt;- levels(group)\n    \n    # Estimate dispersion\n    y &lt;- estimateDisp(y, design)\n    \n    # Fit model\n    fit &lt;- glmFit(y, design)\n    \n    # Contrast\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    \n    # Decide DE\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    # Add adjusted p-values and results\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    \n    # Save results\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    # Histogram plot of AveLogCPM\n    plot_filename &lt;- file.path(condition_folder, \"histogram_plot.png\")\n    png(file = plot_filename)\n    hist(AveLogCPM)\n    dev.off()\n    \n    # BCV plot\n    plot_filename &lt;- file.path(condition_folder, \"BCV_plot.png\")\n    png(file = plot_filename)\n    plotBCV(y)\n    dev.off()\n    \n    # MD plot with DE status (volcano-like)\n    plot_filename &lt;- file.path(condition_folder, \"MD_res_plot.png\")\n    png(file = plot_filename)\n    plotMD(res, status = is.de)\n    dev.off()\n    \n    # Heatmap top DE genes\n    logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n    tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n    o &lt;- order(tr$table$PValue)\n    top_genes &lt;- head(o, 30)\n    logCPM_top &lt;- logCPM[top_genes, ]\n    \n    plot_filename &lt;- file.path(condition_folder, \"Heatmap.png\")\n    png(file = plot_filename)\n    coolmap(logCPM_top, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/NEW_LRT_SVAcorrect/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- gsub(\"-\", \"\\\\.\", rownames(case_legend))\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\", ]\ncase_legend$GROUP[case_legend$GROUP == \"Control\"] &lt;- \"Healthy\"\ncase_legend$GROUP[case_legend$GROUP != \"Healthy\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- factor(case_legend$GROUP)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n\n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n\n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n\n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n\n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n\n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n\n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n\n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n\n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD_C9_sv\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, row.names = 1, sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \",\")\ncase_legend$rn &lt;- rownames(case_legend)\nrownames(surrogate_variables) &lt;- gsub(\"long\", \"\", rownames(surrogate_variables))\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$sample.ID &lt;- case_legend$rn \nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\nrownames(bulk_raw) &lt;- gsub(\"X\", \"\", rownames(bulk_raw))\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n\n\n\n\n\nCode\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/Rimmod_LRT_SV_2/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- rownames(case_legend)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-GRN\", ]\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-MAPT\", ]\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode != \"Healthy\"] &lt;- \"C9orf72\"\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \n\nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1, sep = \",\")\nbulk_raw &lt;-t(bulk_raw)\n#colnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\n\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}"
  },
  {
    "objectID": "Validation/Hdwgcna_validation.html",
    "href": "Validation/Hdwgcna_validation.html",
    "title": "Validation: Gene modules analysis",
    "section": "",
    "text": "Baed on shared genes, we matched the modules obtained from sant pau’s cell states with the obteined from the validation datasets.\n\n\nCode\n# Load necessary libraries\nlibrary(dplyr)\nlibrary(DT)\nlibrary(GeneOverlap)\n\n# Function to get list of subfolders in a directory\nlist_subfolders &lt;- function(dir_path) {\n  list.dirs(dir_path, recursive = FALSE, full.names = FALSE)\n}\n\n# Function to read gene list from a file (one column named \"X\")\nread_genes &lt;- function(file_path) {\n  df &lt;- read.csv(file_path, stringsAsFactors = FALSE, col.names = \"X\")\n  if (!\"X\" %in% colnames(df)) {\n    stop(paste(\"File\", file_path, \"does not contain column named 'X'\"))\n  }\n  unique(df$X)\n}\n\n# Main function to compare files\ncompare_modules &lt;- function(dir1, dir2) {\n  folders1 &lt;- list_subfolders(dir1)\n  folders2 &lt;- list_subfolders(dir2)\n  \n  # Check if folder structure is the same\n  common_folders &lt;- intersect(folders1, folders2)\n  if (length(common_folders) == 0) {\n    stop(\"No common folders found between directories\")\n  }\n  \n  results &lt;- data.frame(\n    folder         = character(),\n    file_dir1      = character(),\n    file_dir2      = character(),\n    n_coincidences = integer(),\n    jaccard        = numeric(),\n    p_overlap      = numeric(),\n    stringsAsFactors = FALSE\n  )\n  \n  for (folder in common_folders) {\n    modules_dir1 &lt;- file.path(dir1, folder, \"MODULES\")\n    modules_dir2 &lt;- file.path(dir2, folder, \"MODULES\")\n    \n    if (!dir.exists(modules_dir1) | !dir.exists(modules_dir2)) {\n      warning(paste(\"MODULES folder missing in\", folder))\n      next\n    }\n    \n    files1 &lt;- list.files(modules_dir1, pattern = \"\\\\.csv$\", full.names = TRUE)\n    files2 &lt;- list.files(modules_dir2, pattern = \"\\\\.csv$\", full.names = TRUE)\n    \n    # Exclude cor_summary.csv and hubs.csv\n    files1 &lt;- files1[!basename(files1) %in% c(\"cor_summary.csv\", \"hubs.csv\")]\n    files2 &lt;- files2[!basename(files2) %in% c(\"cor_summary.csv\", \"hubs.csv\")]\n    \n    # Read all files' genes once to speed up\n    genes_list1 &lt;- lapply(files1, read_genes)\n    names(genes_list1) &lt;- basename(files1)\n    genes_list2 &lt;- lapply(files2, read_genes)\n    names(genes_list2) &lt;- basename(files2)\n    \n    # Gene universe for this folder\n    universe_genes &lt;- unique(c(unlist(genes_list1), unlist(genes_list2)))\n    universe_size  &lt;- length(universe_genes)\n    \n    # Compare each file from dir1 with each file from dir2\n    for (f1 in names(genes_list1)) {\n      for (f2 in names(genes_list2)) {\n        genes1 &lt;- genes_list1[[f1]]\n        genes2 &lt;- genes_list2[[f2]]\n        \n        # Intersection and Jaccard\n        n_common   &lt;- length(intersect(genes1, genes2))\n        union_size &lt;- length(union(genes1, genes2))\n        jaccard    &lt;- if (union_size == 0) NA_real_ else n_common / union_size\n        \n        # GeneOverlap hypergeometric p-value\n        if (universe_size == 0 || (length(genes1) == 0 && length(genes2) == 0)) {\n          p_ov &lt;- NA_real_\n        } else {\n          go_obj &lt;- newGeneOverlap(genes1, genes2, genome.size = universe_size)\n          p_ov   &lt;- testGeneOverlap(go_obj)@pval\n        }\n        \n        results &lt;- rbind(\n          results,\n          data.frame(\n            folder         = folder,\n            file_dir1      = f1,\n            file_dir2      = f2,\n            n_coincidences = n_common,\n            jaccard        = jaccard,\n            p_overlap      = p_ov,\n            stringsAsFactors = FALSE\n          )\n        )\n      }\n    }\n  }\n  \n  results\n}\n\n# Usage example:\ndir1 &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2\"\ndir2 &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS\"\n\noutput_table &lt;- compare_modules(dir1, dir2)\n\noutput_filtered &lt;- output_table %&gt;%\n  filter(\n    basename(file_dir1) != \"grey.csv\",\n    basename(file_dir2) != \"grey.csv\"\n  ) %&gt;%\n  arrange(is.na(p_overlap), p_overlap, desc(n_coincidences))\n\n# ---- Quarto-friendly interactive table (filtered only) ----\n\ndatatable(\n  output_filtered,\n  filter  = \"top\",\n  options = list(pageLength = 25, autoWidth = TRUE),\n  caption = \"Module overlaps (non-grey modules) between FTLD-C9 and RiMod, ranked by GeneOverlap p-value\"\n)\n\n\n\n\n\n\nCode\n#write.csv(output_table, \"C9_modules_gene_overlap_comparison.csv\", row.names = FALSE)\n\n\n\n\nCode\n# Load necessary libraries\nlibrary(dplyr)\nlibrary(DT)\nlibrary(GeneOverlap)\n\n# Function to get list of subfolders in a directory\nlist_subfolders &lt;- function(dir_path) {\n  list.dirs(dir_path, recursive = FALSE, full.names = FALSE)\n}\n\n# Function to read gene list from a file (one column named \"X\")\nread_genes &lt;- function(file_path) {\n  df &lt;- read.csv(file_path, stringsAsFactors = FALSE, col.names = \"X\")\n  if (!\"X\" %in% colnames(df)) {\n    stop(paste(\"File\", file_path, \"does not contain column named 'X'\"))\n  }\n  unique(df$X)\n}\n\n# Main function to compare files\ncompare_modules &lt;- function(dir1, dir2) {\n  folders1 &lt;- list_subfolders(dir1)\n  folders2 &lt;- list_subfolders(dir2)\n  \n  # Check if folder structure is the same\n  common_folders &lt;- intersect(folders1, folders2)\n  if (length(common_folders) == 0) {\n    stop(\"No common folders found between directories\")\n  }\n  \n  results &lt;- data.frame(\n    folder         = character(),\n    file_dir1      = character(),\n    file_dir2      = character(),\n    n_coincidences = integer(),\n    jaccard        = numeric(),\n    p_overlap      = numeric(),\n    stringsAsFactors = FALSE\n  )\n  \n  for (folder in common_folders) {\n    modules_dir1 &lt;- file.path(dir1, folder, \"MODULES\")\n    modules_dir2 &lt;- file.path(dir2, folder, \"MODULES\")\n    \n    if (!dir.exists(modules_dir1) | !dir.exists(modules_dir2)) {\n      warning(paste(\"MODULES folder missing in\", folder))\n      next\n    }\n    \n    files1 &lt;- list.files(modules_dir1, pattern = \"\\\\.csv$\", full.names = TRUE)\n    files2 &lt;- list.files(modules_dir2, pattern = \"\\\\.csv$\", full.names = TRUE)\n    \n    # Exclude cor_summary.csv and hubs.csv\n    files1 &lt;- files1[!basename(files1) %in% c(\"cor_summary.csv\", \"hubs.csv\")]\n    files2 &lt;- files2[!basename(files2) %in% c(\"cor_summary.csv\", \"hubs.csv\")]\n    \n    # Read all files genes once to speed up\n    genes_list1 &lt;- lapply(files1, read_genes)\n    names(genes_list1) &lt;- basename(files1)\n    genes_list2 &lt;- lapply(files2, read_genes)\n    names(genes_list2) &lt;- basename(files2)\n    \n    # Define gene universe for this folder (all genes seen in either dataset)\n    universe_size &lt;- length(unique(c(unlist(genes_list1), unlist(genes_list2))))\n    \n    # Compare each file from dir1 with each file from dir2\n    for (f1 in names(genes_list1)) {\n      for (f2 in names(genes_list2)) {\n        genes1 &lt;- genes_list1[[f1]]\n        genes2 &lt;- genes_list2[[f2]]\n        \n        # Intersection size\n        n_common &lt;- length(intersect(genes1, genes2))\n        \n        # Jaccard similarity\n        union_size &lt;- length(union(genes1, genes2))\n        jaccard &lt;- if (union_size == 0) NA_real_ else n_common / union_size\n        \n        # GeneOverlap hypergeometric p-value\n        if (universe_size == 0 || (length(genes1) == 0 && length(genes2) == 0)) {\n          p_ov &lt;- NA_real_\n        } else {\n          go_obj &lt;- newGeneOverlap(genes1, genes2, genome.size = universe_size)\n          p_ov &lt;- testGeneOverlap(go_obj)@pval\n        }\n        \n        results &lt;- rbind(\n          results,\n          data.frame(\n            folder         = folder,\n            file_dir1      = f1,\n            file_dir2      = f2,\n            n_coincidences = n_common,\n            jaccard        = jaccard,\n            p_overlap      = p_ov,\n            stringsAsFactors = FALSE\n          )\n        )\n      }\n    }\n  }\n  \n  results\n}\n\n# --- Usage example ---\n\ndir1 &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\"\ndir2 &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\"\n\noutput_table &lt;- compare_modules(dir1, dir2)\n\n# Filter out grey modules and sort by p-value (non-NA first, lowest p first)\noutput_filtered &lt;- output_table %&gt;%\n  filter(\n    basename(file_dir1) != \"grey.csv\",\n    basename(file_dir2) != \"grey.csv\"\n  ) %&gt;%\n  arrange(is.na(p_overlap), p_overlap, desc(n_coincidences))\n\n# ---- Quarto-friendly interactive table (filtered only) ----\n\ndatatable(\n  output_filtered,\n  filter = \"top\",\n  options = list(pageLength = 25, autoWidth = TRUE),\n  caption = \"Module overlaps between FTLD-TDP and NEW (non-grey modules), ranked by GeneOverlap p-value\"\n)\n\n\n\n\n\n\nCode\n# write.csv(output_table, \"TDP_modules_gene_overlap_comparison.csv\", row.names = FALSE)"
  },
  {
    "objectID": "Validation/Hdwgcna_validation.html#lists-will-be-removed",
    "href": "Validation/Hdwgcna_validation.html#lists-will-be-removed",
    "title": "Validation: Gene modules analysis",
    "section": "LISTS (Will be removed )",
    "text": "LISTS (Will be removed )\n\nFTLD-C9\nArterial:\ngreenyellow - organic hydroxy compound transport, ceramide biosynthetic process, peptide receptor activity, neuropeptide signaling pathway, ligand-gated monoatomic cation channel activity, negative regulation of gliogenesis, synaptic transmission glutamatergic\nlightgreen + positive regultaion of stablishment of protein localization telomere, DNA integration , DNA-templated transcription, mismatch repair, catalytic activity acting on DNA, ferrous iron binding, ergulation of endocrine process\nred + promoter specific chromatin binding, heterochromatin , chromosome organization\nyellow - mechanosensitive monoatomic channel activity, mucocilary cleareanvce, regulation of synaptic vessicle fussion to presinaptic active zone membrane\ndarkgrey + carbohydrate binding, phosphatidylcholine binding, Schaffer colateral CA1 synapse, chemocal synaptic transmission , response to osmotic stress\ngreen + ribosomal subunit biogenesis, ribonucleoprotein complex biogenesis, tRNA metabolic process, cullin-RING ubiquitin ligase complex, SMN complex, nRNA splicing via spliceosome\nmagenta + reionalzation, retection of chamical stimulus involved in sensory perception, appendage development, cell fate specification\nCapillary:\npink +\ngreen -\ngrey60 -\nblack -\nbrown +\nred -\nCDH4 SCGN:\ndarkgreen +\nmagenta -\ndarkgrey +\nskyblue -\ngreenyellow -\ngrey60 -\nCUX2 RASGRF:\npink -\nblack +\nroyalblue -\nyellow +\nred +\nbrown -\nGFAP - :\nblack -\nred +\nmidnightblue +\nyellow -\ntan -\nsalmon +\ngreen -\nLAMP5_PMEPA1:\nred -\nmidnightblue -\npink +\nblue -\nyellow +\nlightgreen +\ngreen +\nMicro:\nred -\ngreenyellow +\npink +\npurple +\nbrown -\ngreen -\nOligo:\ngreen - black + grey60 + purple - brown + royalblue -\nRORB_ADGRL4:\nmediumpurple3 + lightyellow - salmon - darkolivegreen + midnightblue - plum1 + skyblue3 + magenta + orangered4 + violet + lightgreen + steelblue + orange +\nRORB_FOXO1:\ndarkorange - calcuim ion binding, camera-eye type development, dandrite\nRORB_LRRK1:\nblack - brown + green - red - grey60 - magenta +\nRORB_POU3F2:\nyellow - green + pink + purple + red + brown -\nSMC:\nroyalblue - magenta + green + yellow - lightcyan - red - pink + greenyellow -\nSST_ BRINP3:\ngreenyellow + Unconventional myosin complex , liver development , non-motile cilium , multicellular organism-level iron homeostasis, response to copper iron, hippocampal mossy fiber to CA3 sinapse, regulation of leukocyte apoptotic process\nSST_NPY:\nroyalblue + postsynaptic dendrite membrane, axon extension involved in acon guidance, postsynaptic specialiaztion asembly, regulation of PH, adult behaviour,\nT Cell:\nlightgreen + red - magenta + salmon + white + grey60 - lightyellow + peptide receptor activity, chemical synaptic transmission, membrane lipod metabolic process, feeding behavious, collagen binding darkorange + green - brown + midnightblue - black + royalblue - darkgrey -\nTHEMIS_NR4A2:\ndarkgrey - elarning or memory, beta-tubulin binding, positive regulation of protein localization, positive egulation of synaptic vessicle fussing to presinaptic active zone membrane, postsynaptic density, orange + presynapse , neuronal cell body , postsynapse, positive regulation of neuro projection development, vacuole organization , golgi membrane, regulation of mRNA stability\nTLE4_MEGF11:\ncyan + regulation of skeletal muscle tissue development, olfacotry bulb development, regulation of mitochondrial gene expression , striated muccle cell filament, midnightblue + Sm-like protein family complex, negative regulation of osteoblast differenciation, O-methyltransferase activity, peptide metabolic process, neurotransmitter receptor activity\nVIP_CLSTN2:\nsalmon4 - cortical cytosckeleton organization, coated vessicle membrane, andosomal transport, external encapsulating structure, regulation of cell sunction assembly\n\n\nRimmod\nArterial:\ntan + brown + green - grey + turquoise - blue +\nCapillary:\ngreenyellow + cyan +\nlightyellow + brown + green - red - blue - grey + turquoise + darkgreen - black +\nCDH4_SCHN:\nturquoise + white + grey60 + darkgreen + orange + blue + cyan + magenta - skyblue - darkred + tan + violet + purple + darkturquoise + red - lightcyan - greenyellow + darkorange - paleturquoise - lightyellow - darkgrey - darkolivegreen - lightgreen -\nCLMP_KCNMA1:\ngrey + darkorange2 + steelblue + grey60 + turquoise + navajowhite2 + darkturquoise + white + green + yellow + plum1 + lightsteelblue1 + royalblue + purple + black + tan + maroon + lightyellow + pink + brown + yellowgreen + paleturquoise + palevioletred3 + darkgrey - thistle2 + salmon4 + saddlebrown + sienna3 + skyblue3 + thistle1 + darkred + darkolivegreen + ivory + salmon + mediumpurple3 +\nCLMP_PDGFRA:\nturquoise + grey + blue + red + yellow + black + brown +\nCUX2 RASGRF2:\npurple + blue + red - lightcyan + grey + black - turquoise -\nDISC1_CCK:\nwhite - cyan - darkgreen -\nGFAP - :\ngreenyellow + blue + red - cyan + grey + turquoise - black -\nGFAP + :\nmagenta + purple + grey + turquoise + black -\nLAMP5_PMEPA1:\ngreenyellow + green + lightyellow + yellow - lightgreen + grey + grey60 + blue - turquoise + magenta -\nMicro:\nmagenta + yellow + black - pink - grey + lightcyan + brown + turquoise -\nOligo:\ncyan + tan + midnightblue + red + brown - grey + greenyellow - turquoise + blue - black +\nPVALB_MYBPC1:\nbrown -\nRORB_ADGRL4:\nyellow + greenyellow + lightgreen + darkolivegreen + turquoise + darkmagenta + brown - pink - black + darkgreen - lightcyan + saddlebrown +\nRORB_FOXO1:\nblack + cyan + palevioletred3 + yellowgreen + lightyellow + orange + darkolivegreen + purple + thistle1 + midnightblue + pink + lavenderblush3 + bisque4 - salmon4 + skyblue + mediumpurple3 - saddlebrown + lightcyan + paleturquoise + lightsteelblue1 + darkslateblue - darkgrey + blue - plum2 + skyblue3 + darkorange2 + turquoise + darkmagenta + honeydew1 -\nRORB_LRRK1:\npurple + blue + darkturquoise + yellow - salmon + greenyellow + pink - royalblue + darkred + turquoise + orange - grey + green - magenta +\nSCN4B_NEFH:\ngrey - salmon + red - brown -\nSMC:\ngreenyellow + brown + green - grey + purple - blue +\nSST_GALNT14:\nlightyellow +\nT Cell:\ngreenyellow + brown + tan + yellow - midnightblue + green + grey + turquoise -\nTLE4_CCBE1:\nmagenta + saddlebrown + black +\nTLE4_SEMA3D:\nlightcyan + purple + steelblue + paleturquoise + grey + darkred + cyan + midnightblue + greenyellow + darkgrey + salmon + darkmagenta + darkgreen + saddlebrown + red + lightyellow + darkorange + brown + brown4 + grey60 + yellow + green + white + black + turquoise + navajowhite2 + tan + lightgreen + darkturquoise + blue + floralwhite - royalblue + skyblue + yellowgreen + thistle1 + pink + plum2 + plum1 +\nVAT1L EYA4:\nlightsteelblue1 - blue - thistle2 -\nVIP_CLSTN2:\nmidnightblue + thistle2 + palevioletred3 + skyblue + yellowgreen + darkolivegreen + darkgreen + ivory + lightcoral + lightcyan + lavenderblush3 - honeydew1 + black + violet + salmon + brown + cyan + purple + maroon + skyblue3 + darkorange2 + grey + greenyellow + darkorange + darkgrey - grey60 + mediumpurple3 + tan + indianred4 + darkolivegreen4 + steelblue + darkseagreen4 + mediumorchid + floralwhite + orangered4 + darkmagenta + saddlebrown + skyblue2 + navajowhite2 + coral2 + sienna3 + yellow4 + mediumpurple2 +\nVIP_HTR2C:\nlightgreen -\n\n\nFTLD-TDP\nArterial:\ndarkolivegreen + meiotic cell cycle, digestive system development, male gamete generation , adenylate cyclase-activating G protein-coupled receptor signaling pathway, RNA nuclease activity red + fatty acid metabolic process, neurotreanmitter receptor activity, vacuolar acidification, positive regulation of intercellular estrogen receptor signaling pathway, androgen metabolic process, cellular defense response orange + detection of chmical stimulus involved in sensory perception , cytokine activitym cellular response to copper and iron, hormone metabolic process, cellullar defense response lightgreen + olfactory receptor activity, nuclear division, regulation of mitotic nuclear division , sterioid hydroxylase activity, cell fate specification tan + complement activation classical pathway, regulation of T cell extravasation, error-prone translesions synthesis, response to pain, regulation of B cell mediated immunity, mRNA modification. grey60 - proteoglycan metabolic process, hormone biosinthetic processm glomerular basement membrane development, neuromuscular suiaptic transmission. steelblue + detection of chemical stimulus involved in sensory perception , late endosome lumen, sensory perception of taste, axoneme, positive regulation of T cell proliferation , leucocyte mediated cytotoxicity blue + humoral immune response, cytokine activation , detection of chemical stimulus involved in sensory perception, hormone activiy, inflamatory response, response to bacterium , adaptative immune response yellow - presynapse, active monoatomic ion transmembrane transporter activity, synaptic signaling, regulation of postsynapse assembly\nCapillary:\nlightgreen - neuropeptide binding, spinal cord development, hyaluronic acid binding, regulation of smooth muscle cell migration, regulation of BPM signaling pathway\nCDH4_SCGN:\ndarkmagenta + positive regulation of protein-coding complex assembly, endoplasmatic reticulum lumen, sodium channel activity plum1 + intrinsic apoptitic signaing pathway, regulation of alternative mRNA splicing via spliceosome\nCLMP_PDGFRA:\ndarkgrey + protein tyrosine phosphate activity, protein serine/theroine kinnase binding, mithocondrial protein-contaiing complex\nCUX2_RASGRF2:\norange - detection of chemical stimulus involved in sensory eprception, hormone activity, extracellular matric etructural constituent, retinoid binding, feeding behaviour pink - regulation of muscle system process, cellullar response to peptide hormone stimulus, regulation of blood preassure, regulation of supramoleular fiber organization, regulation of postsynapse assembly, positive regulation of cell migration cyan + 5’-3’ exonuclease activity, lipid droplet formation , cell division , response to progesterone, negative regulation of gliogenesis, translation repression activity, transcription reglator inhibitor activity.\nGFAP - :\ndarkturquoise + olfactory receptor activity, neuropeptide signaling pathway, retinol metabolic process, deaminase activity, defense response to bacterium , immune receptor activity green - hormone activity, axternal encapsulating structure, G-protein-coupled peptide receptor activity, angiogenesis, detection of chemical stimulus involved in sensory perception , purple + immunoglobulin binding, endoplasmic reticulum-Golgi intermediate compartment membrane, positive regulation of imune response, androgen metabolic process, signal recognition particle binding, response to ATp,\nGFAP +:\ngrey - olfactory receptor activity, receptor ligand activity, killing of cells of another organism, external encapsulating structure, hummoral immune response, structural constituent of skin epidermis, hormone activiry, defense response o bacterium, inflamatory response, leukocyte migration involved in infammatory response red - CCR4-MOT core complex, cmall molecule catabolic process, regulation of potassium ion transmembrane transporter activity, quinone metabolic process, positive regulation by host of viral genome replication, darkturquoise + detection of chemical stimulus involved in sensory perception, icosanoid secretion , hormone metabolic process, regulation of blood pressure, response to bacterium, killing of cells of another organism lightyellow - GTPase regulator activity, mitochondrion-endoplasmatic reticulum membrane tethering, axon , microglia differenciation , regulation of postsynapse assembly, positive regulation of apoptotic process cyan + detection of chemical stimulus involved in sensory perception, signaling receptor regulator activity, serine-type endopeptidase activity, DNA-binding transcription activator activity RNApolymerase II specific, natural killer cell activation, monooxigenase activity, regulation of type II interferon production greenyellow + olgfactory receptor activity, negative regulation of transmission of nerve impulse, xenobiotic metabolic process, negative regulation of homeostasis, endopeptidase inhibitor activity, killing of cells of another organism lightcyan + olfactory receptor activity, sister chromatid segregation , cell fate specification , cornified envelope, hormone activity, cell maturation black + signaling receptor regulator activitym rsponse to bacterium , immune receptor activity, external side of plasma membrane , adaptative immune response, regulation of effector immune process, leukocyte activation , mononuclear cell migration , cegulatio nof inflammatory response grey60 + olfactory receptor activity, positive regulation of immune efector process, humoral immune response, peptidase inhibitor activity\nMicro:\nlightyellow + catalytic activity acting on RNA, mRNAmodification , subpallium development, miotic sister chromatid cohesion green - synaptic signaling, cell body, regulation of synaptic plasticity, negative regulation of cation transmembrane transport, spinal cord development, meuropeptide signaling pathway, dendritic shaft, tau protein binding magenta + estradiol 17-beta-dehidrogenase NADP+ activity postsynaptic neurotransmitter receptor activity, nuclear exosome RNAse complex brown + signaling receptor regulation activity, killing of cells of another organism, heparin binding, external encapsulating structure, cell-cell adhesion , cormone activity\nOPC:\npurple + amide metabolic process, insulin processing, methyl-cpg binding, positive regulation of cation channel activity\nRORB_POU3F2:\npink - angiogenesis, negative rgulation of fibroblast growth factor receptor signaling pathway, polysaccharide biosynthetic process, structural costituent of postsynaptic actin sytosckeleton, external encapsulating structure red + fattyaccid oxidation using acyl-CoA oxidase, gluttamate-gated calcuim ion channel activity, cellular response to unfolded protein, vacuolar acidification, mRNA cis-splicing via spliceosome. turquoise + hummoral immune response, killing of cells of another ogranism, immune effector process , response to bacterium , inflammatory response, positive regulation of immune response, mononuclear cell migration, leukocyte mediated immunity, immune receptor activity, regulation of immune response, regulation of mononulear cell proliferation magenta - celular response to hormone stimulus, regualtion of calcium-mediated stimulus , regulation of anatomical structure size, postsynapse , axon , synaptic signaling\nSMC:\nyellow + fattyacid beta-oxidation using acyl-CoA oxidase, DNA replication preinitiation complex, mRNA cis splicing via spliceosome, cillium movement involved in cell motillity, postsinaptic neurotreansmitter receptor activity green - hydrolase activity acting on glicosyl bonds, fat-soluble vitamin metabolic process, peptide receptor activity, signaling receptor regulator activity, neuropeptide signaling pathway, paleturquoise - ( no enriched terms)\nT Cell:\nturquoise + external encapsulating structure, receptor ligand activity, cell-cell adhesion via plasma-membrane adhesion molecules , detection of stimulus involved in sensory perception , alpha-amino acid metabolic process, peptide receptor activity, hummoral immune response, endoplasmatic reticulum lument, yellow + hormone byosinthetic process , intramolecular transferase activity, neurotransmitter receptor activity, dolichol-linked oligosaccharide syoisinthetic process, white + chromosome segregation , porphyrin-containing compound biosynthetic process, visual perception , centromere complex assembly, RNA methylation, negative regulation of mitotic nuclear division magenta - regulation of muscle system process, response to pain, inositol1-4 5 triphosphate 5-phosphatase activity, regulation of polysynapse assembly, RNA polymerase III complex, associative learning, postsynaptic vessicle membrane darkred - external encapsulating structure, lymph vessel development, megative regulation of keratinocyte differenciation,\n\n\nPottier\nArterial:\ntan + pink - green + yellow + salmon - cyan + red + brown -\nCapillary:\ngreenyellow - salmon + green - pink + grey + turquoise +\nCLMP_KCNMA1:\ngrey + lightcyan + green + magenta + yellow + midnightblue + red + purple + tan + black + brown + cyan +\nCLMP_PDGFRA:\ngrey + royalblue +\nDISC1_CKK:\nplum2 - violet + lightyellow - darkgrey - magenta + tan - palevioletred3 -\nGFAP - :\nmagenta - green + black + tan + yellow + cyan - purple + turquoise +\nGFAP + :\nturquoise + grey + purple + blue + pink + lightcyan + midnightblue + red + green + brown + magenta + tan + salmon + yellow + cyan + lightgreen + greenyellow + grey60 - black +\nLAMP5_CA3:\nmediumpurple3 - magenta - floralwhite - grey - darkorange - yellow -\nLAMP5_PMEPA1:\nviolet - turquoise - grey - darkred - darkgreen + yellow - darkorange - darkgrey - tan - paleturquoise - black - steelblue -\nOligo:\nmagenta - black + blue + greenyellow + cyan + red + salmon - yellow - midnightblue + purple + tan + brown - pink + grey - turquoise -\nPericyte:\nsteelblue -\nPVALB_CEMIP:\npurple + skyblue - grey - blue - turquoise +\nPVALB_MYBPC1:\nwhite - plum2 + maroon - darkturquoise - grey - grey60 - saddlebrown - magenta - thistle1 - darkgreen +\nSCN4B_NEFH:\nivory - mediumorchid - saddlebrown - blue - grey - lightcyan - black + mediumpurple3 - brown - pink - skyblue1 + maroon + darkturquoise - grey60 - violet - bisque4 + plum1 + plum2 - tan + turquoise - steelblue - lightyellow - coral1 -\nSMC:\ngreen - purple + yellow + black + brown + cyan + tan +\nSST_ADAMTS19:\nbrown4 - orangered4 - darkolivegreen - bisque4 -\nSST_BRINP3:\nfloralwhite -\nSST_GALNT14:\nlightyellow - darkolivegreen + floralwhite - plum1 + darkgrey + thistle2 +\nT_Cell:\nyellow - magenta + greenyellow + red + black + cyan + green - lightcyan + midnightblue + purple +\nTHEMIS_TMEM233:\npurple + blue + yellow + lightcyan1 - brown + cyan -\nTLE4_CCBE1:\nbisque4 + lightsteelblue1 -\nTLE4_MEGF11:\norangered4 - skyblue3 - tan - lightgreen + brown -\nTLE4_SEMA3D:\norange - thistle2 +"
  },
  {
    "objectID": "Methods/Cell_prop.html",
    "href": "Methods/Cell_prop.html",
    "title": "Cell propotion analysis",
    "section": "",
    "text": "Compare inferred cell-type proportions across diagnosis groups using multiple statistical tests and data transformations.\nTo assess alterations in inferred cell state proportions among FTLD cases and cognitively healthy controls, we performed non-parametric statistical comparisons using the Kruskal–Wallis test. Deconvolved cell state proportions were obtained from Bayesian modeling of bulk RNA-seq data, and all samples were included in the analysis.\nFor each cell state, we compared estimated proportions between disease groups (FTLD-C9 or FTLD-TDP) and healthy controls. Prior to statistical testing, all zero values were replaced with a small constant (1e−10) to avoid division-by-zero errors in downstream calculations. Group comparisons were limited to conditions with at least two observations per group to ensure statistical robustness.\nCell-wise comparisons were conducted using the Kruskal–Wallis rank-sum test, implemented in R. Tests were performed independently for each cell state, with disease groups compared separately against controls. In parallel, fold change and log2 fold change values were computed based on group-wise means, providing complementary effect size measures alongside statistical significance.\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/theta.state_original.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/FTLD/TDP/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n### FTLD TDP\n#### ArcSin\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/TDP/Arcsin_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/FTLD/TDP/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCode\n### FTLD C9\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/FTLD/c9/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n#### ArcSin\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/C9/Arcsin_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/FTLD/C9/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCode\n# pottier\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/NEW/theta.state_cellstate.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/NEW/\"\n\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"\\\\.\", \"_\", x))\ndata$FCX_ID &lt;- sapply(data$FCX_ID, function(x) gsub(\"-\", \"_\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"FCX_ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\nmerged_data &lt;- merged_data[merged_data$GROUP != \"FTLD-TDP-C\",]\nmerged_data$GROUP[merged_data$GROUP != \"Control\"]&lt;-\"FTLD\"\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$GROUP)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Control\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$GROUP %in% c(\"Control\", m_cond), \n                             c(\"GROUP\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$GROUP, levels = c(\"Control\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$GROUP == \"Control\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$GROUP == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$GROUP)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n#### ArcSin\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/Pottier/TDP/Log_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/Pottier/TDP/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file)\ndata$group.ID &lt;- data$GROUP\ndata$GROUP &lt;- NULL\ndata &lt;- data[!data$group.ID == \"FTLD-TDP-C\",]\ndata$group.ID[data$group.ID == \"Control\"] &lt;- \"Healthy\"\ndata$group.ID[!data$group.ID == \"Healthy\"] &lt;- \"TDP\"\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"\\\\.\", \"-\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"FCX_ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/RIMOD/theta.state_cellstate.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/Rimod/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"RimodID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$DiseaseCode)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"control\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$DiseaseCode %in% c(\"control\", m_cond), \n                             c(\"DiseaseCode\", column)]\n  \n  # Ensure DiseaseCode is treated as a factor\n  subset_data$DiseaseCode &lt;- factor(subset_data$DiseaseCode, levels = c(\"control\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$DiseaseCode == \"control\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$DiseaseCode == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$DiseaseCode)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n#### ArcSin\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/Rimod/C9/Arcsin_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../RiMod/Data/rimod_ftd_dataset_table_v3.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/Rimod/C9/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file, row.names = 1)\ndata$group.ID &lt;- data$DiseaseCode\ndata$DiseaseCode &lt;- NULL\ndata &lt;- data[!data$group.ID == \"FTD-GRN\",]\ndata &lt;- data[!data$group.ID == \"FTD-MAPT\",]\ndata$group.ID[data$group.ID == \"control\"] &lt;- \"Healthy\"\ndata$group.ID[data$group.ID == \"FTD-C9\"] &lt;- \"C9orf72\"\ndata$sample.ID &lt;- rownames(data)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCorrelate cell-type proportions (raw and transformed) with clinical and pathological variables for FTLD cohorts.\nTo assess the relationship between cellular composition and neuropathological severity, we performed Spearman correlation analyses between BayesPrism-inferred cell state proportions and neuropathological or molecular covariates derived from frontal cortex tissue from individuals with C9orf72 repeat expansion-associated FTLD (FTLD-C9). Specifically, cell state proportions from the BayesPrism deconvolution were correlated with quantitative pathology scores and molecular readouts of ACSL3, lncRNA, polyGA, polyGR, fociSENSE, fociANTI, pTDP43 and STMN2 across individuals using raw values and transformations to asses non linear correlations (log , log2, logit and arcsin) on both cell proportion and pathology values. Correlation coefficients and p-values were computed using the cor.test function.\nIn a complementary analysis, for each cell state, Spearman correlations were computed independently for each gene with each of the pathology markers indicated. These results provided information about the differences in the impact of these covariables among cell groups for disease-associated shifts in expression and suggested potential pathophysiological relevance for specific gene expression changes.\nFinally, we evaluated the association between transcriptional co-expression modules and the described pathology markers. Module eigengenes (MEs) from each cell state-specific co-expression network were correlated with the corresponding pathology density using Spearman correlation. Modules were ranked by p-value and correlation strength to identify modules whose expression was most strongly associated with neuropathological burden. These correlations were calculated separately for each cell state, and significant modules were retained for downstream interpretation and enrichment analysis.\nFor the TDP43 samples the same analysis was performed using only pTDP43 and STMN2 pathology markers.\n\n\nCode\nlibrary(\"Seurat\")\nlibrary(\"dplyr\")\nlibrary(\"RColorBrewer\")\nlibrary(\"unikn\")\nlibrary(\"cluster\")\nlibrary(\"tidyverse\")\nlibrary(\"readxl\")  # Asegurar que readxl está cargado\n\n# Load Metadata\nmetadata &lt;- read_xlsx(\".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\ncolnames(metadata)[1] &lt;- \"X\"\nsamples &lt;- metadata$X[metadata$group.ID == \"C9orf72\"]\nmetadata &lt;- metadata[metadata$group.ID == \"C9orf72\",]\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nCRscores$X &lt;- gsub(pattern = \"X\", replacement = \"\", x = CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), CRscores$X)\nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% filter(X %in% common_samples) %&gt;% column_to_rownames(\"X\")\n\nif (nrow(proportions_data) &gt; 2 && nrow(covariables) &gt; 2) {\n  \n  results &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                         Covariate = colnames(covariables), \n                         stringsAsFactors = FALSE)\n  \n  compute_spearman &lt;- function(cell_state, covariate) {\n    test_result &lt;- cor.test(proportions_data[, cell_state], covariables[, covariate], \n                            method = \"spearman\", exact = TRUE)\n    return(c(test_result$estimate, test_result$p.value))\n  }\n  \n  cor_pvals &lt;- mapply(compute_spearman, results$Cell_State, results$Covariate)\n  \n  results$Spearman_Correlation &lt;- cor_pvals[1, ]\n  results$p_value &lt;- cor_pvals[2, ]\n}\n\nwrite.csv(results, \".../BAYESPRISM_12_3/CORRELATION/C9_spearman_results_true.csv\", row.names = FALSE)\n\n\n# ARCSIN\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv\", row.names = \"X\")\nrownames(CRscores) &lt;- gsub(pattern = \"X\", replacement = \"\", x = rownames(CRscores))\nCRscores &lt;- CRscores[rownames(CRscores) %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/C9/Arcsin_Cell_state_proportions.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), rownames(CRscores))\nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% dplyr::filter(rownames(CRscores) %in% common_samples) \nif (nrow(proportions_data) &gt; 2 && nrow(covariables) &gt; 2) {\n  \n  results &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                         Covariate = colnames(covariables), \n                         stringsAsFactors = FALSE)\n  \n  compute_spearman &lt;- function(cell_state, covariate) {\n    test_result &lt;- cor.test(proportions_data[, cell_state], covariables[, covariate], \n                            method = \"spearman\", exact = TRUE) \n    return(c(test_result$estimate, test_result$p.value))\n  }\n  \n  cor_pvals &lt;- apply(results, 1, function(row) {\n    compute_spearman(row[\"Cell_State\"], row[\"Covariate\"])\n  })\n  \n  results$Spearman_Correlation &lt;- cor_pvals[1, ]\n  results$p_value &lt;- cor_pvals[2, ]\n}\n\nwrite.csv(results, paste0(outdir, \"ArcSin_C9_spearman_results.csv\"), row.names = FALSE)\n\n\n\n\nCode\nlibrary(\"Seurat\")\nlibrary(\"dplyr\")\nlibrary(\"RColorBrewer\")\nlibrary(\"unikn\")\nlibrary(\"cluster\")\nlibrary(\"tidyverse\")\nlibrary(\"readxl\")  # Asegurar que readxl está cargado\n\n# Load Metadata\nmetadata &lt;- read_xlsx(\".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\ncolnames(metadata)[1] &lt;- \"X\"\nsamples &lt;- metadata$X[metadata$group.ID == \"TDP\"]\nmetadata &lt;- metadata[metadata$group.ID == \"TDP\",]\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\nCRscores$X &lt;- gsub(pattern = \"long\", replacement = \"\", x = CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/theta.state_original.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), CRscores$X)\ncommon_samples &lt;- setdiff(common_samples, \"7BLACK\")  # Remove outlier \nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% dplyr::filter(X %in% common_samples) %&gt;% column_to_rownames(\"X\")\n\nif (nrow(proportions_data) &gt; 2 && nrow(covariables) &gt; 2) {\n  \n  results &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                         Covariate = colnames(covariables), \n                         stringsAsFactors = FALSE)\n  \n  compute_spearman &lt;- function(cell_state, covariate) {\n    test_result &lt;- cor.test(proportions_data[, cell_state], covariables[, covariate], \n                            method = \"spearman\", exact = TRUE) # TRUE \n    return(c(test_result$estimate, test_result$p.value))\n  }\n  \n  cor_pvals &lt;- mapply(compute_spearman, results$Cell_State, results$Covariate)\n  \n  results$Spearman_Correlation &lt;- cor_pvals[1, ]\n  results$p_value &lt;- cor_pvals[2, ]\n}\n\nwrite.csv(results, \".../BAYESPRISM_12_3/CORRELATION/TDP_spearman_results_true_no_out.csv\", row.names = FALSE)\n\n\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM\")\nCRscores$X &lt;- gsub(pattern = \"long\", replacement = \"\", x = CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/TDP/Arcsin_Cell_state_proportions.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), CRscores$X)\nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% dplyr::filter(X %in% common_samples) %&gt;% column_to_rownames(\"X\")\n\n# ULL AMB AQUEST CANVI DE VALOR\ny &lt;- covariables[, \"STMN2\"]\ny[is.infinite(y)] &lt;- min(y[is.finite(y)]) - 1e-2\ncovariables[, \"STMN2\"] &lt;- y\n\n# Separate STMN2 to remove outlier\ncov_stmn2 &lt;- covariables[rownames(covariables) != \"7BLACK\", \"STMN2\", drop = FALSE]\nproportions_data_STMN2 &lt;- proportions_data[rownames(proportions_data) != \"7BLACK\", ]\n\ncov_tdp43b &lt;- covariables[, \"TDP43b\", drop = FALSE]\n\n# Results dataframe \nresults &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                       Covariate = colnames(covariables), \n                       stringsAsFactors = FALSE)\n\n# --- Correlations with TDP43b ---\nres_tdp43b &lt;- do.call(rbind, lapply(colnames(proportions_data), function(cs) {\n  compute_spearman(cs, \"TDP43b\", proportions_data, cov_tdp43b)\n}))\n\n# --- Correlations with STMN2 (without outlier) ---\nres_stmn2 &lt;- do.call(rbind, lapply(colnames(proportions_data_STMN2), function(cs) {\n  compute_spearman(cs, \"STMN2\", proportions_data_STMN2, cov_stmn2)\n}))\n\n# Combine results\nresults &lt;- rbind(res_tdp43b, res_stmn2)\n\nwrite.csv(results, paste0(outdir, \"ArcSin_TDP_spearman_results.csv\"), row.names = FALSE)"
  },
  {
    "objectID": "Methods/Cell_prop.html#differences",
    "href": "Methods/Cell_prop.html#differences",
    "title": "Cell propotion analysis",
    "section": "",
    "text": "Compare inferred cell-type proportions across diagnosis groups using multiple statistical tests and data transformations.\nTo assess alterations in inferred cell state proportions among FTLD cases and cognitively healthy controls, we performed non-parametric statistical comparisons using the Kruskal–Wallis test. Deconvolved cell state proportions were obtained from Bayesian modeling of bulk RNA-seq data, and all samples were included in the analysis.\nFor each cell state, we compared estimated proportions between disease groups (FTLD-C9 or FTLD-TDP) and healthy controls. Prior to statistical testing, all zero values were replaced with a small constant (1e−10) to avoid division-by-zero errors in downstream calculations. Group comparisons were limited to conditions with at least two observations per group to ensure statistical robustness.\nCell-wise comparisons were conducted using the Kruskal–Wallis rank-sum test, implemented in R. Tests were performed independently for each cell state, with disease groups compared separately against controls. In parallel, fold change and log2 fold change values were computed based on group-wise means, providing complementary effect size measures alongside statistical significance.\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/theta.state_original.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/FTLD/TDP/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n### FTLD TDP\n#### ArcSin\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/TDP/Arcsin_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/FTLD/TDP/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCode\n### FTLD C9\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/FTLD/c9/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n#### ArcSin\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/C9/Arcsin_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/FTLD/C9/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.xlsx(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCode\n# pottier\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/NEW/theta.state_cellstate.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/NEW/\"\n\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"\\\\.\", \"_\", x))\ndata$FCX_ID &lt;- sapply(data$FCX_ID, function(x) gsub(\"-\", \"_\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"FCX_ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\nmerged_data &lt;- merged_data[merged_data$GROUP != \"FTLD-TDP-C\",]\nmerged_data$GROUP[merged_data$GROUP != \"Control\"]&lt;-\"FTLD\"\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$GROUP)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Control\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$GROUP %in% c(\"Control\", m_cond), \n                             c(\"GROUP\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$GROUP, levels = c(\"Control\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$GROUP == \"Control\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$GROUP == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$GROUP)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n#### ArcSin\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/Pottier/TDP/Log_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/Pottier/TDP/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file)\ndata$group.ID &lt;- data$GROUP\ndata$GROUP &lt;- NULL\ndata &lt;- data[!data$group.ID == \"FTLD-TDP-C\",]\ndata$group.ID[data$group.ID == \"Control\"] &lt;- \"Healthy\"\ndata$group.ID[!data$group.ID == \"Healthy\"] &lt;- \"TDP\"\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"\\\\.\", \"-\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"FCX_ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCode\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/RIMOD/theta.state_cellstate.csv\"\nmetadata_file &lt;- \".../BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/Rimod/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"RimodID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$DiseaseCode)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"control\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$DiseaseCode %in% c(\"control\", m_cond), \n                             c(\"DiseaseCode\", column)]\n  \n  # Ensure DiseaseCode is treated as a factor\n  subset_data$DiseaseCode &lt;- factor(subset_data$DiseaseCode, levels = c(\"control\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$DiseaseCode == \"control\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$DiseaseCode == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$DiseaseCode)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n#### ArcSin\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")  \n\n# FILE PATHS\nfrequency_file &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/Rimod/C9/Arcsin_Cell_state_proportions.csv\"\nmetadata_file &lt;- \".../RiMod/Data/rimod_ftd_dataset_table_v3.txt\"\noutput_path &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMED_RESULTS/Rimod/C9/ArcSin/\"\n\nif (!file.exists(output_path)) {\n  dir.create(output_path, recursive = TRUE)\n}\nif (!file.exists(file.path(output_path,\"Significative\"))) {\n  dir.create(file.path(output_path,\"Significative\"), recursive = TRUE)\n}\n\ndata &lt;- read.delim(metadata_file, row.names = 1)\ndata$group.ID &lt;- data$DiseaseCode\ndata$DiseaseCode &lt;- NULL\ndata &lt;- data[!data$group.ID == \"FTD-GRN\",]\ndata &lt;- data[!data$group.ID == \"FTD-MAPT\",]\ndata$group.ID[data$group.ID == \"control\"] &lt;- \"Healthy\"\ndata$group.ID[data$group.ID == \"FTD-C9\"] &lt;- \"C9orf72\"\ndata$sample.ID &lt;- rownames(data)\n\nfreq_cell_types &lt;- read.csv(frequency_file)\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"long\", \"\", x))\nfreq_cell_types$X &lt;- sapply(freq_cell_types$X, function(x) gsub(\"X\", \"\", x))\n\nmerged_data &lt;- merge(data, freq_cell_types, by.x = \"sample.ID\", by.y = \"X\")\nmerged_data[merged_data == 0] &lt;- 1e-10\n\n# Generate needed objects\n\nm_conditions &lt;- unique(merged_data$group.ID)\nm_conditions_nh &lt;- m_conditions[m_conditions != \"Healthy\"]\nfiles_to_iterate &lt;- colnames(merged_data)[4:length(colnames(merged_data))]\nm_cond &lt;- m_conditions_nh[1]\ncounter = 0\n\nsignificatives &lt;- data.frame(matrix(nrow = length(files_to_iterate), ncol = 3))\ncolnames(significatives)&lt;- c(\"cell\", \"group+sv\", \"group\")\n\n\nfor (column in colnames(freq_cell_types)[2:length(colnames(freq_cell_types))]){\n  counter &lt;- counter + 1\n  filename &lt;- paste0(\"Kruskal_\", column, \"_\", m_cond, \".txt\")\n  \n  subset_data &lt;- merged_data[merged_data$group.ID %in% c(\"Healthy\", m_cond), \n                             c(\"group.ID\", column)]\n  \n  # Ensure group.ID is treated as a factor\n  subset_data$group.ID &lt;- factor(subset_data$group.ID, levels = c(\"Healthy\", m_cond))\n  \n  # Calculate group means\n  mean_healthy &lt;- mean(subset_data[[column]][subset_data$group.ID == \"Healthy\"], na.rm = TRUE)\n  mean_condition &lt;- mean(subset_data[[column]][subset_data$group.ID == m_cond], na.rm = TRUE)\n  \n  # Calculate fold change\n  fold_change &lt;- ifelse(mean_healthy == 0, NA, mean_condition / mean_healthy)  # Avoid division by zero\n  \n  # Log-transform the fold change (optional)\n  log2_fold_change &lt;- ifelse(is.na(fold_change), NA, log2(fold_change))\n  \n  # Check if both groups (Healthy and m_cond) have at least 2 observations\n  save = TRUE\n  tryCatch({\n    if (save == TRUE){sink(paste0(output_path, filename))}\n    \n    print(filename)\n    \n    # Model A: Kruskal-Wallis Test (without covariates)\n    kruskal_A &lt;- kruskal.test(subset_data[[column]], subset_data$group.ID)\n    print(\"Kruskal-Wallis Test (General model)\")\n    print(kruskal_A)\n    if (save == TRUE){sink()}\n    \n  }, error = function(e) {\n    message(\"Error in processing column \", column, \": \", e$message)\n    next\n  })\n  \n  # Store the p-values, fold change, and means in the significatives data frame\n  significatives[counter, 1] &lt;- column\n  significatives[counter, 3] &lt;- kruskal_A$p.value  # Group (from Kruskal-Wallis test)\n  significatives[counter, 4] &lt;- fold_change  # Fold change\n  significatives[counter, 5] &lt;- log2_fold_change  # Log2 fold change\n  significatives[counter, 6] &lt;- mean_healthy  # Mean of the Healthy group\n  significatives[counter, 7] &lt;- mean_condition  # Mean of the specific condition group\n}\n\n# Update column names of the significatives data frame\ncolnames(significatives) &lt;- c(\"cell\", \"group+sv\", \"group\", \"fold_change\", \n                              \"log2_fold_change\", \"mean_healthy\", \"mean_condition\")\n\n# Save the significatives data frame as a TSV file\ntsv_output_path &lt;- file.path(output_path, \"significatives_nonparametric_with_means_cs.tsv\")\nwrite.table(significatives, \n            file = tsv_output_path, \n            sep = \"\\t\",          \n            row.names = FALSE,   \n            col.names = TRUE,    \n            quote = FALSE)\n\n\n\n\nCorrelate cell-type proportions (raw and transformed) with clinical and pathological variables for FTLD cohorts.\nTo assess the relationship between cellular composition and neuropathological severity, we performed Spearman correlation analyses between BayesPrism-inferred cell state proportions and neuropathological or molecular covariates derived from frontal cortex tissue from individuals with C9orf72 repeat expansion-associated FTLD (FTLD-C9). Specifically, cell state proportions from the BayesPrism deconvolution were correlated with quantitative pathology scores and molecular readouts of ACSL3, lncRNA, polyGA, polyGR, fociSENSE, fociANTI, pTDP43 and STMN2 across individuals using raw values and transformations to asses non linear correlations (log , log2, logit and arcsin) on both cell proportion and pathology values. Correlation coefficients and p-values were computed using the cor.test function.\nIn a complementary analysis, for each cell state, Spearman correlations were computed independently for each gene with each of the pathology markers indicated. These results provided information about the differences in the impact of these covariables among cell groups for disease-associated shifts in expression and suggested potential pathophysiological relevance for specific gene expression changes.\nFinally, we evaluated the association between transcriptional co-expression modules and the described pathology markers. Module eigengenes (MEs) from each cell state-specific co-expression network were correlated with the corresponding pathology density using Spearman correlation. Modules were ranked by p-value and correlation strength to identify modules whose expression was most strongly associated with neuropathological burden. These correlations were calculated separately for each cell state, and significant modules were retained for downstream interpretation and enrichment analysis.\nFor the TDP43 samples the same analysis was performed using only pTDP43 and STMN2 pathology markers.\n\n\nCode\nlibrary(\"Seurat\")\nlibrary(\"dplyr\")\nlibrary(\"RColorBrewer\")\nlibrary(\"unikn\")\nlibrary(\"cluster\")\nlibrary(\"tidyverse\")\nlibrary(\"readxl\")  # Asegurar que readxl está cargado\n\n# Load Metadata\nmetadata &lt;- read_xlsx(\".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\ncolnames(metadata)[1] &lt;- \"X\"\nsamples &lt;- metadata$X[metadata$group.ID == \"C9orf72\"]\nmetadata &lt;- metadata[metadata$group.ID == \"C9orf72\",]\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nCRscores$X &lt;- gsub(pattern = \"X\", replacement = \"\", x = CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), CRscores$X)\nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% filter(X %in% common_samples) %&gt;% column_to_rownames(\"X\")\n\nif (nrow(proportions_data) &gt; 2 && nrow(covariables) &gt; 2) {\n  \n  results &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                         Covariate = colnames(covariables), \n                         stringsAsFactors = FALSE)\n  \n  compute_spearman &lt;- function(cell_state, covariate) {\n    test_result &lt;- cor.test(proportions_data[, cell_state], covariables[, covariate], \n                            method = \"spearman\", exact = TRUE)\n    return(c(test_result$estimate, test_result$p.value))\n  }\n  \n  cor_pvals &lt;- mapply(compute_spearman, results$Cell_State, results$Covariate)\n  \n  results$Spearman_Correlation &lt;- cor_pvals[1, ]\n  results$p_value &lt;- cor_pvals[2, ]\n}\n\nwrite.csv(results, \".../BAYESPRISM_12_3/CORRELATION/C9_spearman_results_true.csv\", row.names = FALSE)\n\n\n# ARCSIN\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv\", row.names = \"X\")\nrownames(CRscores) &lt;- gsub(pattern = \"X\", replacement = \"\", x = rownames(CRscores))\nCRscores &lt;- CRscores[rownames(CRscores) %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/C9/Arcsin_Cell_state_proportions.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), rownames(CRscores))\nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% dplyr::filter(rownames(CRscores) %in% common_samples) \nif (nrow(proportions_data) &gt; 2 && nrow(covariables) &gt; 2) {\n  \n  results &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                         Covariate = colnames(covariables), \n                         stringsAsFactors = FALSE)\n  \n  compute_spearman &lt;- function(cell_state, covariate) {\n    test_result &lt;- cor.test(proportions_data[, cell_state], covariables[, covariate], \n                            method = \"spearman\", exact = TRUE) \n    return(c(test_result$estimate, test_result$p.value))\n  }\n  \n  cor_pvals &lt;- apply(results, 1, function(row) {\n    compute_spearman(row[\"Cell_State\"], row[\"Covariate\"])\n  })\n  \n  results$Spearman_Correlation &lt;- cor_pvals[1, ]\n  results$p_value &lt;- cor_pvals[2, ]\n}\n\nwrite.csv(results, paste0(outdir, \"ArcSin_C9_spearman_results.csv\"), row.names = FALSE)\n\n\n\n\nCode\nlibrary(\"Seurat\")\nlibrary(\"dplyr\")\nlibrary(\"RColorBrewer\")\nlibrary(\"unikn\")\nlibrary(\"cluster\")\nlibrary(\"tidyverse\")\nlibrary(\"readxl\")  # Asegurar que readxl está cargado\n\n# Load Metadata\nmetadata &lt;- read_xlsx(\".../BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\ncolnames(metadata)[1] &lt;- \"X\"\nsamples &lt;- metadata$X[metadata$group.ID == \"TDP\"]\nmetadata &lt;- metadata[metadata$group.ID == \"TDP\",]\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\nCRscores$X &lt;- gsub(pattern = \"long\", replacement = \"\", x = CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/theta.state_original.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), CRscores$X)\ncommon_samples &lt;- setdiff(common_samples, \"7BLACK\")  # Remove outlier \nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% dplyr::filter(X %in% common_samples) %&gt;% column_to_rownames(\"X\")\n\nif (nrow(proportions_data) &gt; 2 && nrow(covariables) &gt; 2) {\n  \n  results &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                         Covariate = colnames(covariables), \n                         stringsAsFactors = FALSE)\n  \n  compute_spearman &lt;- function(cell_state, covariate) {\n    test_result &lt;- cor.test(proportions_data[, cell_state], covariables[, covariate], \n                            method = \"spearman\", exact = TRUE) # TRUE \n    return(c(test_result$estimate, test_result$p.value))\n  }\n  \n  cor_pvals &lt;- mapply(compute_spearman, results$Cell_State, results$Covariate)\n  \n  results$Spearman_Correlation &lt;- cor_pvals[1, ]\n  results$p_value &lt;- cor_pvals[2, ]\n}\n\nwrite.csv(results, \".../BAYESPRISM_12_3/CORRELATION/TDP_spearman_results_true_no_out.csv\", row.names = FALSE)\n\n\n\nCRscores &lt;- read.csv(\".../BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM\")\nCRscores$X &lt;- gsub(pattern = \"long\", replacement = \"\", x = CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples,]\n\nproportions_directory &lt;- \".../BAYESPRISM_12_3/CELL_PROP/TRANSFORMATED_PROPORTIONS/ArcSin/FTLD/TDP/Arcsin_Cell_state_proportions.csv\"\nproportions_data &lt;- read.csv(proportions_directory, row.names = 1)\nrownames(proportions_data) &lt;- gsub(\"^X\", \"\", rownames(proportions_data))\n\ncommon_samples &lt;- intersect(rownames(proportions_data), CRscores$X)\nproportions_data &lt;- proportions_data[common_samples, , drop = FALSE]\ncovariables &lt;- CRscores %&gt;% dplyr::filter(X %in% common_samples) %&gt;% column_to_rownames(\"X\")\n\n# ULL AMB AQUEST CANVI DE VALOR\ny &lt;- covariables[, \"STMN2\"]\ny[is.infinite(y)] &lt;- min(y[is.finite(y)]) - 1e-2\ncovariables[, \"STMN2\"] &lt;- y\n\n# Separate STMN2 to remove outlier\ncov_stmn2 &lt;- covariables[rownames(covariables) != \"7BLACK\", \"STMN2\", drop = FALSE]\nproportions_data_STMN2 &lt;- proportions_data[rownames(proportions_data) != \"7BLACK\", ]\n\ncov_tdp43b &lt;- covariables[, \"TDP43b\", drop = FALSE]\n\n# Results dataframe \nresults &lt;- expand.grid(Cell_State = colnames(proportions_data), \n                       Covariate = colnames(covariables), \n                       stringsAsFactors = FALSE)\n\n# --- Correlations with TDP43b ---\nres_tdp43b &lt;- do.call(rbind, lapply(colnames(proportions_data), function(cs) {\n  compute_spearman(cs, \"TDP43b\", proportions_data, cov_tdp43b)\n}))\n\n# --- Correlations with STMN2 (without outlier) ---\nres_stmn2 &lt;- do.call(rbind, lapply(colnames(proportions_data_STMN2), function(cs) {\n  compute_spearman(cs, \"STMN2\", proportions_data_STMN2, cov_stmn2)\n}))\n\n# Combine results\nresults &lt;- rbind(res_tdp43b, res_stmn2)\n\nwrite.csv(results, paste0(outdir, \"ArcSin_TDP_spearman_results.csv\"), row.names = FALSE)"
  },
  {
    "objectID": "Results/Cell_composition.html",
    "href": "Results/Cell_composition.html",
    "title": "Differences in cell composition",
    "section": "",
    "text": "Analysis revealed significant shifts in arcsin transformed cell type proportions between healthy controls and FTLD-C9 cases, reflecting disease-associated alterations in cortical cellular composition. VAT1L/EYA4 (p = 0.013, FC= 0.066) and GFAP + (p = 0.026, FC= 202,85) cells displayed a striking increase in FTLD-C9 indicative of astrocytic activation. T Cell (p = 0.033, FC= 1.24) proportion is also found increased. Additional significative proportion decreases were observed in PVALB/MYBPC1(p = 0.009, FC= 1.49), and RORB/POU3F2 (p = 0.042, FC= 0.87) populations (Fig.1). Overall, there was an enrichment of cell types associated with immune responses and inflammation, whereas neuronal populations were generally reduced in FTLD-C9.\n\n\n\n\nCode\nlibrary(openxlsx)\nlibrary(dplyr)\nlibrary(DT)\nlibrary(janitor)\n\n# Load sheets\nsheets &lt;- openxlsx::getSheetNames(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\")\n\ndata &lt;- xlsx::read.xlsx(\n  \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\",\n  sheetName = sheets[1]\n)\n\ndata2 &lt;- xlsx::read.xlsx(\n  \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\",\n  sheetName = sheets[12]\n)\n\n# ───────────────────────────────────────────────\n# 1. Remove group.sv\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% select(-group.sv)\n\n# ───────────────────────────────────────────────\n# 2. Replace \"group\" using data2$group matched by \"cell\"\n# ───────────────────────────────────────────────\n\ndata &lt;- data %&gt;%\n  left_join(\n    data2 %&gt;% select(cell, group) %&gt;% rename(new_group = group),\n    by = \"cell\"\n  ) %&gt;%\n  mutate(group = new_group) %&gt;%\n  select(-new_group)\n\n# ───────────────────────────────────────────────\n# 3. Rename \"group\" to \"p.value\"\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% rename(p.value = group)\n\n# Clean column names (HTML safe)\ndata &lt;- data %&gt;% clean_names()\n\n# ───────────────────────────────────────────────\n# 4. Output for HTML Quarto\n# ───────────────────────────────────────────────\ndatatable(\n  data,\n  options = list(\n    pageLength = 25,\n    scrollX = TRUE,\n    autoWidth = TRUE,\n    searchHighlight = TRUE\n  ),\n  class = \"display compact\",\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\n# ---- Libraries ----\n\nlibrary(tidyverse)\nlibrary(openxlsx)\nlibrary(plotly)\n\n# ---- File paths ----\nfrequency_file &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\"\nmetadata_file  &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path    &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CELL_PROP/FTLD/c9/\"\n\nif (!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)\nif (!dir.exists(file.path(output_path, \"Significative\"))) dir.create(file.path(output_path, \"Significative\"))\n\n# ---- Load data ----\nmeta &lt;- openxlsx::read.xlsx(metadata_file, sheet = 1)\nfreq &lt;- read.csv(frequency_file)\n\n# ---- Harmonize IDs ----\nfreq$X &lt;- gsub(\"long\", \"\", freq$X)\nfreq$X &lt;- gsub(\"^X\", \"\", freq$X)\nmeta$sample.ID &lt;- gsub(\"-\", \"_\", meta$sample.ID)\n\n# ---- Merge ----\nmerged &lt;- merge(meta, freq, by.x = \"sample.ID\", by.y = \"X\")\nmerged[merged == 0] &lt;- NA\n\n# ---- Define groups ----\nmerged &lt;- merged[merged$group.ID %in% c(\"Healthy\", \"C9orf72\"), ]\nmerged$GROUP &lt;- factor(ifelse(merged$group.ID == \"Healthy\", \"Control\", \"FTLD\"),\n                       levels = c(\"Control\", \"FTLD\"))\n\n# ---- Extract cell states ----\ncell_states &lt;- colnames(freq)[-1]\n\n# ---- Transform proportions (arcsin sqrt) ----\nmerged_arcsin &lt;- merged\nmerged_arcsin[cell_states] &lt;- asin(sqrt(merged[cell_states]))\n\n# ---- Robust Kruskal–Wallis loop ----\nsignif_list &lt;- lapply(cell_states, function(cs) {\n  subd &lt;- merged_arcsin %&gt;% select(GROUP, all_of(cs))\n  # Ensure both groups have enough samples\n  if (any(table(subd$GROUP) &lt; 2, na.rm = TRUE)) return(NULL)\n  \n  kw &lt;- tryCatch(kruskal.test(subd[[cs]] ~ subd$GROUP), error = function(e) NULL)\n  if (is.null(kw)) return(NULL)\n  \n  pval &lt;- kw$p.value\n  mean_ctrl &lt;- mean(merged[[cs]][merged$GROUP == \"Control\"], na.rm = TRUE)\n  mean_ftld &lt;- mean(merged[[cs]][merged$GROUP == \"FTLD\"], na.rm = TRUE)\n  fc &lt;- ifelse(mean_ctrl == 0, NA, mean_ftld / mean_ctrl)\n  log2fc &lt;- log2(fc)\n  \n  data.frame(\n    cell = cs,\n    p = pval,\n    mean_ctrl = mean_ctrl,\n    mean_ftld = mean_ftld,\n    fold_change = fc,\n    log2FC = log2fc,\n    stringsAsFactors = FALSE\n  )\n})\n\n# ---- Bind cleanly into one table ----\nsignif_tbl &lt;- bind_rows(signif_list)   # use bind_rows instead of rbind for safety\n\n# ---- Multiple testing correction ----\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE ~ \"ns\"\n    )\n  )\n\n# ---- Convert p to numeric safely ----\nsignif_tbl$p &lt;- as.numeric(unlist(signif_tbl$p))\nsignif_tbl$mean_ctrl &lt;- as.numeric(unlist(signif_tbl$mean_ctrl))\nsignif_tbl$mean_ftld &lt;- as.numeric(unlist(signif_tbl$mean_ftld))\nsignif_tbl$fold_change &lt;- as.numeric(unlist(signif_tbl$fold_change))\nsignif_tbl$log2FC &lt;- as.numeric(unlist(signif_tbl$log2FC))\n\n# ---- Multiple testing correction ----\nlibrary(dplyr)\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE ~ \"ns\"\n    )\n  )\n# ---- Interactive boxplot (fixed) ----\nall_traces &lt;- list()\nfor (i in seq_along(cell_states)) {\n  cs &lt;- cell_states[i]\n  df &lt;- merged %&gt;%\n    select(GROUP, all_of(cs)) %&gt;%\n    rename(Proportion = all_of(cs)) %&gt;%\n    filter(!is.na(Proportion))        # remove NA rows before plotting\n  \n  # make sure both groups are present\n  missing_groups &lt;- setdiff(levels(merged$GROUP), unique(df$GROUP))\n  if (length(missing_groups) &gt; 0) {\n    for (mg in missing_groups) {\n      df &lt;- rbind(df, data.frame(GROUP = mg, Proportion = NA))\n    }\n  }\n\n  pval &lt;- signif_tbl$p[signif_tbl$cell == cs]\n  fdr  &lt;- signif_tbl$FDR[signif_tbl$cell == cs]\n  signif_label &lt;- signif_tbl$signif[signif_tbl$cell == cs]\n\n  # Create one trace per group (Control, FTLD)\n  for (grp in levels(merged$GROUP)) {\n    grp_data &lt;- df %&gt;% filter(GROUP == grp)\n    tr &lt;- list(\n      type = \"box\",\n      x = rep(grp, nrow(grp_data)),\n      y = grp_data$Proportion,\n      name = grp,\n      boxpoints = \"all\",\n      jitter = 0.4,\n      marker = list(opacity = 0.6, size = 4),\n      line = list(width = 1),\n      visible = ifelse(i == 1, TRUE, FALSE),\n      text = paste0(\n        \"Cell state: \", cs,\n        \"&lt;br&gt;Group: \", grp,\n        \"&lt;br&gt;p=\", signif(pval, 3),\n        \" (FDR=\", signif(fdr, 3), \")\"\n      ),\n      hoverinfo = \"text\"\n    )\n    all_traces &lt;- append(all_traces, list(tr))\n  }\n}\n\n# ---- Dropdown menu ----\nbuttons &lt;- lapply(seq_along(cell_states), function(i) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  vis[((i - 1) * 2 + 1):(i * 2)] &lt;- TRUE\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = vis),\n      list(\n        title = paste0(\n          cell_states[i],\n          \" — Kruskal p=\", signif(signif_tbl$p[i], 3),\n          \", FDR=\", signif(signif_tbl$FDR[i], 3),\n          \" \", signif_tbl$signif[i]\n        ),\n        yaxis = list(autorange = TRUE)\n      )\n    ),\n    label = cell_states[i]\n  )\n})\n\n# ---- Build figure ----\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type, x = tr$x, y = tr$y,\n    name = tr$name, boxpoints = tr$boxpoints, jitter = tr$jitter,\n    marker = tr$marker, line = tr$line,\n    text = tr$text, hoverinfo = tr$hoverinfo,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    updatemenus = list(list(\n      y = 1.1, buttons = buttons,\n      direction = \"down\", showactive = TRUE\n    )),\n    boxmode = \"group\",\n    showlegend = TRUE,\n    legend = list(title = list(text = \"&lt;b&gt;Group&lt;/b&gt;\")),\n    yaxis = list(title = \"Proportion\", autorange = TRUE),\n    xaxis = list(title = \"\"),\n    title = list(\n      text = paste0(\"FTLD-C9 Cell-State Proportion Comparison (\", length(cell_states), \" total)\"),\n      x = 0.05\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\ndata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[4])\n\ndata2 &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[20])\n\n# ───────────────────────────────────────────────\n# 1. Remove group.sv\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% select(-group.sv)\n\n# ───────────────────────────────────────────────\n# 2. Replace \"group\" using data2$group matched by \"cell\"\n# ───────────────────────────────────────────────\n\ndata &lt;- data %&gt;%\n  left_join(\n    data2 %&gt;% select(cell, group) %&gt;% rename(new_group = group),\n    by = \"cell\"\n  ) %&gt;%\n  mutate(group = new_group) %&gt;%\n  select(-new_group)\n\n# ───────────────────────────────────────────────\n# 3. Rename \"group\" to \"p.value\"\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% rename(p.value = group)\n\n# Clean column names (HTML safe)\ndata &lt;- data %&gt;% clean_names()\n\n# ───────────────────────────────────────────────\n# 4. Output for HTML Quarto\n# ───────────────────────────────────────────────\ndatatable(\n  data,\n  options = list(\n    pageLength = 25,\n    scrollX = TRUE,\n    autoWidth = TRUE,\n    searchHighlight = TRUE\n  ),\n  class = \"display compact\",\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\n###############################################################\n# PREPROCESSING FOR RIMOD — CONTROL VS C9 ONLY\n###############################################################\n\nlibrary(dplyr)\nlibrary(readr)\nlibrary(openxlsx)\n\n# -------------------------------------------------------------\n# 1. Paths\n# -------------------------------------------------------------\nfrequency_file &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/theta.state_cellstate.csv\"\nmetadata_file  &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\n\n# -------------------------------------------------------------\n# 2. Load metadata\n# -------------------------------------------------------------\nmeta &lt;- read_tsv(metadata_file, show_col_types = FALSE)\n\n# -------------------------------------------------------------\n# 3. Load proportions\n# -------------------------------------------------------------\nfreq &lt;- read.csv(frequency_file, check.names = FALSE)\n\n# First column contains RimodID → rename it\ncolnames(freq)[1] &lt;- \"RimodID\"\n\n# -------------------------------------------------------------\n# 4. Merge metadata + BayesPrism proportions\n# -------------------------------------------------------------\nmerged &lt;- merge(meta, freq, by = \"RimodID\")\n\n# -------------------------------------------------------------\n# 5. Keep ONLY Control and C9 samples\n# -------------------------------------------------------------\nmerged &lt;- merged %&gt;%\n  filter(DiseaseCode %in% c(\"control\", \"FTD-C9\"))\n\n# If no C9 samples exist, stop early\nif (!any(merged$DiseaseCode == \"FTD-C9\")) {\n  stop(\"❌ No C9 samples found in metadata. Check 'DiseaseCode' field.\")\n}\n\n# -------------------------------------------------------------\n# 6. Define two-group factor for the plot\n# -------------------------------------------------------------\nmerged$GROUP &lt;- factor(\n  ifelse(merged$DiseaseCode == \"control\", \"Control\", \"C9\"),\n  levels = c(\"Control\", \"C9\")\n)\n\n# -------------------------------------------------------------\n# 7. Extract cell-state names\n# -------------------------------------------------------------\ncell_states &lt;- colnames(freq)[-1]\n\n# -------------------------------------------------------------\n# 8. arcsin-sqrt transform\n# -------------------------------------------------------------\nmerged_arcsin &lt;- merged\nmerged_arcsin[cell_states] &lt;- asin(sqrt(merged[cell_states]))\n\n# -------------------------------------------------------------\n# 9. Kruskal–Wallis per cell state\n# -------------------------------------------------------------\nsignif_list &lt;- lapply(cell_states, function(cs) {\n\n  subd &lt;- merged_arcsin %&gt;% select(GROUP, all_of(cs))\n  if (any(table(subd$GROUP) &lt; 2, na.rm=TRUE))\n    return(NULL)\n\n  kw &lt;- tryCatch(kruskal.test(subd[[cs]] ~ subd$GROUP),\n                 error = function(e) NULL)\n  if (is.null(kw)) return(NULL)\n\n  pval &lt;- kw$p.value\n  mean_ctrl &lt;- mean(merged[[cs]][merged$GROUP == \"Control\"], na.rm=TRUE)\n  mean_c9   &lt;- mean(merged[[cs]][merged$GROUP == \"C9\"], na.rm=TRUE)\n\n  fc &lt;- ifelse(mean_ctrl == 0, NA, mean_c9 / mean_ctrl)\n\n  data.frame(\n    cell = cs,\n    p = pval,\n    mean_ctrl = mean_ctrl,\n    mean_c9 = mean_c9,\n    fold_change = fc,\n    log2FC = log2(fc)\n  )\n})\n\nsignif_tbl &lt;- bind_rows(signif_list)\n\n# -------------------------------------------------------------\n# 10. Adjust FDR\n# -------------------------------------------------------------\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE        ~ \"ns\"\n    )\n  )\n\n###############################################################\n# These objects are now ready and compatible with your boxplot:\n# - merged\n# - merged_arcsin\n# - cell_states\n# - signif_tbl\n###############################################################\n# ===============================================================\n# Interactive boxplot\n# ===============================================================\nall_traces &lt;- list()\nfor (i in seq_along(cell_states)) {\n  cs &lt;- cell_states[i]\n  df &lt;- merged %&gt;%\n    select(GROUP, all_of(cs)) %&gt;%\n    rename(Proportion = all_of(cs)) %&gt;%\n    filter(!is.na(Proportion))\n\n  # guarantee both groups appear even if one is all-NA\n  missing_groups &lt;- setdiff(levels(merged$GROUP), unique(df$GROUP))\n  if (length(missing_groups) &gt; 0) {\n    df &lt;- rbind(df, data.frame(GROUP = missing_groups, Proportion = NA))\n  }\n  df$GROUP &lt;- factor(df$GROUP, levels = levels(merged$GROUP))\n\n  pval &lt;- signif_tbl$p[signif_tbl$cell == cs]\n  fdr  &lt;- signif_tbl$FDR[signif_tbl$cell == cs]\n  signif_label &lt;- signif_tbl$signif[signif_tbl$cell == cs]\n\n  for (grp in levels(df$GROUP)) {\n    grp_data &lt;- df %&gt;% filter(GROUP == grp)\n    tr &lt;- list(\n      type = \"box\",\n      name = grp,\n      x = rep(grp, nrow(grp_data)),\n      y = grp_data$Proportion,\n      boxpoints = \"all\",\n      jitter = 0.4,\n      marker = list(opacity = 0.6, size = 4),\n      line = list(width = 1),\n      visible = ifelse(i == 1, TRUE, FALSE),\n      text = paste0(\n        \"Cell state: \", cs,\n        \"&lt;br&gt;Group: \", grp,\n        \"&lt;br&gt;p=\", signif(pval, 3),\n        \" (FDR=\", signif(fdr, 3), \")\"\n      ),\n      hoverinfo = \"text\"\n    )\n    all_traces &lt;- append(all_traces, list(tr))\n  }\n}\n\n# ---- Dropdown ----\nbuttons &lt;- lapply(seq_along(cell_states), function(i) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  vis[((i - 1) * length(levels(merged$GROUP)) + 1):(i * length(levels(merged$GROUP)))] &lt;- TRUE\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = vis),\n      list(\n        title = paste0(\n          cell_states[i],\n          \" — Kruskal p=\", signif(signif_tbl$p[i], 3),\n          \", FDR=\", signif(signif_tbl$FDR[i], 3),\n          \" \", signif_tbl$signif[i]\n        ),\n        yaxis = list(autorange = TRUE)\n      )\n    ),\n    label = cell_states[i]\n  )\n})\n\n# ---- Plot ----\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type, x = tr$x, y = tr$y,\n    name = tr$name,\n    boxpoints = tr$boxpoints, jitter = tr$jitter,\n    marker = tr$marker, line = tr$line,\n    text = tr$text, hoverinfo = tr$hoverinfo,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    updatemenus = list(list(\n      y = 1.1, buttons = buttons,\n      direction = \"down\", showactive = TRUE\n    )),\n    boxmode = \"group\",\n    showlegend = TRUE,\n    legend = list(title = list(text = \"&lt;b&gt;Group&lt;/b&gt;\")),\n    yaxis = list(title = \"Proportion (original scale)\", autorange = TRUE),\n    xaxis = list(title = \"\"),\n    title = list(\n      text = paste0(\"FTLD-TDP Cell-State Proportion Comparison (\", length(cell_states), \" total)\"),\n      x = 0.05\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Cell_composition.html#c9",
    "href": "Results/Cell_composition.html#c9",
    "title": "Differences in cell composition",
    "section": "",
    "text": "Analysis revealed significant shifts in arcsin transformed cell type proportions between healthy controls and FTLD-C9 cases, reflecting disease-associated alterations in cortical cellular composition. VAT1L/EYA4 (p = 0.013, FC= 0.066) and GFAP + (p = 0.026, FC= 202,85) cells displayed a striking increase in FTLD-C9 indicative of astrocytic activation. T Cell (p = 0.033, FC= 1.24) proportion is also found increased. Additional significative proportion decreases were observed in PVALB/MYBPC1(p = 0.009, FC= 1.49), and RORB/POU3F2 (p = 0.042, FC= 0.87) populations (Fig.1). Overall, there was an enrichment of cell types associated with immune responses and inflammation, whereas neuronal populations were generally reduced in FTLD-C9.\n\n\n\n\nCode\nlibrary(openxlsx)\nlibrary(dplyr)\nlibrary(DT)\nlibrary(janitor)\n\n# Load sheets\nsheets &lt;- openxlsx::getSheetNames(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\")\n\ndata &lt;- xlsx::read.xlsx(\n  \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\",\n  sheetName = sheets[1]\n)\n\ndata2 &lt;- xlsx::read.xlsx(\n  \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\",\n  sheetName = sheets[12]\n)\n\n# ───────────────────────────────────────────────\n# 1. Remove group.sv\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% select(-group.sv)\n\n# ───────────────────────────────────────────────\n# 2. Replace \"group\" using data2$group matched by \"cell\"\n# ───────────────────────────────────────────────\n\ndata &lt;- data %&gt;%\n  left_join(\n    data2 %&gt;% select(cell, group) %&gt;% rename(new_group = group),\n    by = \"cell\"\n  ) %&gt;%\n  mutate(group = new_group) %&gt;%\n  select(-new_group)\n\n# ───────────────────────────────────────────────\n# 3. Rename \"group\" to \"p.value\"\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% rename(p.value = group)\n\n# Clean column names (HTML safe)\ndata &lt;- data %&gt;% clean_names()\n\n# ───────────────────────────────────────────────\n# 4. Output for HTML Quarto\n# ───────────────────────────────────────────────\ndatatable(\n  data,\n  options = list(\n    pageLength = 25,\n    scrollX = TRUE,\n    autoWidth = TRUE,\n    searchHighlight = TRUE\n  ),\n  class = \"display compact\",\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\n# ---- Libraries ----\n\nlibrary(tidyverse)\nlibrary(openxlsx)\nlibrary(plotly)\n\n# ---- File paths ----\nfrequency_file &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\"\nmetadata_file  &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path    &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CELL_PROP/FTLD/c9/\"\n\nif (!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)\nif (!dir.exists(file.path(output_path, \"Significative\"))) dir.create(file.path(output_path, \"Significative\"))\n\n# ---- Load data ----\nmeta &lt;- openxlsx::read.xlsx(metadata_file, sheet = 1)\nfreq &lt;- read.csv(frequency_file)\n\n# ---- Harmonize IDs ----\nfreq$X &lt;- gsub(\"long\", \"\", freq$X)\nfreq$X &lt;- gsub(\"^X\", \"\", freq$X)\nmeta$sample.ID &lt;- gsub(\"-\", \"_\", meta$sample.ID)\n\n# ---- Merge ----\nmerged &lt;- merge(meta, freq, by.x = \"sample.ID\", by.y = \"X\")\nmerged[merged == 0] &lt;- NA\n\n# ---- Define groups ----\nmerged &lt;- merged[merged$group.ID %in% c(\"Healthy\", \"C9orf72\"), ]\nmerged$GROUP &lt;- factor(ifelse(merged$group.ID == \"Healthy\", \"Control\", \"FTLD\"),\n                       levels = c(\"Control\", \"FTLD\"))\n\n# ---- Extract cell states ----\ncell_states &lt;- colnames(freq)[-1]\n\n# ---- Transform proportions (arcsin sqrt) ----\nmerged_arcsin &lt;- merged\nmerged_arcsin[cell_states] &lt;- asin(sqrt(merged[cell_states]))\n\n# ---- Robust Kruskal–Wallis loop ----\nsignif_list &lt;- lapply(cell_states, function(cs) {\n  subd &lt;- merged_arcsin %&gt;% select(GROUP, all_of(cs))\n  # Ensure both groups have enough samples\n  if (any(table(subd$GROUP) &lt; 2, na.rm = TRUE)) return(NULL)\n  \n  kw &lt;- tryCatch(kruskal.test(subd[[cs]] ~ subd$GROUP), error = function(e) NULL)\n  if (is.null(kw)) return(NULL)\n  \n  pval &lt;- kw$p.value\n  mean_ctrl &lt;- mean(merged[[cs]][merged$GROUP == \"Control\"], na.rm = TRUE)\n  mean_ftld &lt;- mean(merged[[cs]][merged$GROUP == \"FTLD\"], na.rm = TRUE)\n  fc &lt;- ifelse(mean_ctrl == 0, NA, mean_ftld / mean_ctrl)\n  log2fc &lt;- log2(fc)\n  \n  data.frame(\n    cell = cs,\n    p = pval,\n    mean_ctrl = mean_ctrl,\n    mean_ftld = mean_ftld,\n    fold_change = fc,\n    log2FC = log2fc,\n    stringsAsFactors = FALSE\n  )\n})\n\n# ---- Bind cleanly into one table ----\nsignif_tbl &lt;- bind_rows(signif_list)   # use bind_rows instead of rbind for safety\n\n# ---- Multiple testing correction ----\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE ~ \"ns\"\n    )\n  )\n\n# ---- Convert p to numeric safely ----\nsignif_tbl$p &lt;- as.numeric(unlist(signif_tbl$p))\nsignif_tbl$mean_ctrl &lt;- as.numeric(unlist(signif_tbl$mean_ctrl))\nsignif_tbl$mean_ftld &lt;- as.numeric(unlist(signif_tbl$mean_ftld))\nsignif_tbl$fold_change &lt;- as.numeric(unlist(signif_tbl$fold_change))\nsignif_tbl$log2FC &lt;- as.numeric(unlist(signif_tbl$log2FC))\n\n# ---- Multiple testing correction ----\nlibrary(dplyr)\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE ~ \"ns\"\n    )\n  )\n# ---- Interactive boxplot (fixed) ----\nall_traces &lt;- list()\nfor (i in seq_along(cell_states)) {\n  cs &lt;- cell_states[i]\n  df &lt;- merged %&gt;%\n    select(GROUP, all_of(cs)) %&gt;%\n    rename(Proportion = all_of(cs)) %&gt;%\n    filter(!is.na(Proportion))        # remove NA rows before plotting\n  \n  # make sure both groups are present\n  missing_groups &lt;- setdiff(levels(merged$GROUP), unique(df$GROUP))\n  if (length(missing_groups) &gt; 0) {\n    for (mg in missing_groups) {\n      df &lt;- rbind(df, data.frame(GROUP = mg, Proportion = NA))\n    }\n  }\n\n  pval &lt;- signif_tbl$p[signif_tbl$cell == cs]\n  fdr  &lt;- signif_tbl$FDR[signif_tbl$cell == cs]\n  signif_label &lt;- signif_tbl$signif[signif_tbl$cell == cs]\n\n  # Create one trace per group (Control, FTLD)\n  for (grp in levels(merged$GROUP)) {\n    grp_data &lt;- df %&gt;% filter(GROUP == grp)\n    tr &lt;- list(\n      type = \"box\",\n      x = rep(grp, nrow(grp_data)),\n      y = grp_data$Proportion,\n      name = grp,\n      boxpoints = \"all\",\n      jitter = 0.4,\n      marker = list(opacity = 0.6, size = 4),\n      line = list(width = 1),\n      visible = ifelse(i == 1, TRUE, FALSE),\n      text = paste0(\n        \"Cell state: \", cs,\n        \"&lt;br&gt;Group: \", grp,\n        \"&lt;br&gt;p=\", signif(pval, 3),\n        \" (FDR=\", signif(fdr, 3), \")\"\n      ),\n      hoverinfo = \"text\"\n    )\n    all_traces &lt;- append(all_traces, list(tr))\n  }\n}\n\n# ---- Dropdown menu ----\nbuttons &lt;- lapply(seq_along(cell_states), function(i) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  vis[((i - 1) * 2 + 1):(i * 2)] &lt;- TRUE\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = vis),\n      list(\n        title = paste0(\n          cell_states[i],\n          \" — Kruskal p=\", signif(signif_tbl$p[i], 3),\n          \", FDR=\", signif(signif_tbl$FDR[i], 3),\n          \" \", signif_tbl$signif[i]\n        ),\n        yaxis = list(autorange = TRUE)\n      )\n    ),\n    label = cell_states[i]\n  )\n})\n\n# ---- Build figure ----\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type, x = tr$x, y = tr$y,\n    name = tr$name, boxpoints = tr$boxpoints, jitter = tr$jitter,\n    marker = tr$marker, line = tr$line,\n    text = tr$text, hoverinfo = tr$hoverinfo,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    updatemenus = list(list(\n      y = 1.1, buttons = buttons,\n      direction = \"down\", showactive = TRUE\n    )),\n    boxmode = \"group\",\n    showlegend = TRUE,\n    legend = list(title = list(text = \"&lt;b&gt;Group&lt;/b&gt;\")),\n    yaxis = list(title = \"Proportion\", autorange = TRUE),\n    xaxis = list(title = \"\"),\n    title = list(\n      text = paste0(\"FTLD-C9 Cell-State Proportion Comparison (\", length(cell_states), \" total)\"),\n      x = 0.05\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\n\nCode\ndata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[4])\n\ndata2 &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[20])\n\n# ───────────────────────────────────────────────\n# 1. Remove group.sv\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% select(-group.sv)\n\n# ───────────────────────────────────────────────\n# 2. Replace \"group\" using data2$group matched by \"cell\"\n# ───────────────────────────────────────────────\n\ndata &lt;- data %&gt;%\n  left_join(\n    data2 %&gt;% select(cell, group) %&gt;% rename(new_group = group),\n    by = \"cell\"\n  ) %&gt;%\n  mutate(group = new_group) %&gt;%\n  select(-new_group)\n\n# ───────────────────────────────────────────────\n# 3. Rename \"group\" to \"p.value\"\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% rename(p.value = group)\n\n# Clean column names (HTML safe)\ndata &lt;- data %&gt;% clean_names()\n\n# ───────────────────────────────────────────────\n# 4. Output for HTML Quarto\n# ───────────────────────────────────────────────\ndatatable(\n  data,\n  options = list(\n    pageLength = 25,\n    scrollX = TRUE,\n    autoWidth = TRUE,\n    searchHighlight = TRUE\n  ),\n  class = \"display compact\",\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\n###############################################################\n# PREPROCESSING FOR RIMOD — CONTROL VS C9 ONLY\n###############################################################\n\nlibrary(dplyr)\nlibrary(readr)\nlibrary(openxlsx)\n\n# -------------------------------------------------------------\n# 1. Paths\n# -------------------------------------------------------------\nfrequency_file &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/theta.state_cellstate.csv\"\nmetadata_file  &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\n\n# -------------------------------------------------------------\n# 2. Load metadata\n# -------------------------------------------------------------\nmeta &lt;- read_tsv(metadata_file, show_col_types = FALSE)\n\n# -------------------------------------------------------------\n# 3. Load proportions\n# -------------------------------------------------------------\nfreq &lt;- read.csv(frequency_file, check.names = FALSE)\n\n# First column contains RimodID → rename it\ncolnames(freq)[1] &lt;- \"RimodID\"\n\n# -------------------------------------------------------------\n# 4. Merge metadata + BayesPrism proportions\n# -------------------------------------------------------------\nmerged &lt;- merge(meta, freq, by = \"RimodID\")\n\n# -------------------------------------------------------------\n# 5. Keep ONLY Control and C9 samples\n# -------------------------------------------------------------\nmerged &lt;- merged %&gt;%\n  filter(DiseaseCode %in% c(\"control\", \"FTD-C9\"))\n\n# If no C9 samples exist, stop early\nif (!any(merged$DiseaseCode == \"FTD-C9\")) {\n  stop(\"❌ No C9 samples found in metadata. Check 'DiseaseCode' field.\")\n}\n\n# -------------------------------------------------------------\n# 6. Define two-group factor for the plot\n# -------------------------------------------------------------\nmerged$GROUP &lt;- factor(\n  ifelse(merged$DiseaseCode == \"control\", \"Control\", \"C9\"),\n  levels = c(\"Control\", \"C9\")\n)\n\n# -------------------------------------------------------------\n# 7. Extract cell-state names\n# -------------------------------------------------------------\ncell_states &lt;- colnames(freq)[-1]\n\n# -------------------------------------------------------------\n# 8. arcsin-sqrt transform\n# -------------------------------------------------------------\nmerged_arcsin &lt;- merged\nmerged_arcsin[cell_states] &lt;- asin(sqrt(merged[cell_states]))\n\n# -------------------------------------------------------------\n# 9. Kruskal–Wallis per cell state\n# -------------------------------------------------------------\nsignif_list &lt;- lapply(cell_states, function(cs) {\n\n  subd &lt;- merged_arcsin %&gt;% select(GROUP, all_of(cs))\n  if (any(table(subd$GROUP) &lt; 2, na.rm=TRUE))\n    return(NULL)\n\n  kw &lt;- tryCatch(kruskal.test(subd[[cs]] ~ subd$GROUP),\n                 error = function(e) NULL)\n  if (is.null(kw)) return(NULL)\n\n  pval &lt;- kw$p.value\n  mean_ctrl &lt;- mean(merged[[cs]][merged$GROUP == \"Control\"], na.rm=TRUE)\n  mean_c9   &lt;- mean(merged[[cs]][merged$GROUP == \"C9\"], na.rm=TRUE)\n\n  fc &lt;- ifelse(mean_ctrl == 0, NA, mean_c9 / mean_ctrl)\n\n  data.frame(\n    cell = cs,\n    p = pval,\n    mean_ctrl = mean_ctrl,\n    mean_c9 = mean_c9,\n    fold_change = fc,\n    log2FC = log2(fc)\n  )\n})\n\nsignif_tbl &lt;- bind_rows(signif_list)\n\n# -------------------------------------------------------------\n# 10. Adjust FDR\n# -------------------------------------------------------------\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE        ~ \"ns\"\n    )\n  )\n\n###############################################################\n# These objects are now ready and compatible with your boxplot:\n# - merged\n# - merged_arcsin\n# - cell_states\n# - signif_tbl\n###############################################################\n# ===============================================================\n# Interactive boxplot\n# ===============================================================\nall_traces &lt;- list()\nfor (i in seq_along(cell_states)) {\n  cs &lt;- cell_states[i]\n  df &lt;- merged %&gt;%\n    select(GROUP, all_of(cs)) %&gt;%\n    rename(Proportion = all_of(cs)) %&gt;%\n    filter(!is.na(Proportion))\n\n  # guarantee both groups appear even if one is all-NA\n  missing_groups &lt;- setdiff(levels(merged$GROUP), unique(df$GROUP))\n  if (length(missing_groups) &gt; 0) {\n    df &lt;- rbind(df, data.frame(GROUP = missing_groups, Proportion = NA))\n  }\n  df$GROUP &lt;- factor(df$GROUP, levels = levels(merged$GROUP))\n\n  pval &lt;- signif_tbl$p[signif_tbl$cell == cs]\n  fdr  &lt;- signif_tbl$FDR[signif_tbl$cell == cs]\n  signif_label &lt;- signif_tbl$signif[signif_tbl$cell == cs]\n\n  for (grp in levels(df$GROUP)) {\n    grp_data &lt;- df %&gt;% filter(GROUP == grp)\n    tr &lt;- list(\n      type = \"box\",\n      name = grp,\n      x = rep(grp, nrow(grp_data)),\n      y = grp_data$Proportion,\n      boxpoints = \"all\",\n      jitter = 0.4,\n      marker = list(opacity = 0.6, size = 4),\n      line = list(width = 1),\n      visible = ifelse(i == 1, TRUE, FALSE),\n      text = paste0(\n        \"Cell state: \", cs,\n        \"&lt;br&gt;Group: \", grp,\n        \"&lt;br&gt;p=\", signif(pval, 3),\n        \" (FDR=\", signif(fdr, 3), \")\"\n      ),\n      hoverinfo = \"text\"\n    )\n    all_traces &lt;- append(all_traces, list(tr))\n  }\n}\n\n# ---- Dropdown ----\nbuttons &lt;- lapply(seq_along(cell_states), function(i) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  vis[((i - 1) * length(levels(merged$GROUP)) + 1):(i * length(levels(merged$GROUP)))] &lt;- TRUE\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = vis),\n      list(\n        title = paste0(\n          cell_states[i],\n          \" — Kruskal p=\", signif(signif_tbl$p[i], 3),\n          \", FDR=\", signif(signif_tbl$FDR[i], 3),\n          \" \", signif_tbl$signif[i]\n        ),\n        yaxis = list(autorange = TRUE)\n      )\n    ),\n    label = cell_states[i]\n  )\n})\n\n# ---- Plot ----\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type, x = tr$x, y = tr$y,\n    name = tr$name,\n    boxpoints = tr$boxpoints, jitter = tr$jitter,\n    marker = tr$marker, line = tr$line,\n    text = tr$text, hoverinfo = tr$hoverinfo,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    updatemenus = list(list(\n      y = 1.1, buttons = buttons,\n      direction = \"down\", showactive = TRUE\n    )),\n    boxmode = \"group\",\n    showlegend = TRUE,\n    legend = list(title = list(text = \"&lt;b&gt;Group&lt;/b&gt;\")),\n    yaxis = list(title = \"Proportion (original scale)\", autorange = TRUE),\n    xaxis = list(title = \"\"),\n    title = list(\n      text = paste0(\"FTLD-TDP Cell-State Proportion Comparison (\", length(cell_states), \" total)\"),\n      x = 0.05\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Cell_composition.html#tdp",
    "href": "Results/Cell_composition.html#tdp",
    "title": "Differences in cell composition",
    "section": "TDP",
    "text": "TDP\nCell type composition analysis revealed pronounced differences between healthy individuals and FTLD-TDP casesusing arcsin transformation, highlighting disease-related cellular remodeling. GFAP + astrocytes were significantly increased in FTLD-TDP, with a fold change of 7.62 and a p value of 0.003 compared to controls, suggesting astrocytic activation. In contrast, several inhibitory interneuron subtypes—including PVALB_PTHLH (p = 0.017, FC = 0.72), LAMP5_PMEPA1(p = 0.023 FC = 0.59), and PVALB_CEMIP(p = 0.030,FC= 0.62)—were diminished in the disease group (Fig.2). These alterations in cell state proportions emphasize potential cellular mechanisms .\n\nSant Pau\n\n\nCode\ndata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[2])\n\ndata2 &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[8])\n\n# ───────────────────────────────────────────────\n# 1. Remove group.sv\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% select(-group.sv)\n\n# ───────────────────────────────────────────────\n# 2. Replace \"group\" using data2$group matched by \"cell\"\n# ───────────────────────────────────────────────\n\ndata &lt;- data %&gt;%\n  left_join(\n    data2 %&gt;% select(cell, group) %&gt;% rename(new_group = group),\n    by = \"cell\"\n  ) %&gt;%\n  mutate(group = new_group) %&gt;%\n  select(-new_group)\n\n# ───────────────────────────────────────────────\n# 3. Rename \"group\" to \"p.value\"\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% rename(p.value = group)\n\n# Clean column names (HTML safe)\ndata &lt;- data %&gt;% clean_names()\n\n# ───────────────────────────────────────────────\n# 4. Output for HTML Quarto\n# ───────────────────────────────────────────────\ndatatable(\n  data,\n  options = list(\n    pageLength = 25,\n    scrollX = TRUE,\n    autoWidth = TRUE,\n    searchHighlight = TRUE\n  ),\n  class = \"display compact\",\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\nfrequency_file &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/theta.state_original.csv\"\nmetadata_file  &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\noutput_path    &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CELL_PROP/FTLD/TDP/\"\n\nif (!dir.exists(output_path)) dir.create(output_path, recursive = TRUE)\nif (!dir.exists(file.path(output_path, \"Significative\"))) dir.create(file.path(output_path, \"Significative\"))\n\n# ---- Load data ----\nmeta &lt;- openxlsx::read.xlsx(metadata_file, sheet =1)\nfreq &lt;- read.csv(frequency_file)\n\n# ---- Harmonize IDs ----\nfreq$X &lt;- gsub(\"long\", \"\", freq$X)\nfreq$X &lt;- gsub(\"^X\", \"\", freq$X)\nmeta$sample.ID &lt;- gsub(\"-\", \"_\", meta$sample.ID)\n\n# ---- Merge ----\nmerged &lt;- merge(meta, freq, by.x = \"sample.ID\", by.y = \"X\")\nmerged[merged == 0] &lt;- NA\n\n# ---- Define groups ----\nmerged &lt;- merged[merged$group.ID %in% c(\"Healthy\", \"TDP\"), ]\nmerged$GROUP &lt;- factor(ifelse(merged$group.ID == \"Healthy\", \"Control\", \"FTLD\"),\n                       levels = c(\"Control\", \"FTLD\"))\n\n# ---- Extract cell states ----\ncell_states &lt;- colnames(freq)[-1]\n\n# ---- Transform proportions (arcsin sqrt) ----\nmerged_arcsin &lt;- merged\nmerged_arcsin[cell_states] &lt;- asin(sqrt(merged[cell_states]))\n\n# ---- Kruskal–Wallis tests ----\nsignif_list &lt;- lapply(cell_states, function(cs) {\n  subd &lt;- merged_arcsin %&gt;% select(GROUP, all_of(cs))\n  if (any(table(subd$GROUP) &lt; 2, na.rm = TRUE)) return(NULL)\n\n  kw &lt;- tryCatch(kruskal.test(subd[[cs]] ~ subd$GROUP), error = function(e) NULL)\n  if (is.null(kw)) return(NULL)\n\n  pval &lt;- kw$p.value\n  mean_ctrl &lt;- mean(merged[[cs]][merged$GROUP == \"Control\"], na.rm = TRUE)\n  mean_ftld &lt;- mean(merged[[cs]][merged$GROUP == \"FTLD\"], na.rm = TRUE)\n  fc &lt;- ifelse(mean_ctrl == 0, NA, mean_ftld / mean_ctrl)\n  log2fc &lt;- log2(fc)\n\n  data.frame(\n    cell = cs,\n    p = pval,\n    mean_ctrl = mean_ctrl,\n    mean_ftld = mean_ftld,\n    fold_change = fc,\n    log2FC = log2fc,\n    stringsAsFactors = FALSE\n  )\n})\n\n# ---- Combine cleanly ----\nsignif_tbl &lt;- bind_rows(signif_list)\n\n# ---- FDR correction ----\nsignif_tbl &lt;- signif_tbl %&gt;%\n  mutate(\n    FDR = p.adjust(p, method = \"BH\"),\n    signif = case_when(\n      FDR &lt; 0.001 ~ \"***\",\n      FDR &lt; 0.01  ~ \"**\",\n      FDR &lt; 0.05  ~ \"*\",\n      TRUE ~ \"ns\"\n    )\n  )\n# ===============================================================\n# Interactive boxplot\n# ===============================================================\nall_traces &lt;- list()\nfor (i in seq_along(cell_states)) {\n  cs &lt;- cell_states[i]\n  df &lt;- merged %&gt;%\n    select(GROUP, all_of(cs)) %&gt;%\n    rename(Proportion = all_of(cs)) %&gt;%\n    filter(!is.na(Proportion))\n\n  # guarantee both groups appear even if one is all-NA\n  missing_groups &lt;- setdiff(levels(merged$GROUP), unique(df$GROUP))\n  if (length(missing_groups) &gt; 0) {\n    df &lt;- rbind(df, data.frame(GROUP = missing_groups, Proportion = NA))\n  }\n  df$GROUP &lt;- factor(df$GROUP, levels = levels(merged$GROUP))\n\n  pval &lt;- signif_tbl$p[signif_tbl$cell == cs]\n  fdr  &lt;- signif_tbl$FDR[signif_tbl$cell == cs]\n  signif_label &lt;- signif_tbl$signif[signif_tbl$cell == cs]\n\n  for (grp in levels(df$GROUP)) {\n    grp_data &lt;- df %&gt;% filter(GROUP == grp)\n    tr &lt;- list(\n      type = \"box\",\n      name = grp,\n      x = rep(grp, nrow(grp_data)),\n      y = grp_data$Proportion,\n      boxpoints = \"all\",\n      jitter = 0.4,\n      marker = list(opacity = 0.6, size = 4),\n      line = list(width = 1),\n      visible = ifelse(i == 1, TRUE, FALSE),\n      text = paste0(\n        \"Cell state: \", cs,\n        \"&lt;br&gt;Group: \", grp,\n        \"&lt;br&gt;p=\", signif(pval, 3),\n        \" (FDR=\", signif(fdr, 3), \")\"\n      ),\n      hoverinfo = \"text\"\n    )\n    all_traces &lt;- append(all_traces, list(tr))\n  }\n}\n\n# ---- Dropdown ----\nbuttons &lt;- lapply(seq_along(cell_states), function(i) {\n  vis &lt;- rep(FALSE, length(all_traces))\n  vis[((i - 1) * length(levels(merged$GROUP)) + 1):(i * length(levels(merged$GROUP)))] &lt;- TRUE\n  list(\n    method = \"update\",\n    args = list(\n      list(visible = vis),\n      list(\n        title = paste0(\n          cell_states[i],\n          \" — Kruskal p=\", signif(signif_tbl$p[i], 3),\n          \", FDR=\", signif(signif_tbl$FDR[i], 3),\n          \" \", signif_tbl$signif[i]\n        ),\n        yaxis = list(autorange = TRUE)\n      )\n    ),\n    label = cell_states[i]\n  )\n})\n\n# ---- Plot ----\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type, x = tr$x, y = tr$y,\n    name = tr$name,\n    boxpoints = tr$boxpoints, jitter = tr$jitter,\n    marker = tr$marker, line = tr$line,\n    text = tr$text, hoverinfo = tr$hoverinfo,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    updatemenus = list(list(\n      y = 1.1, buttons = buttons,\n      direction = \"down\", showactive = TRUE\n    )),\n    boxmode = \"group\",\n    showlegend = TRUE,\n    legend = list(title = list(text = \"&lt;b&gt;Group&lt;/b&gt;\")),\n    yaxis = list(title = \"Proportion (original scale)\", autorange = TRUE),\n    xaxis = list(title = \"\"),\n    title = list(\n      text = paste0(\"FTLD-TDP Cell-State Proportion Comparison (\", length(cell_states), \" total)\"),\n      x = 0.05\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\nPottier\n\n\nCode\ndata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[3])\n\ndata2 &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/3. CELL PROP DIFFERENCES/ALL_CELL_PROP_DIFFERENCES.xlsx\", sheetName = sheets[16])\n\n\n# ───────────────────────────────────────────────\n# 1. Remove group.sv\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% select(-group.sv)\n\n# ───────────────────────────────────────────────\n# 2. Replace \"group\" using data2$group matched by \"cell\"\n# ───────────────────────────────────────────────\n\ndata &lt;- data %&gt;%\n  left_join(\n    data2 %&gt;% select(cell, group) %&gt;% rename(new_group = group),\n    by = \"cell\"\n  ) %&gt;%\n  mutate(group = new_group) %&gt;%\n  select(-new_group)\n\n# ───────────────────────────────────────────────\n# 3. Rename \"group\" to \"p.value\"\n# ───────────────────────────────────────────────\ndata &lt;- data %&gt;% rename(p.value = group)\n\n# Clean column names (HTML safe)\ndata &lt;- data %&gt;% clean_names()\n\n# ───────────────────────────────────────────────\n# 4. Output for HTML Quarto\n# ───────────────────────────────────────────────\ndatatable(\n  data,\n  options = list(\n    pageLength = 25,\n    scrollX = TRUE,\n    autoWidth = TRUE,\n    searchHighlight = TRUE\n  ),\n  class = \"display compact\",\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(plotly)\nlibrary(coin)\n# ---- Load and preprocess ----\nfrequency_file &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/NEW/theta.state_cellstate.csv\"\nmetadata_file  &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\n\ndata &lt;- read.delim(metadata_file)\nfreq &lt;- read.csv(frequency_file)\n\n# Harmonize sample IDs\nfreq$X &lt;- gsub(\"\\\\.\", \"_\", freq$X)\ndata$FCX_ID &lt;- gsub(\"-\", \"_\", data$FCX_ID)\n\n# Merge and clean\nmerged &lt;- merge(data, freq, by.x = \"FCX_ID\", by.y = \"X\")\nmerged[merged == 0] &lt;- 1e-10\nmerged &lt;- merged[merged$GROUP != \"FTLD-TDP-C\", ]\nmerged$GROUP[merged$GROUP != \"Control\"] &lt;- \"FTLD\"\nmerged$GROUP &lt;- factor(merged$GROUP, levels = c(\"Control\", \"FTLD\"))\n\n# ---- Identify variables ----\ncell_states &lt;- colnames(freq)[-1]\n\n# ---- Run Kruskal–Wallis tests ----\nsignif_tbl &lt;- map_dfr(cell_states, function(cs){\n  subd &lt;- merged %&gt;% select(GROUP, all_of(cs))\n  kw &lt;- tryCatch(kruskal.test(subd[[cs]] ~ subd$GROUP), error=function(e) NULL)\n  if (is.null(kw)) return(NULL)\n  pval &lt;- kw$p.value\n  mean_ctrl &lt;- mean(subd[[cs]][subd$GROUP==\"Control\"], na.rm=TRUE)\n  mean_ftld &lt;- mean(subd[[cs]][subd$GROUP==\"FTLD\"], na.rm=TRUE)\n  fc &lt;- ifelse(mean_ctrl==0, NA, mean_ftld/mean_ctrl)\n  tibble(\n    cell = cs,\n    p = pval,\n    log2FC = log2(fc),\n    mean_ctrl = mean_ctrl,\n    mean_ftld = mean_ftld,\n    signif = case_when(\n      p &lt; 0.001 ~ \"***\",\n      p &lt; 0.01  ~ \"**\",\n      p &lt; 0.05  ~ \"*\",\n      TRUE ~ \"ns\"\n    )\n  )\n})\n\n# ---- Create all traces (two boxes per cell state) ----\nall_traces &lt;- list()\nfor (i in seq_along(cell_states)) {\n  cs &lt;- cell_states[i]\n  df &lt;- merged %&gt;% select(GROUP, all_of(cs)) %&gt;% rename(Proportion = all_of(cs))\n  pval &lt;- signif_tbl$p[signif_tbl$cell==cs][1]\n  signif_label &lt;- signif_tbl$signif[signif_tbl$cell==cs][1]\n\n  # Create two box traces: Control + FTLD\n  for (grp in levels(df$GROUP)) {\n    grp_data &lt;- df[df$GROUP == grp, ]\n    tr &lt;- list(\n      type = \"box\",\n      x = rep(grp, nrow(grp_data)),\n      y = grp_data$Proportion,\n      name = grp,\n      boxpoints = \"all\",\n      jitter = 0.4,\n      marker = list(opacity = 0.6, size = 4),\n      line = list(width = 1),\n      visible = ifelse(i == 1, TRUE, FALSE),\n      text = paste0(\n        \"Cell state: \", cs,\n        \"&lt;br&gt;Group: \", grp,\n        \"&lt;br&gt;Proportion: \", signif(grp_data$Proportion,3)\n      ),\n      hoverinfo = \"text\"\n    )\n    all_traces &lt;- append(all_traces, list(tr))\n  }\n}\n\n# ---- Dropdown buttons ----\nbuttons &lt;- lapply(seq_along(cell_states), function(i){\n  vis &lt;- rep(FALSE, length(all_traces))\n  vis[((i - 1) * 2 + 1):(i * 2)] &lt;- TRUE  # only show 2 boxes per cell state\n  list(\n    method = \"update\",\n    args = list(list(visible = vis),\n                list(title = paste0(cell_states[i],\n                                    \" — Kruskal p=\",\n                                    signif(signif_tbl$p[i], 3), \" \",\n                                    signif_tbl$signif[i]),\n                     yaxis = list(autorange = TRUE))),\n    label = cell_states[i]\n  )\n})\n\n# ---- Combine all into one Plotly figure ----\nfig &lt;- plot_ly()\nfor (tr in all_traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    boxpoints = tr$boxpoints,\n    jitter = tr$jitter,\n    marker = tr$marker,\n    line = tr$line,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    updatemenus = list(list(\n      y = 1.1,\n      buttons = buttons,\n      direction = \"down\",\n      showactive = TRUE\n    )),\n    boxmode = \"group\",\n    showlegend = TRUE,\n    legend = list(title = list(text = \"&lt;b&gt;Group&lt;/b&gt;\")),\n    yaxis = list(title = \"Proportion\", autorange = TRUE),\n    xaxis = list(title = \"\"),\n    title = list(\n      text = paste0(\"Rimmod-C9 Cell-State Boxplots (\", length(cell_states), \" total)\"),\n      x = 0.05\n    )\n  )\n\nfig"
  },
  {
    "objectID": "Results/Bulk_dea_results.html",
    "href": "Results/Bulk_dea_results.html",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "The results on bulk differencial expression analysis showed…."
  },
  {
    "objectID": "Results/Bulk_dea_results.html#c9",
    "href": "Results/Bulk_dea_results.html#c9",
    "title": "Bulk differencial expression analysis",
    "section": "C9",
    "text": "C9\nIn the FTLD-C9 group, we detected 424 DEGs, with 113 upregulated and 311 downregulated. Among the most significantly deregulated genes were C4B (FC = 3.09, adjusted p = 0.010), SEMA3D (FC = 1.75, adjusted p = 0.011), TMEM255A (FC = 1.74, adjusted p = 0.0018), EGR4 (FC = 0.39, adjusted p = 1.6×10⁻⁹), and TRIM29 (FC = 0.23, adjusted p = 9.5×10⁻¹²). These findings point towards both synaptic signaling alterations (e.g., SEMA3D) and transcriptional dysregulation (e.g., EGR4, TRIM29). Validation against the Rimmod dataset, which reported 317 DEGs (252 upregulated, 65 downregulated), confirms the presence of widespread transcriptional alterations in FTLD-C9, although again our cohort showed fewer DEGs, likely reflecting differences in sample size and sequencing depth. Metascape indicated upregulated positive regulation of apoptotic cell cleareance and downregulated dendrite and postsinaptic transmission functions.\n\nSant Pau\n\n\nCode\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(DT)\n\ndata&lt;-readODS::read_ods(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/1. Bulk DEA/ALL_Bulk_DEA.xlsx\", sheet = 2)\n\ncolnames(data)[1] &lt;- \"Gene\"\n\nDT::datatable(\n  data,\n  options = list(\n    pageLength = 5,     \n    lengthMenu = c(5, 10, 20, 50, 100),\n    scrollX = TRUE      \n  ),\n  rownames = FALSE,\n  filter = \"top\",       \n  style = \"bootstrap\"\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(DT)\n\ndf &lt;- data %&gt;%\n  mutate(\n    neglog10FDR = -log10(adj_pval),\n    sig = case_when(\n      adj_pval &lt; 0.05 & logFC &gt; 0 ~ \"Up\",\n      adj_pval &lt; 0.05 & logFC &lt; 0 ~ \"Down\",\n      TRUE ~ \"NS\"\n    )\n  )\n\nplot_ly(\n  df,\n  x = ~logFC,\n  y = ~neglog10FDR,\n  color = ~sig,\n  colors = c(\"Down\" = \"blue\", \"NS\" = \"grey\", \"Up\" = \"red\"),\n  type = \"scatter\",\n  mode = \"markers\",\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;logFC:\", round(logFC, 3),\n    \"&lt;br&gt;FDR:\", signif(adj_pval, 3)\n  ),\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(\n    title = \"Volcano Plot (Interactive)\",\n    xaxis = list(title = \"log2 Fold Change\",\n                 zeroline = TRUE, zerolinewidth = 1, zerolinecolor = \"black\"),\n    yaxis = list(title = \"-log10(FDR)\"),\n    shapes = list(\n      # FC = 0\n      list(type = \"line\",\n           x0 = 0, x1 = 0, y0 = 0, y1 = max(df$neglog10FDR),\n           line = list(dash = \"dash\")),\n      # FDR = 0.05\n      list(type = \"line\",\n           x0 = min(df$logFC), x1 = max(df$logFC),\n           y0 = -log10(0.05), y1 = -log10(0.05),\n           line = list(dash = \"dash\"))\n    )\n  )\n\n\n\n\n\n\n\n\nRimmod\n\n\nCode\ndata&lt;-readODS::read_ods(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/1. Bulk DEA/ALL_Bulk_DEA.xlsx\", sheet = 4)\n\ncolnames(data)[1] &lt;- \"Gene\"\n\nDT::datatable(\n  data,\n  options = list(\n    pageLength = 5,     \n    lengthMenu = c(5, 10, 20, 50, 100),\n    scrollX = TRUE      \n  ),\n  rownames = FALSE,\n  filter = \"top\",       \n  style = \"bootstrap\"\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(plotly)\n\ndf &lt;- data %&gt;%\n  mutate(\n    neglog10FDR = -log10(adj_pval),\n    sig = case_when(\n      adj_pval &lt; 0.05 & logFC &gt; 0 ~ \"Up\",\n      adj_pval &lt; 0.05 & logFC &lt; 0 ~ \"Down\",\n      TRUE ~ \"NS\"\n    )\n  )\n\nplot_ly(\n  df,\n  x = ~logFC,\n  y = ~neglog10FDR,\n  color = ~sig,\n  colors = c(\"Down\" = \"blue\", \"NS\" = \"grey\", \"Up\" = \"red\"),\n  type = \"scatter\",\n  mode = \"markers\",\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;logFC:\", round(logFC, 3),\n    \"&lt;br&gt;FDR:\", signif(adj_pval, 3)\n  ),\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(\n    title = \"Volcano Plot (Interactive)\",\n    xaxis = list(title = \"log2 Fold Change\",\n                 zeroline = TRUE, zerolinewidth = 1, zerolinecolor = \"black\"),\n    yaxis = list(title = \"-log10(FDR)\"),\n    shapes = list(\n      # FC = 0\n      list(type = \"line\",\n           x0 = 0, x1 = 0, y0 = 0, y1 = max(df$neglog10FDR),\n           line = list(dash = \"dash\")),\n      # FDR = 0.05\n      list(type = \"line\",\n           x0 = min(df$logFC), x1 = max(df$logFC),\n           y0 = -log10(0.05), y1 = -log10(0.05),\n           line = list(dash = \"dash\"))\n    )\n  )"
  },
  {
    "objectID": "Results/Bulk_dea_results.html#tdp",
    "href": "Results/Bulk_dea_results.html#tdp",
    "title": "Bulk differencial expression analysis",
    "section": "TDP",
    "text": "TDP\nIn the FTLD-TDP group, we identified 14 differentially expressed genes (DEGs) relative to healthy controls (FDR &lt; 0.05), of which 9 were upregulated and 5 downregulated. Among the upregulated genes, CHI3L2 (FC = 11.08, adjusted p = 0.022) and CHI3L1 (FC = 3.71, adjusted p = 5.2×10⁻⁴) showed the strongest associations, both previously linked to neuroinflammatory processes. SPP1 (FC = 3.19, adjusted p = 0.026) was also significantly upregulated. In comparison, the independent validation dataset from Pottier et al., reported 5624 DEGs (2758 upregulated, 2866 downregulated). The downregulated genes from validation dataset point to a loss in pre and postsynaptic functions but only perinuclear cytoplasmic region is found enriched on sant Pau TDP dataset. Metascape enrichment indicated an upregulation in perinuclear region of cytoplasm.\n\nSant Pau\n\n\nCode\ndata&lt;-readODS::read_ods(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/1. Bulk DEA/ALL_Bulk_DEA.xlsx\", sheet = 1)\n\ncolnames(data)[1] &lt;- \"Gene\"\n\nDT::datatable(\n  data,\n  options = list(\n    pageLength = 5,     \n    lengthMenu = c(5, 10, 20, 50, 100),\n    scrollX = TRUE      \n  ),\n  rownames = FALSE,\n  filter = \"top\",       \n  style = \"bootstrap\"\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(DT)\n\ndf &lt;- data %&gt;%\n  mutate(\n    neglog10FDR = -log10(adj_pval),\n    sig = case_when(\n      adj_pval &lt; 0.05 & logFC &gt; 0 ~ \"Up\",\n      adj_pval &lt; 0.05 & logFC &lt; 0 ~ \"Down\",\n      TRUE ~ \"NS\"\n    )\n  )\n\nplot_ly(\n  df,\n  x = ~logFC,\n  y = ~neglog10FDR,\n  color = ~sig,\n  colors = c(\"Down\" = \"blue\", \"NS\" = \"grey\", \"Up\" = \"red\"),\n  type = \"scatter\",\n  mode = \"markers\",\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;logFC:\", round(logFC, 3),\n    \"&lt;br&gt;FDR:\", signif(adj_pval, 3)\n  ),\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(\n    title = \"Volcano Plot (Interactive)\",\n    xaxis = list(title = \"log2 Fold Change\",\n                 zeroline = TRUE, zerolinewidth = 1, zerolinecolor = \"black\"),\n    yaxis = list(title = \"-log10(FDR)\"),\n    shapes = list(\n      # FC = 0\n      list(type = \"line\",\n           x0 = 0, x1 = 0, y0 = 0, y1 = max(df$neglog10FDR),\n           line = list(dash = \"dash\")),\n      # FDR = 0.05\n      list(type = \"line\",\n           x0 = min(df$logFC), x1 = max(df$logFC),\n           y0 = -log10(0.05), y1 = -log10(0.05),\n           line = list(dash = \"dash\"))\n    )\n  )\n\n\n\n\n\n\n\n\nPottier\n\n\nCode\ndata&lt;-readODS::read_ods(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/1. Bulk DEA/ALL_Bulk_DEA.xlsx\", sheet = 3)\n\ncolnames(data)[1] &lt;- \"Gene\"\n\nDT::datatable(\n  data,\n  options = list(\n    pageLength = 5,     \n    lengthMenu = c(5, 10, 20, 50, 100),\n    scrollX = TRUE      \n  ),\n  rownames = FALSE,\n  filter = \"top\",       \n  style = \"bootstrap\"\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(plotly)\n\ndf &lt;- data %&gt;%\n  mutate(\n    neglog10FDR = -log10(adj_pval),\n    sig = case_when(\n      adj_pval &lt; 0.05 & logFC &gt; 0 ~ \"Up\",\n      adj_pval &lt; 0.05 & logFC &lt; 0 ~ \"Down\",\n      TRUE ~ \"NS\"\n    )\n  )\n\nplot_ly(\n  df,\n  x = ~logFC,\n  y = ~neglog10FDR,\n  color = ~sig,\n  colors = c(\"Down\" = \"blue\", \"NS\" = \"grey\", \"Up\" = \"red\"),\n  type = \"scatter\",\n  mode = \"markers\",\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;logFC:\", round(logFC, 3),\n    \"&lt;br&gt;FDR:\", signif(adj_pval, 3)\n  ),\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(\n    title = \"Volcano Plot (Interactive)\",\n    xaxis = list(title = \"log2 Fold Change\",\n                 zeroline = TRUE, zerolinewidth = 1, zerolinecolor = \"black\"),\n    yaxis = list(title = \"-log10(FDR)\"),\n    shapes = list(\n      # FC = 0\n      list(type = \"line\",\n           x0 = 0, x1 = 0, y0 = 0, y1 = max(df$neglog10FDR),\n           line = list(dash = \"dash\")),\n      # FDR = 0.05\n      list(type = \"line\",\n           x0 = min(df$logFC), x1 = max(df$logFC),\n           y0 = -log10(0.05), y1 = -log10(0.05),\n           line = list(dash = \"dash\"))\n    )\n  )\n\n\n\n\n\n\n\n\nCode\ncell_type_dea &lt;- load_or_placeholder(\n  option_name = \"results_vis.cell_type_dea\",\n  pattern = \"cell.*type.*dea.*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    tibble::tibble(\n      Cluster = rep(paste(\"Cluster\", 1:8), each = 40),\n      Gene = paste0(\"Gene\", seq_len(320)),\n      avg_log2FC = rnorm(320, sd = 0.8),\n      pct_in = runif(320, min = 0, max = 1),\n      pct_out = runif(320, min = 0, max = 1),\n      p_val_adj = p.adjust(runif(320, min = 1e-5, max = 0.5), method = \"BH\")\n    )\n  }\n)\n\n\n\n\nCode\nrender_source_note(cell_type_dea, \"cell type DEA\")\nplot_ly(\n  cell_type_dea,\n  x = ~avg_log2FC,\n  y = ~-log10(p_val_adj + 1e-12),\n  color = ~Cluster,\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;pct_in:\", sprintf(\"%.1f%%\", pct_in * 100),\n    \"&lt;br&gt;pct_out:\", sprintf(\"%.1f%%\", pct_out * 100)\n  ),\n  type = \"scatter\",\n  mode = \"markers\",\n  hovertemplate = \"%{text}&lt;extra&gt;&lt;/extra&gt;\"\n) %&gt;%\n  layout(title = \"Cell-Type Differential Expression\",\n         xaxis = list(title = \"Average log2 Fold Change\"),\n         yaxis = list(title = \"-log10(adj p-value)\")) %&gt;%\n  annotate_placeholder(cell_type_dea)"
  },
  {
    "objectID": "Methods/Sc_dea.html",
    "href": "Methods/Sc_dea.html",
    "title": "Single cell analysis",
    "section": "",
    "text": "Bulk RNA-seq differential expression identifies tissue-level transcriptional changes but cannot distinguish whether these alterations originate from specific neuronal subclasses, glial populations, or vascular/immune lineages. Because FTLD pathology is known to selectively affect distinct cortical cell populations—such as RORB-expressing excitatory neurons, subsets of inhibitory neurons, and diverse astroglial and microglial states—bulk analysis alone provides limited biological resolution.\nTo overcome this limitation, we leveraged the cell-state–specific expression matrices generated by BayesPrism, which infer gene-level expression for each of the 44 transcriptional states defined in the Pineda et al. single-nucleus reference. These matrices represent “pseudobulk” expression profiles for each cell state within each sample, enabling differential gene expression analysis at single-cell resolution using bulk RNA-seq.\nApplying edgeR (Robinson, McCarthy, and Smyth 2010) to these deconvolved matrices allows rigorous detection of transcriptional alterations within individual cell states, thereby identifying the precise cellular compartments responsible for disease-associated dysregulation in FTLD-C9 and FTLD-TDP.\n\n\n\n\nFor each sample, BayesPrism returned cell-state–specific gene expression estimates for all 43–44 states in the Pineda et al. reference. These matrices were:\n\naggregated per cell state across samples,\ntreated as pseudobulk counts,\n\nused as direct input to edgeR differential expression workflows.\nOnly cell states with sufficient expression and non-zero counts across samples were retained for statistical modeling.\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  # Handle other cases or file types\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\n\n\n\nFor each cell state:\n\nGenes with zero or near-zero counts were removed.\nOnly transcripts expressed in ≥1 sample were kept.\nMitochondrial, ribosomal, and sex-chromosome genes had already been removed at the BayesPrism stage.\naverage CPM\nnormalization\n\nThis ensured that differential expression reflected biologically meaningful changes rather than sparsity-related artifacts.\n\n\nCode\ncomparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n\n\n\n\n\nTo account for unwanted technical and biological variability:\n\nSurrogate variables (SVs) estimated from the bulk RNA-seq data were included as covariates in the design matrix, controlling for batch-like or hidden confounders.\n\nThis approach improves statistical robustness, especially in modest sample sizes typical of post-mortem FTLD cohorts.\n\n\nCode\n   group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n\n\n\n\n\nFor each of the 43–44 cell states:\n\nA design matrix modeled diagnostic status (FTLD-C9 or FTLD-TDP) with Healthy as the reference level.\nA single contrast per cell state tested the effect of disease.\nThe glmLRT() framework was applied.\n\nMultiple-testing correction within each cell state was performed using Benjamini–Hochberg FDR, with significance defined as:\n\nFDR &lt; 0.05\n\nFor each significant gene, the following metrics were extracted:\n\nlog2 fold change\nraw p-value and FDR-adjusted p-value\naverage CPM per condition\n\n\n\nCode\n     # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n\n\n\n\n\nTo assess reproducibility:\n\nCell-state DEGs from the Sant Pau FTLD-C9 dataset were compared with those from the Menden et al. dataset.\nCell-state DEGs from the Sant Pau FTLD-TDP dataset were compared with the Pottier et al. cohort.\n\nOverlap significance was quantified using:\n\nGeneOverlap statistics\nJaccard indices\n\nThis allowed identification of robust cell-state–specific signatures conserved across cohorts.\n\n\nCode\n# JACCARD \nlibrary(\"openxlsx\")\nlibrary(\"GeneOverlap\")\nlibrary(\"VennDiagram\")\nlibrary(\"grid\")\n\n# Define functions\n# Jaccard similarity index\njaccard_similarity &lt;- function(list1, list2) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  union_size &lt;- length(union(list1, list2))\n  return(intersection_size / union_size)\n}\n\n# Perform permutation test for p-value\npermutation_test &lt;- function(list1, list2, n_permutations = 10000) {\n  observed_jaccard &lt;- jaccard_similarity(list1, list2)\n  \n  permuted_jaccards &lt;- replicate(n_permutations, {\n    permuted_list1 &lt;- sample(list1)\n    permuted_list2 &lt;- sample(list2)\n    jaccard_similarity(permuted_list1, permuted_list2)\n  })\n  p_value &lt;- mean(permuted_jaccards &gt;= observed_jaccard)\n  return(p_value)\n}\n\nhypergeometric_test &lt;- function(list1, list2, total_population_size) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  total_genes &lt;- total_population_size  # Total number of possible genes\n  \n  # Number of DEGs in list1 and list2\n  K1 &lt;- length(list1)\n  K2 &lt;- length(list2)\n  \n  # Hypergeometric test to calculate p-value\n  p_value &lt;- phyper(intersection_size - 1, K1, total_genes - K1, K2, lower.tail = FALSE)\n  \n  return(p_value)\n}\n\n\n# TDP43\n\n# Define variables\nCStates &lt;- c(\n  \"Arterial\", \"DISC1_RELN\", \"Pericyte\", \"SMC\", \"TLE4_CCBE1\",\n  \"Capillary\", \"GFAP-neg\", \"PVALB_CEMIP\", \"SST_ADAMTS19\", \"TLE4_MEGF11\",\n  \"CDH4_CCK\", \"GFAP-pos\", \"PVALB_MYBPC1\", \"SST_BRINP3\", \"TLE4_SEMA3D\",\n  \"CDH4_SCGN\", \"LAMP5_CA3\", \"PVALB_PTHLH\", \"SST_GALNT14\", \"VAT1L_EYA4\",\n  \"CLMP_KCNMA1\", \"LAMP5_PMEPA1\", \"RORB_ADGRL4\", \"SST_NPY\", \"Venous\",\n  \"CLMP_PDGFRA\", \"Micro\", \"RORB_FOXO1\", \"VIP_CLSTN2\",\n  \"CUX2_RASGRF2\", \"Oligo\", \"RORB_LRRK1\", \"T_Cell\", \"VIP_HTR2C\",\n  \"CUX2_RORB\", \"OPC\", \"RORB_POU3F2\", \"THEMIS_NR4A2\", \"VIP_LAMA3\",\n  \"DISC1_CCK\", \"PCP4_NXPH2\", \"SCN4B_NEFH\", \"THEMIS_TMEM233\"\n)\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/CS_LRT/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/TDP_NEW/CS_Correcte\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Nou\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Nou\",\n  \"CU FTLD – Nou\", \"CD FTLD – Nou\", \n  \"JU FTLD – Nou\", \"JD FTLD – Nou\",\n  \"GU FTLD – Nou\", \"GD FTLD – Nou\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n    # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n\n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Control.1.TDP == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Control.1.TDP == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n\n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n\n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n\n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n\n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Nou\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Nou\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Nou\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Nou\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Nou\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Nou\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Nou\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Nou\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\n\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/TDP43_Validation_results_cs.csv\"))\n\n\n\n\nCode\n# C9\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/C9_NEW/CS\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Rimod\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Rimod\",\n  \"CU FTLD – Rimod\", \"CD FTLD – Rimod\", \n  \"JU FTLD – Rimod\", \"JD FTLD – Rimod\",\n  \"GU FTLD – Rimod\", \"GD FTLD – Rimod\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n  # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n  \n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.C9orf72 == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.c9orf72 == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n  \n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n  \n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n  \n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n  \n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Rimod\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Rimod\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Rimod\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Rimod\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Rimod\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Rimod\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Rimod\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Rimod\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/C9_Validation_results_cs.csv\"))\n\n\n\n\n\n\nThe single-cell differential expression module was designed to:\n\nIdentify the precise cell states driving disease-specific transcriptional alterations in FTLD-C9 and FTLD-TDP.\nDistinguish neuronal and glial subtypes with high DEG burden, pointing to selective cellular vulnerability.\nCharacterize lineage-specific pathways, such as synaptic dysfunction in RORB neurons or inflammatory activation in GFAP+ astrocytes.\nLink transcriptional changes to neuropathological markers, including STMN2 loss, pTDP-43 burden, and DPR/RNA foci density.\nEnable functional enrichment (GO/Metascape) for each cell state, revealing discrete biological processes altered in disease.\nProvide a unified cellular framework for comparing FTLD-C9 and FTLD-TDP, facilitating identification of shared and divergent mechanisms.\nSupport robust cross-validation with independent datasets, increasing confidence in the generalizability of cell-state transcriptional signatures.\n\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  conditions &lt;- \"C9orf72\"\n  for (condition in conditions){\n    \n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\n\n\nCode\nlibrary(edgeR, lib.loc = \"/home/jaumatell/R/x86_64-pc-linux-gnu-library/4.4/edgeR_4\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/DEG\"\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.xlsx(CASE_LEGEND,sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"TDP\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  rownames(data) &lt;-gsub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      \n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      data_ordered[is.na(data_ordered)] &lt;- 10e-8\n      \n      group &lt;- factor(comparison_data$group_ID)\n      y &lt;- DGEList(counts = t(data_ordered), group = group)\n      \n      # Plot average log CPM\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(y, column = 1)\n      abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n      dev.off()\n      \n      # Create design matrix\n      design &lt;- model.matrix(~ 0 + group)\n      colnames(design) &lt;- levels(group)\n      \n      # Estimate dispersion\n      y &lt;- estimateDisp(y, design)\n      fit &lt;- glmFit(y, design)\n      \n      #Differential expression analysis\n      contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n      res &lt;- glmLRT(fit, contrast = contrast)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      \n      # Save results\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      # Histogram\n      plot_filename &lt;- file.path(condition_folder, \"histogram_plot_h.png\")\n      png(file = plot_filename)\n      hist(AveLogCPM)\n      dev.off()\n      \n      # BCV plot\n      plot_filename &lt;- file.path(condition_folder, \"BCV_plot_h.png\")\n      png(file = plot_filename)\n      plotBCV(y)\n      dev.off()\n      \n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status = is.de)\n      dev.off()\n      \n      # Heatmap clustering\n      logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep = \"-\")\n      tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30], ]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n      dev.off()\n      \n      # Update summary DataFrame\n      df[condition, filename] &lt;- nrow(results_table[results_table$adj_pval &lt; 0.05, ])\n      \n    }, error = function(e) {\n      print(e)\n      df[condition, filename] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/CELL STATE ORIGINAL/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncovariate_data &lt;- read.csv(SV_COVARIATE, sep = \"\\t\")\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode %in% c(\"control\", \"FTD-C9\"), ]\n\n# 2. Renombrar valores dentro de DiseaseCode\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"FTD-C9\"] &lt;- \"C9orf72\"\n\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"C9orf72\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$RimodID, covariate_data$ID)]\n\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      common_ids &lt;- intersect(comparison_data$RimodID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$RimodID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$RimodID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$RimodID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# FTD\n#CT\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/NEW/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect\"\n\nREFERENCE_GROUP &lt;- \"Control\"\n\ncovariate_data &lt;- read.delim(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\",]\ncase_legend$GROUP[case_legend$GROUP != \"Control\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- as.factor(case_legend$GROUP)\n\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  \n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions){\n    condition &lt;- \"TDP\"\n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$FCX_ID, covariate_data$ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      comparison_data$FCX_ID &lt;- gsub(\"-\", \".\", comparison_data$FCX_ID)\n      common_ids &lt;- intersect(comparison_data$FCX_ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$FCX_ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$FCX_ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$FCX_ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))"
  },
  {
    "objectID": "Methods/Sc_dea.html#analytical-strategy",
    "href": "Methods/Sc_dea.html#analytical-strategy",
    "title": "Single cell analysis",
    "section": "",
    "text": "For each sample, BayesPrism returned cell-state–specific gene expression estimates for all 43–44 states in the Pineda et al. reference. These matrices were:\n\naggregated per cell state across samples,\ntreated as pseudobulk counts,\n\nused as direct input to edgeR differential expression workflows.\nOnly cell states with sufficient expression and non-zero counts across samples were retained for statistical modeling.\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  # Handle other cases or file types\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\n\n\n\nFor each cell state:\n\nGenes with zero or near-zero counts were removed.\nOnly transcripts expressed in ≥1 sample were kept.\nMitochondrial, ribosomal, and sex-chromosome genes had already been removed at the BayesPrism stage.\naverage CPM\nnormalization\n\nThis ensured that differential expression reflected biologically meaningful changes rather than sparsity-related artifacts.\n\n\nCode\ncomparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n\n\n\n\n\nTo account for unwanted technical and biological variability:\n\nSurrogate variables (SVs) estimated from the bulk RNA-seq data were included as covariates in the design matrix, controlling for batch-like or hidden confounders.\n\nThis approach improves statistical robustness, especially in modest sample sizes typical of post-mortem FTLD cohorts.\n\n\nCode\n   group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n\n\n\n\n\nFor each of the 43–44 cell states:\n\nA design matrix modeled diagnostic status (FTLD-C9 or FTLD-TDP) with Healthy as the reference level.\nA single contrast per cell state tested the effect of disease.\nThe glmLRT() framework was applied.\n\nMultiple-testing correction within each cell state was performed using Benjamini–Hochberg FDR, with significance defined as:\n\nFDR &lt; 0.05\n\nFor each significant gene, the following metrics were extracted:\n\nlog2 fold change\nraw p-value and FDR-adjusted p-value\naverage CPM per condition\n\n\n\nCode\n     # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n\n\n\n\n\nTo assess reproducibility:\n\nCell-state DEGs from the Sant Pau FTLD-C9 dataset were compared with those from the Menden et al. dataset.\nCell-state DEGs from the Sant Pau FTLD-TDP dataset were compared with the Pottier et al. cohort.\n\nOverlap significance was quantified using:\n\nGeneOverlap statistics\nJaccard indices\n\nThis allowed identification of robust cell-state–specific signatures conserved across cohorts.\n\n\nCode\n# JACCARD \nlibrary(\"openxlsx\")\nlibrary(\"GeneOverlap\")\nlibrary(\"VennDiagram\")\nlibrary(\"grid\")\n\n# Define functions\n# Jaccard similarity index\njaccard_similarity &lt;- function(list1, list2) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  union_size &lt;- length(union(list1, list2))\n  return(intersection_size / union_size)\n}\n\n# Perform permutation test for p-value\npermutation_test &lt;- function(list1, list2, n_permutations = 10000) {\n  observed_jaccard &lt;- jaccard_similarity(list1, list2)\n  \n  permuted_jaccards &lt;- replicate(n_permutations, {\n    permuted_list1 &lt;- sample(list1)\n    permuted_list2 &lt;- sample(list2)\n    jaccard_similarity(permuted_list1, permuted_list2)\n  })\n  p_value &lt;- mean(permuted_jaccards &gt;= observed_jaccard)\n  return(p_value)\n}\n\nhypergeometric_test &lt;- function(list1, list2, total_population_size) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  total_genes &lt;- total_population_size  # Total number of possible genes\n  \n  # Number of DEGs in list1 and list2\n  K1 &lt;- length(list1)\n  K2 &lt;- length(list2)\n  \n  # Hypergeometric test to calculate p-value\n  p_value &lt;- phyper(intersection_size - 1, K1, total_genes - K1, K2, lower.tail = FALSE)\n  \n  return(p_value)\n}\n\n\n# TDP43\n\n# Define variables\nCStates &lt;- c(\n  \"Arterial\", \"DISC1_RELN\", \"Pericyte\", \"SMC\", \"TLE4_CCBE1\",\n  \"Capillary\", \"GFAP-neg\", \"PVALB_CEMIP\", \"SST_ADAMTS19\", \"TLE4_MEGF11\",\n  \"CDH4_CCK\", \"GFAP-pos\", \"PVALB_MYBPC1\", \"SST_BRINP3\", \"TLE4_SEMA3D\",\n  \"CDH4_SCGN\", \"LAMP5_CA3\", \"PVALB_PTHLH\", \"SST_GALNT14\", \"VAT1L_EYA4\",\n  \"CLMP_KCNMA1\", \"LAMP5_PMEPA1\", \"RORB_ADGRL4\", \"SST_NPY\", \"Venous\",\n  \"CLMP_PDGFRA\", \"Micro\", \"RORB_FOXO1\", \"VIP_CLSTN2\",\n  \"CUX2_RASGRF2\", \"Oligo\", \"RORB_LRRK1\", \"T_Cell\", \"VIP_HTR2C\",\n  \"CUX2_RORB\", \"OPC\", \"RORB_POU3F2\", \"THEMIS_NR4A2\", \"VIP_LAMA3\",\n  \"DISC1_CCK\", \"PCP4_NXPH2\", \"SCN4B_NEFH\", \"THEMIS_TMEM233\"\n)\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/CS_LRT/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/TDP_NEW/CS_Correcte\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Nou\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Nou\",\n  \"CU FTLD – Nou\", \"CD FTLD – Nou\", \n  \"JU FTLD – Nou\", \"JD FTLD – Nou\",\n  \"GU FTLD – Nou\", \"GD FTLD – Nou\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n    # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n\n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Control.1.TDP == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Control.1.TDP == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n\n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n\n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n\n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n\n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Nou\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Nou\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Nou\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Nou\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Nou\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Nou\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Nou\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Nou\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\n\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/TDP43_Validation_results_cs.csv\"))\n\n\n\n\nCode\n# C9\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/C9_NEW/CS\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Rimod\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Rimod\",\n  \"CU FTLD – Rimod\", \"CD FTLD – Rimod\", \n  \"JU FTLD – Rimod\", \"JD FTLD – Rimod\",\n  \"GU FTLD – Rimod\", \"GD FTLD – Rimod\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n  # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n  \n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.C9orf72 == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.c9orf72 == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n  \n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n  \n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n  \n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n  \n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Rimod\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Rimod\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Rimod\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Rimod\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Rimod\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Rimod\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Rimod\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Rimod\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/C9_Validation_results_cs.csv\"))"
  },
  {
    "objectID": "Methods/Sc_dea.html#analytical-goals-of-the-single-cellresolved-differential-expression-analysis",
    "href": "Methods/Sc_dea.html#analytical-goals-of-the-single-cellresolved-differential-expression-analysis",
    "title": "Single cell analysis",
    "section": "",
    "text": "The single-cell differential expression module was designed to:\n\nIdentify the precise cell states driving disease-specific transcriptional alterations in FTLD-C9 and FTLD-TDP.\nDistinguish neuronal and glial subtypes with high DEG burden, pointing to selective cellular vulnerability.\nCharacterize lineage-specific pathways, such as synaptic dysfunction in RORB neurons or inflammatory activation in GFAP+ astrocytes.\nLink transcriptional changes to neuropathological markers, including STMN2 loss, pTDP-43 burden, and DPR/RNA foci density.\nEnable functional enrichment (GO/Metascape) for each cell state, revealing discrete biological processes altered in disease.\nProvide a unified cellular framework for comparing FTLD-C9 and FTLD-TDP, facilitating identification of shared and divergent mechanisms.\nSupport robust cross-validation with independent datasets, increasing confidence in the generalizability of cell-state transcriptional signatures.\n\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  conditions &lt;- \"C9orf72\"\n  for (condition in conditions){\n    \n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\n\n\nCode\nlibrary(edgeR, lib.loc = \"/home/jaumatell/R/x86_64-pc-linux-gnu-library/4.4/edgeR_4\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/DEG\"\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.xlsx(CASE_LEGEND,sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"TDP\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  rownames(data) &lt;-gsub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      \n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      data_ordered[is.na(data_ordered)] &lt;- 10e-8\n      \n      group &lt;- factor(comparison_data$group_ID)\n      y &lt;- DGEList(counts = t(data_ordered), group = group)\n      \n      # Plot average log CPM\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(y, column = 1)\n      abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n      dev.off()\n      \n      # Create design matrix\n      design &lt;- model.matrix(~ 0 + group)\n      colnames(design) &lt;- levels(group)\n      \n      # Estimate dispersion\n      y &lt;- estimateDisp(y, design)\n      fit &lt;- glmFit(y, design)\n      \n      #Differential expression analysis\n      contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n      res &lt;- glmLRT(fit, contrast = contrast)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      \n      # Save results\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      # Histogram\n      plot_filename &lt;- file.path(condition_folder, \"histogram_plot_h.png\")\n      png(file = plot_filename)\n      hist(AveLogCPM)\n      dev.off()\n      \n      # BCV plot\n      plot_filename &lt;- file.path(condition_folder, \"BCV_plot_h.png\")\n      png(file = plot_filename)\n      plotBCV(y)\n      dev.off()\n      \n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status = is.de)\n      dev.off()\n      \n      # Heatmap clustering\n      logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep = \"-\")\n      tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30], ]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n      dev.off()\n      \n      # Update summary DataFrame\n      df[condition, filename] &lt;- nrow(results_table[results_table$adj_pval &lt; 0.05, ])\n      \n    }, error = function(e) {\n      print(e)\n      df[condition, filename] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/CELL STATE ORIGINAL/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncovariate_data &lt;- read.csv(SV_COVARIATE, sep = \"\\t\")\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode %in% c(\"control\", \"FTD-C9\"), ]\n\n# 2. Renombrar valores dentro de DiseaseCode\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"FTD-C9\"] &lt;- \"C9orf72\"\n\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"C9orf72\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$RimodID, covariate_data$ID)]\n\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      common_ids &lt;- intersect(comparison_data$RimodID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$RimodID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$RimodID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$RimodID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\n\n\nCode\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# FTD\n#CT\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/NEW/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect\"\n\nREFERENCE_GROUP &lt;- \"Control\"\n\ncovariate_data &lt;- read.delim(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\",]\ncase_legend$GROUP[case_legend$GROUP != \"Control\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- as.factor(case_legend$GROUP)\n\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  \n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions){\n    condition &lt;- \"TDP\"\n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$FCX_ID, covariate_data$ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      comparison_data$FCX_ID &lt;- gsub(\"-\", \".\", comparison_data$FCX_ID)\n      common_ids &lt;- intersect(comparison_data$FCX_ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$FCX_ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$FCX_ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$FCX_ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))"
  },
  {
    "objectID": "Results/Cell_correlation.html",
    "href": "Results/Cell_correlation.html",
    "title": "Cell composition correlation with neuropathology",
    "section": "",
    "text": "The neurpopathology markers identifyed in C9orf72 cases were ACSL3 FociANTI, FociSENSE, lncRNA, PolyGA, PolyGP, PolyGR, STMN2 and burden TDP43 and for the TDP43 cases STMN2 and burden TDP43 only.\nIn FTLD-C9orf72 cell composition association with neuropathology we find the following correlations on each marker. Changes in ACSL3 levels point to altered lipid metabolism seen in C9orf72-associated FTLD.\nSeveral cell types exhibited significant correlations with ACSL3 pathology. OPC cell type is found to be the most correlated cell type(ρ = 0.78, p = 0.007), showing an increase in their proportion with ACSL3 density. Notably, RORB/ADGRL4 (ρ = –0.65, p = 0.03) and RORB/LRRK1 (ρ = –0.63, p = 0.04), excitatory neurons showed a strong negative correlation, suggesting a reduction in this subtypes in cases with greater aggregate burden.\nIn contrast, GFAP - astrocytes exhibited a positive correlation with ACSL3 load (ρ = 0.64, p = 0.03), indicating an expansion of this glial population in more affected individuals. Antisense RNA foci from the repeat expansion similarly disrupt RNA metabolism in FTLD. One cell type exhibited significant correlation with fociANTI pathology. The non transformed PCP4/NXPH2 cell type showed a negative correlation with fociANTI load (ρ = –0.69, p = 0.019), suggesting a reduction in this population in more affected individuals. Non transformed fociSENSE RNA from the expanded C9orf72 repeat sequester RNA-binding proteins, contributing to FTLD pathology.\nSeveral cell types exhibited significant correlations with fociSENSE pathology. PCP4/NXPH2 exhibited a strong negative correlation (ρ = –0.70, p = 0.01), while PVALB/MYBPC1 showed a similarly strong positive correlation (ρ = 0.70, p = 0.01). Pericyte cells were also negatively correlated (ρ = –0.70, p = 0.02), indicating a decrease in their proportion with increased pathology. Conversely, VIP/LAMA3 (ρ = 0.65, p = 0.03) and capillary cells (ρ = 0.65, p = 0.03) showed positive correlations, suggesting their expansion in higher pathology cases.\nAdditionally, RORB/LRRK1 (ρ = –0.63, p = 0.04) and PVALB/CEMIP (ρ = 0.62, p = 0.04) were significantly associated, indicating subtype-specific vulnerability. Dysregulation of specific long non-coding RNAs is linked to RNA toxicity from C9orf72 repeat expansions in FTLD. Several cell types exhibited significant correlations with lncRNA pathology. RORB/FOXO1 displayed a very strong positive correlation (ρ = 0.93, p = 0.00), suggesting a marked increase in this subtype with higher pathology.\nIn contrast, Oligodendrocytes showed a negative correlation (ρ = –0.68, p = 0.02), as did THEMIS/NR4A2 neurons (ρ = –0.63, p = 0.04), indicating a decrease in these populations in more affected individuals. THEMIS/TMEM233 neurons were significantly positively correlated with polyGA pathology (ρ = 0.63, p = 0.04), suggesting an expansion of this subtype in individuals with greater aggregate burden.\nTwo cell types exhibited significant correlations with polyGP pathology. THEMIS/TMEM233 (ρ = 0.66, p = 0.03) and TLE4/CCBE1 (ρ = 0.63, p = 0.04) both demonstrated positive correlations, indicating an increased presence of these excitatory neuron subtypes in relation to pathology load. Reduced STMN2 expression reflects TDP-43–related cryptic splicing, a hallmark of FTLD with C9orf72 expansion. Several cell types exhibited significant correlations with STMN2 pathology. GFAP- astrocytes showed a very strong positive correlation (ρ = 0.87, p = 0.0009), suggesting marked gliosis in response to pathology.\nRORB/LRRK1 neurons were negatively correlated (ρ = –0.84, p = 0.002), indicating vulnerability of this excitatory subtype. THEMIS/TMEM233 also showed a negative correlation (ρ = –0.69, p = 0.02), while TLE4/SEMA3D exhibited a positive correlation (ρ = 0.63, p = 0.04), highlighting diverse cell-type-specific responses to STMN2 pathology.\nNotably, some neuropathologies did not exhibit any significant correlations with cell type proportions. Specifically, no cell type showed a statistically significant association with PolyGR or pTDP43 pathology, suggesting that these pathological features may not be strongly linked to changes in the relative abundance of specific cellular populations within the analyzed dataset.\n\n\nCode\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\nlibrary(janitor)\n\ndata &lt;- read_csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/4. CELL PROP CORRELATIONS/C9_spearman_results.csv\")\n\ndata_clean &lt;- data %&gt;% janitor::clean_names()\n\ndatatable(\n  data_clean,\n  options = list(pageLength = 15, scrollX = TRUE),\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(plotly)\nlibrary(tidyverse)\nlibrary(readxl)\n\n# ---------------- Load Data ----------------\nmetadata &lt;- read_xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\ncolnames(metadata)[1] &lt;- \"X\"\nsamples &lt;- metadata$X[metadata$group.ID == \"C9orf72\"]\n\nCRscores &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nCRscores$X &lt;- gsub(\"^X\", \"\", CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples, ]\n\nproportions &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\", row.names = 1)\nrownames(proportions) &lt;- gsub(\"^X\", \"\", rownames(proportions))\n\n# ---- Match samples ----\ncommon_samples &lt;- intersect(rownames(proportions), CRscores$X)\nproportions &lt;- proportions[common_samples, , drop=FALSE]\nCRscores &lt;- CRscores[match(common_samples, CRscores$X), ]\n\ncell_states &lt;- colnames(proportions)\ncovariates  &lt;- setdiff(colnames(CRscores), \"X\")\n\n# ---- Generate all combinations ----\ntraces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), cell_state = character(), covariate = character())\n\nfor (i in seq_along(cell_states)) {\n  for (j in seq_along(covariates)) {\n    cs &lt;- cell_states[i]\n    cv &lt;- covariates[j]\n    df &lt;- tibble(\n      sample = common_samples,\n      x = CRscores[[cv]],\n      y = proportions[[cs]]\n    ) %&gt;% drop_na()\n\n    if (nrow(df) &lt; 3) next  # skip insufficient points\n\n    rho &lt;- suppressWarnings(cor(df$x, df$y, method=\"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method=\"spearman\")$p.value)\n    fit &lt;- lm(y ~ x, data=df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out=100))\n    line_df$y &lt;- predict(fit, newdata=line_df)\n\n    # Scatter trace\n    traces &lt;- append(traces, list(\n      list(\n        type = \"scatter\",\n        mode = \"markers\",\n        x = df$x,\n        y = df$y,\n        name = paste(cs, cv),\n        text = paste0(\"&lt;b&gt;\", cs, \" vs \", cv, \"&lt;/b&gt;&lt;br&gt;\",\n                      \"ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n        hoverinfo = \"text\",\n        marker = list(size = 8, opacity = 0.7),\n        visible = (i == 1 && j == 1)\n      )\n    ))\n\n    # Regression line trace\n    traces &lt;- append(traces, list(\n      list(\n        type = \"scatter\",\n        mode = \"lines\",\n        x = line_df$x,\n        y = line_df$y,\n        line = list(color = \"firebrick\", width = 2),\n        showlegend = FALSE,\n        hoverinfo = \"none\",\n        visible = (i == 1 && j == 1)\n      )\n    ))\n\n    meta &lt;- add_row(meta,\n                    trace_id = length(traces) - 1,\n                    cell_state = cs,\n                    covariate = cv)\n  }\n}\n\n# ---- Helper: compute which traces to show ----\nmake_visibility &lt;- function(cs, cv) {\n  vis &lt;- rep(FALSE, length(traces))\n  idx &lt;- which(meta$cell_state == cs & meta$covariate == cv)\n  if (length(idx) == 1) {\n    # each combination has 2 traces (points + line)\n    start &lt;- (idx - 1) * 2 + 1\n    vis[start:(start + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ---- Create dropdown menus ----\nbuttons &lt;- list()\nk &lt;- 1\nfor (i in seq_along(cell_states)) {\n  for (j in seq_along(covariates)) {\n    cs &lt;- cell_states[i]\n    cv &lt;- covariates[j]\n    buttons[[k]] &lt;- list(\n      method = \"update\",\n      args = list(list(visible = make_visibility(cs, cv)),\n                  list(title = paste(\"Cell state:\", cs, \" | Covariate:\", cv))),\n      label = paste(cs, cv)\n    )\n    k &lt;- k + 1\n  }\n}\n\n# ---- Build Plot ----\nfig &lt;- plot_ly()\n\nfor (tr in traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = \"Spearman correlation: Cell-state proportions vs pathology markers\",\n    xaxis = list(title = \"Covariate value\"),\n    yaxis = list(title = \"Cell-state proportion\"),\n    updatemenus = list(\n      list(\n        y = 1.1,\n        x = 0,\n        buttons = buttons,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\",\n        yanchor = \"top\",\n        title = list(text = \"Select cell state + covariate\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate &lt;- function(cv){\n\n  metadata &lt;- read_xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\n  colnames(metadata)[1] &lt;- \"X\"\n  samples &lt;- metadata$X[metadata$group.ID == \"C9orf72\"]\n\n  CRscores &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\n  CRscores$X &lt;- gsub(\"^X\", \"\", CRscores$X)\n  CRscores &lt;- CRscores[CRscores$X %in% samples, ]\n\n  proportions &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\",\n                          row.names = 1)\n  rownames(proportions) &lt;- gsub(\"^X\", \"\", rownames(proportions))\n\n  # Match samples\n  common_samples &lt;- intersect(rownames(proportions), CRscores$X)\n  proportions &lt;- proportions[common_samples, , drop=FALSE]\n  CRscores &lt;- CRscores[match(common_samples, CRscores$X), ]\n\n  cell_states &lt;- colnames(proportions)\n\n  # Store actual trace indices for each selectable cell state\n  trace_map &lt;- list()\n  fig &lt;- plot_ly()\n  trace_index &lt;- 0   # count of traces added\n\n  for (cs in cell_states) {\n\n    df &lt;- tibble(\n      x = CRscores[[cv]],\n      y = proportions[[cs]]\n    ) %&gt;% drop_na()\n\n    if (nrow(df) &lt; 3) next\n\n    # regression line\n    fit &lt;- lm(y ~ x, data=df)\n    line_df &lt;- tibble(\n      x = seq(min(df$x), max(df$x), length.out=100),\n      y = predict(fit, newdata=list(x = seq(min(df$x), max(df$x), length.out=100)))\n    )\n\n    # ---- ADD POINTS ----\n    fig &lt;- fig %&gt;% add_markers(\n      data = df,\n      x = ~x, y = ~y,\n      name = cs,\n      visible = (length(trace_map) == 0),\n      marker = list(size=9, opacity=0.7)\n    )\n    trace_index &lt;- trace_index + 1\n    points_trace &lt;- trace_index\n\n    # ---- ADD LINE ----\n    fig &lt;- fig %&gt;% add_lines(\n      data = line_df,\n      x = ~x, y = ~y,\n      showlegend = FALSE,\n      visible = (length(trace_map) == 0),\n      line = list(color=\"firebrick\")\n    )\n    trace_index &lt;- trace_index + 1\n    line_trace &lt;- trace_index\n\n    # Store mapping for dropdown\n    trace_map[[cs]] &lt;- c(points_trace, line_trace)\n  }\n\n  # ---- BUILD DROPDOWN ----\n  buttons &lt;- list()\n  total_traces &lt;- trace_index\n\n  for (i in seq_along(trace_map)) {\n    cs &lt;- names(trace_map)[i]\n\n    vis &lt;- rep(FALSE, total_traces)\n    vis[trace_map[[cs]]] &lt;- TRUE\n\n    buttons[[i]] &lt;- list(\n      method = \"update\",\n      label = cs,\n      args = list(\n        list(visible = vis),\n        list(title = paste(cv, \"—\", cs))\n      )\n    )\n  }\n\n  # ---- FINAL PLOT ----\n  fig %&gt;% layout(\n    title = paste(\"Correlation of\", cv, \"with cell-state proportions\"),\n    xaxis = list(title=cv),\n    yaxis = list(title=\"Cell-state proportion\"),\n    updatemenus = list(\n      list(\n        type=\"dropdown\",\n        buttons=buttons,\n        x=0, y=1.15,\n        showactive=TRUE\n      )\n    )\n  )\n}\n\n\n\n\nCode\nmake_plot_for_covariate(\"pTDP43\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"STMN2\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"ACSL3\")\n\n\n\n\n\n\n###lncRNA\n\n\nCode\nmake_plot_for_covariate(\"lncRNA\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"fociSENSE\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"fociANTI\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"polyGP\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"polyGA\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"polyGR\")"
  },
  {
    "objectID": "Results/Cell_correlation.html#c9-sant-pau",
    "href": "Results/Cell_correlation.html#c9-sant-pau",
    "title": "Cell composition correlation with neuropathology",
    "section": "",
    "text": "The neurpopathology markers identifyed in C9orf72 cases were ACSL3 FociANTI, FociSENSE, lncRNA, PolyGA, PolyGP, PolyGR, STMN2 and burden TDP43 and for the TDP43 cases STMN2 and burden TDP43 only.\nIn FTLD-C9orf72 cell composition association with neuropathology we find the following correlations on each marker. Changes in ACSL3 levels point to altered lipid metabolism seen in C9orf72-associated FTLD.\nSeveral cell types exhibited significant correlations with ACSL3 pathology. OPC cell type is found to be the most correlated cell type(ρ = 0.78, p = 0.007), showing an increase in their proportion with ACSL3 density. Notably, RORB/ADGRL4 (ρ = –0.65, p = 0.03) and RORB/LRRK1 (ρ = –0.63, p = 0.04), excitatory neurons showed a strong negative correlation, suggesting a reduction in this subtypes in cases with greater aggregate burden.\nIn contrast, GFAP - astrocytes exhibited a positive correlation with ACSL3 load (ρ = 0.64, p = 0.03), indicating an expansion of this glial population in more affected individuals. Antisense RNA foci from the repeat expansion similarly disrupt RNA metabolism in FTLD. One cell type exhibited significant correlation with fociANTI pathology. The non transformed PCP4/NXPH2 cell type showed a negative correlation with fociANTI load (ρ = –0.69, p = 0.019), suggesting a reduction in this population in more affected individuals. Non transformed fociSENSE RNA from the expanded C9orf72 repeat sequester RNA-binding proteins, contributing to FTLD pathology.\nSeveral cell types exhibited significant correlations with fociSENSE pathology. PCP4/NXPH2 exhibited a strong negative correlation (ρ = –0.70, p = 0.01), while PVALB/MYBPC1 showed a similarly strong positive correlation (ρ = 0.70, p = 0.01). Pericyte cells were also negatively correlated (ρ = –0.70, p = 0.02), indicating a decrease in their proportion with increased pathology. Conversely, VIP/LAMA3 (ρ = 0.65, p = 0.03) and capillary cells (ρ = 0.65, p = 0.03) showed positive correlations, suggesting their expansion in higher pathology cases.\nAdditionally, RORB/LRRK1 (ρ = –0.63, p = 0.04) and PVALB/CEMIP (ρ = 0.62, p = 0.04) were significantly associated, indicating subtype-specific vulnerability. Dysregulation of specific long non-coding RNAs is linked to RNA toxicity from C9orf72 repeat expansions in FTLD. Several cell types exhibited significant correlations with lncRNA pathology. RORB/FOXO1 displayed a very strong positive correlation (ρ = 0.93, p = 0.00), suggesting a marked increase in this subtype with higher pathology.\nIn contrast, Oligodendrocytes showed a negative correlation (ρ = –0.68, p = 0.02), as did THEMIS/NR4A2 neurons (ρ = –0.63, p = 0.04), indicating a decrease in these populations in more affected individuals. THEMIS/TMEM233 neurons were significantly positively correlated with polyGA pathology (ρ = 0.63, p = 0.04), suggesting an expansion of this subtype in individuals with greater aggregate burden.\nTwo cell types exhibited significant correlations with polyGP pathology. THEMIS/TMEM233 (ρ = 0.66, p = 0.03) and TLE4/CCBE1 (ρ = 0.63, p = 0.04) both demonstrated positive correlations, indicating an increased presence of these excitatory neuron subtypes in relation to pathology load. Reduced STMN2 expression reflects TDP-43–related cryptic splicing, a hallmark of FTLD with C9orf72 expansion. Several cell types exhibited significant correlations with STMN2 pathology. GFAP- astrocytes showed a very strong positive correlation (ρ = 0.87, p = 0.0009), suggesting marked gliosis in response to pathology.\nRORB/LRRK1 neurons were negatively correlated (ρ = –0.84, p = 0.002), indicating vulnerability of this excitatory subtype. THEMIS/TMEM233 also showed a negative correlation (ρ = –0.69, p = 0.02), while TLE4/SEMA3D exhibited a positive correlation (ρ = 0.63, p = 0.04), highlighting diverse cell-type-specific responses to STMN2 pathology.\nNotably, some neuropathologies did not exhibit any significant correlations with cell type proportions. Specifically, no cell type showed a statistically significant association with PolyGR or pTDP43 pathology, suggesting that these pathological features may not be strongly linked to changes in the relative abundance of specific cellular populations within the analyzed dataset.\n\n\nCode\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\nlibrary(janitor)\n\ndata &lt;- read_csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/4. CELL PROP CORRELATIONS/C9_spearman_results.csv\")\n\ndata_clean &lt;- data %&gt;% janitor::clean_names()\n\ndatatable(\n  data_clean,\n  options = list(pageLength = 15, scrollX = TRUE),\n  rownames = FALSE\n)\n\n\n\n\n\n\n\n\nCode\nlibrary(plotly)\nlibrary(tidyverse)\nlibrary(readxl)\n\n# ---------------- Load Data ----------------\nmetadata &lt;- read_xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\ncolnames(metadata)[1] &lt;- \"X\"\nsamples &lt;- metadata$X[metadata$group.ID == \"C9orf72\"]\n\nCRscores &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\nCRscores$X &lt;- gsub(\"^X\", \"\", CRscores$X)\nCRscores &lt;- CRscores[CRscores$X %in% samples, ]\n\nproportions &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\", row.names = 1)\nrownames(proportions) &lt;- gsub(\"^X\", \"\", rownames(proportions))\n\n# ---- Match samples ----\ncommon_samples &lt;- intersect(rownames(proportions), CRscores$X)\nproportions &lt;- proportions[common_samples, , drop=FALSE]\nCRscores &lt;- CRscores[match(common_samples, CRscores$X), ]\n\ncell_states &lt;- colnames(proportions)\ncovariates  &lt;- setdiff(colnames(CRscores), \"X\")\n\n# ---- Generate all combinations ----\ntraces &lt;- list()\nmeta &lt;- tibble(trace_id = integer(), cell_state = character(), covariate = character())\n\nfor (i in seq_along(cell_states)) {\n  for (j in seq_along(covariates)) {\n    cs &lt;- cell_states[i]\n    cv &lt;- covariates[j]\n    df &lt;- tibble(\n      sample = common_samples,\n      x = CRscores[[cv]],\n      y = proportions[[cs]]\n    ) %&gt;% drop_na()\n\n    if (nrow(df) &lt; 3) next  # skip insufficient points\n\n    rho &lt;- suppressWarnings(cor(df$x, df$y, method=\"spearman\"))\n    pval &lt;- suppressWarnings(cor.test(df$x, df$y, method=\"spearman\")$p.value)\n    fit &lt;- lm(y ~ x, data=df)\n    line_df &lt;- tibble(x = seq(min(df$x), max(df$x), length.out=100))\n    line_df$y &lt;- predict(fit, newdata=line_df)\n\n    # Scatter trace\n    traces &lt;- append(traces, list(\n      list(\n        type = \"scatter\",\n        mode = \"markers\",\n        x = df$x,\n        y = df$y,\n        name = paste(cs, cv),\n        text = paste0(\"&lt;b&gt;\", cs, \" vs \", cv, \"&lt;/b&gt;&lt;br&gt;\",\n                      \"ρ = \", round(rho, 3), \"&lt;br&gt;p = \", signif(pval, 3)),\n        hoverinfo = \"text\",\n        marker = list(size = 8, opacity = 0.7),\n        visible = (i == 1 && j == 1)\n      )\n    ))\n\n    # Regression line trace\n    traces &lt;- append(traces, list(\n      list(\n        type = \"scatter\",\n        mode = \"lines\",\n        x = line_df$x,\n        y = line_df$y,\n        line = list(color = \"firebrick\", width = 2),\n        showlegend = FALSE,\n        hoverinfo = \"none\",\n        visible = (i == 1 && j == 1)\n      )\n    ))\n\n    meta &lt;- add_row(meta,\n                    trace_id = length(traces) - 1,\n                    cell_state = cs,\n                    covariate = cv)\n  }\n}\n\n# ---- Helper: compute which traces to show ----\nmake_visibility &lt;- function(cs, cv) {\n  vis &lt;- rep(FALSE, length(traces))\n  idx &lt;- which(meta$cell_state == cs & meta$covariate == cv)\n  if (length(idx) == 1) {\n    # each combination has 2 traces (points + line)\n    start &lt;- (idx - 1) * 2 + 1\n    vis[start:(start + 1)] &lt;- TRUE\n  }\n  vis\n}\n\n# ---- Create dropdown menus ----\nbuttons &lt;- list()\nk &lt;- 1\nfor (i in seq_along(cell_states)) {\n  for (j in seq_along(covariates)) {\n    cs &lt;- cell_states[i]\n    cv &lt;- covariates[j]\n    buttons[[k]] &lt;- list(\n      method = \"update\",\n      args = list(list(visible = make_visibility(cs, cv)),\n                  list(title = paste(\"Cell state:\", cs, \" | Covariate:\", cv))),\n      label = paste(cs, cv)\n    )\n    k &lt;- k + 1\n  }\n}\n\n# ---- Build Plot ----\nfig &lt;- plot_ly()\n\nfor (tr in traces) {\n  fig &lt;- fig %&gt;% add_trace(\n    type = tr$type,\n    mode = tr$mode,\n    x = tr$x,\n    y = tr$y,\n    name = tr$name,\n    text = tr$text,\n    hoverinfo = tr$hoverinfo,\n    marker = tr$marker,\n    line = tr$line,\n    visible = tr$visible\n  )\n}\n\nfig &lt;- fig %&gt;%\n  layout(\n    title = \"Spearman correlation: Cell-state proportions vs pathology markers\",\n    xaxis = list(title = \"Covariate value\"),\n    yaxis = list(title = \"Cell-state proportion\"),\n    updatemenus = list(\n      list(\n        y = 1.1,\n        x = 0,\n        buttons = buttons,\n        direction = \"down\",\n        showactive = TRUE,\n        xanchor = \"left\",\n        yanchor = \"top\",\n        title = list(text = \"Select cell state + covariate\")\n      )\n    )\n  )\n\nfig\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate &lt;- function(cv){\n\n  metadata &lt;- read_xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\n  colnames(metadata)[1] &lt;- \"X\"\n  samples &lt;- metadata$X[metadata$group.ID == \"C9orf72\"]\n\n  CRscores &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_C9_neuropath_SOM.csv\")\n  CRscores$X &lt;- gsub(\"^X\", \"\", CRscores$X)\n  CRscores &lt;- CRscores[CRscores$X %in% samples, ]\n\n  proportions &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/theta.state_cellstate.csv\",\n                          row.names = 1)\n  rownames(proportions) &lt;- gsub(\"^X\", \"\", rownames(proportions))\n\n  # Match samples\n  common_samples &lt;- intersect(rownames(proportions), CRscores$X)\n  proportions &lt;- proportions[common_samples, , drop=FALSE]\n  CRscores &lt;- CRscores[match(common_samples, CRscores$X), ]\n\n  cell_states &lt;- colnames(proportions)\n\n  # Store actual trace indices for each selectable cell state\n  trace_map &lt;- list()\n  fig &lt;- plot_ly()\n  trace_index &lt;- 0   # count of traces added\n\n  for (cs in cell_states) {\n\n    df &lt;- tibble(\n      x = CRscores[[cv]],\n      y = proportions[[cs]]\n    ) %&gt;% drop_na()\n\n    if (nrow(df) &lt; 3) next\n\n    # regression line\n    fit &lt;- lm(y ~ x, data=df)\n    line_df &lt;- tibble(\n      x = seq(min(df$x), max(df$x), length.out=100),\n      y = predict(fit, newdata=list(x = seq(min(df$x), max(df$x), length.out=100)))\n    )\n\n    # ---- ADD POINTS ----\n    fig &lt;- fig %&gt;% add_markers(\n      data = df,\n      x = ~x, y = ~y,\n      name = cs,\n      visible = (length(trace_map) == 0),\n      marker = list(size=9, opacity=0.7)\n    )\n    trace_index &lt;- trace_index + 1\n    points_trace &lt;- trace_index\n\n    # ---- ADD LINE ----\n    fig &lt;- fig %&gt;% add_lines(\n      data = line_df,\n      x = ~x, y = ~y,\n      showlegend = FALSE,\n      visible = (length(trace_map) == 0),\n      line = list(color=\"firebrick\")\n    )\n    trace_index &lt;- trace_index + 1\n    line_trace &lt;- trace_index\n\n    # Store mapping for dropdown\n    trace_map[[cs]] &lt;- c(points_trace, line_trace)\n  }\n\n  # ---- BUILD DROPDOWN ----\n  buttons &lt;- list()\n  total_traces &lt;- trace_index\n\n  for (i in seq_along(trace_map)) {\n    cs &lt;- names(trace_map)[i]\n\n    vis &lt;- rep(FALSE, total_traces)\n    vis[trace_map[[cs]]] &lt;- TRUE\n\n    buttons[[i]] &lt;- list(\n      method = \"update\",\n      label = cs,\n      args = list(\n        list(visible = vis),\n        list(title = paste(cv, \"—\", cs))\n      )\n    )\n  }\n\n  # ---- FINAL PLOT ----\n  fig %&gt;% layout(\n    title = paste(\"Correlation of\", cv, \"with cell-state proportions\"),\n    xaxis = list(title=cv),\n    yaxis = list(title=\"Cell-state proportion\"),\n    updatemenus = list(\n      list(\n        type=\"dropdown\",\n        buttons=buttons,\n        x=0, y=1.15,\n        showactive=TRUE\n      )\n    )\n  )\n}\n\n\n\n\nCode\nmake_plot_for_covariate(\"pTDP43\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"STMN2\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"ACSL3\")\n\n\n\n\n\n\n###lncRNA\n\n\nCode\nmake_plot_for_covariate(\"lncRNA\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"fociSENSE\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"fociANTI\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"polyGP\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"polyGA\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nmake_plot_for_covariate(\"polyGR\")"
  },
  {
    "objectID": "Results/Cell_correlation.html#tdp-sant-pau",
    "href": "Results/Cell_correlation.html#tdp-sant-pau",
    "title": "Cell composition correlation with neuropathology",
    "section": "TDP Sant Pau",
    "text": "TDP Sant Pau\nIn the case of FTLD-TDP cell type proportions associations with neuropathology markers. FTLD-TDP cell types correlation with STMN2 density it is seen a significative negative correlation with different neuronal cell types. TLE4/CCBE1(p = 0.031, ρ = -0.73), CUX2/RORB (p = 0.043, ρ = -0.7), DISC1/RELN (p = 0.043, ρ = -0.7 ).\n\nSeveral cell types exhibited significant correlations with pTDP-43 pathology. Notably, RORB_LRRK1 excitatory neurons showed a strong negative correlation (ρ = –0.766, p = 0.021), suggesting a reduction in this subtype in cases with greater aggregate burden.\nSimilarly, LAMP5_PMEPA1 interneurons were also negatively correlated (ρ = –0.700, p = 0.043). In contrast, GFAP + astrocytes exhibited a positive correlation with pTDP-43 load (ρ = 0.733, p = 0.031), indicating an expansion of this glial population in more affected individuals.\nOther cell types showed nominal correlations but did not reach statistical significance, including RORB_ADGRL4, PVALB_MYBPC1, and Venous endothelial cells. These trends may warrant further investigation in larger cohorts.\n\n\nCode\nlibrary(readr)\nlibrary(dplyr)\nlibrary(DT)\nlibrary(janitor)\n\ndata &lt;- read_csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/4. CELL PROP CORRELATIONS/TDP_spearman_results_2.csv\")\n\ndata_clean &lt;- data %&gt;% janitor::clean_names()\n\ndatatable(\n  data_clean,\n  options = list(pageLength = 15, scrollX = TRUE),\n  rownames = FALSE\n)\n\n\n\n\n\n\n\npTDP43\n\n\nCode\nmake_plot_for_covariate &lt;- function(cv){\n\n  metadata &lt;- read_xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\")\n  colnames(metadata)[1] &lt;- \"X\"\n  samples &lt;- metadata$X[metadata$group.ID == \"TDP\"]\n\n  CRscores &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/FTD_TDP_neuropath_SOM.csv\")\n  CRscores$X &lt;- gsub(\"^long\", \"\", CRscores$X)\n  CRscores &lt;- CRscores[CRscores$X %in% samples, ]\n\n  proportions &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/theta.state_original.csv\",\n                          row.names = 1)\n  rownames(proportions) &lt;- gsub(\"^X\", \"\", rownames(proportions))\n\n  # Match samples\n  common_samples &lt;- intersect(rownames(proportions), CRscores$X)\n  proportions &lt;- proportions[common_samples, , drop=FALSE]\n  CRscores &lt;- CRscores[match(common_samples, CRscores$X), ]\n\n  cell_states &lt;- colnames(proportions)\n\n  # Store actual trace indices for each selectable cell state\n  trace_map &lt;- list()\n  fig &lt;- plot_ly()\n  trace_index &lt;- 0   # count of traces added\n\n  for (cs in cell_states) {\n\n    df &lt;- tibble(\n      x = CRscores[[cv]],\n      y = proportions[[cs]]\n    ) %&gt;% drop_na()\n\n    if (nrow(df) &lt; 3) next\n\n    # regression line\n    fit &lt;- lm(y ~ x, data=df)\n    line_df &lt;- tibble(\n      x = seq(min(df$x), max(df$x), length.out=100),\n      y = predict(fit, newdata=list(x = seq(min(df$x), max(df$x), length.out=100)))\n    )\n\n    # ---- ADD POINTS ----\n    fig &lt;- fig %&gt;% add_markers(\n      data = df,\n      x = ~x, y = ~y,\n      name = cs,\n      visible = (length(trace_map) == 0),\n      marker = list(size=9, opacity=0.7)\n    )\n    trace_index &lt;- trace_index + 1\n    points_trace &lt;- trace_index\n\n    # ---- ADD LINE ----\n    fig &lt;- fig %&gt;% add_lines(\n      data = line_df,\n      x = ~x, y = ~y,\n      showlegend = FALSE,\n      visible = (length(trace_map) == 0),\n      line = list(color=\"firebrick\")\n    )\n    trace_index &lt;- trace_index + 1\n    line_trace &lt;- trace_index\n\n    # Store mapping for dropdown\n    trace_map[[cs]] &lt;- c(points_trace, line_trace)\n  }\n\n  # ---- BUILD DROPDOWN ----\n  buttons &lt;- list()\n  total_traces &lt;- trace_index\n\n  for (i in seq_along(trace_map)) {\n    cs &lt;- names(trace_map)[i]\n\n    vis &lt;- rep(FALSE, total_traces)\n    vis[trace_map[[cs]]] &lt;- TRUE\n\n    buttons[[i]] &lt;- list(\n      method = \"update\",\n      label = cs,\n      args = list(\n        list(visible = vis),\n        list(title = paste(cv, \"—\", cs))\n      )\n    )\n  }\n\n  # ---- FINAL PLOT ----\n  fig %&gt;% layout(\n    title = paste(\"Correlation of\", cv, \"with cell-state proportions\"),\n    xaxis = list(title=cv),\n    yaxis = list(title=\"Cell-state proportion\"),\n    updatemenus = list(\n      list(\n        type=\"dropdown\",\n        buttons=buttons,\n        x=0, y=1.15,\n        showactive=TRUE\n      )\n    )\n  )\n}\nmake_plot_for_covariate(\"TDP43b\")\n\n\n\n\n\n\n\n\nSTMN2\n\n\nCode\nmake_plot_for_covariate(\"STMN2\")"
  },
  {
    "objectID": "Results/Sc_dea_results_C9_2.html",
    "href": "Results/Sc_dea_results_C9_2.html",
    "title": "Single cell difference expression analysis ( C9orf72 )",
    "section": "",
    "text": "Show table\n\n\n\n\n\n\n\nCode\nlibrary(DT)\ncounter &lt;- 1\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_Rimmod.xlsx\"\nsheets &lt;- readxl::excel_sheets(file)\n\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1"
  },
  {
    "objectID": "Results/Sc_dea_results_C9_2.html#rimmod",
    "href": "Results/Sc_dea_results_C9_2.html#rimmod",
    "title": "Single cell difference expression analysis ( C9orf72 )",
    "section": "",
    "text": "Show table\n\n\n\n\n\n\n\nCode\nlibrary(DT)\ncounter &lt;- 1\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_Rimmod.xlsx\"\nsheets &lt;- readxl::excel_sheets(file)\n\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- readxl::read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1"
  },
  {
    "objectID": "Results/Sc_dea_results_TDP_2.html",
    "href": "Results/Sc_dea_results_TDP_2.html",
    "title": "Single cell difference expression analysis ( TDP )",
    "section": "",
    "text": "Show table\n\n\n\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(DT)\ncounter &lt;- 1\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_Pottier.xlsx\"\nsheets &lt;- excel_sheets(file)\n\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1"
  },
  {
    "objectID": "Results/Sc_dea_results_TDP_2.html#pottier",
    "href": "Results/Sc_dea_results_TDP_2.html#pottier",
    "title": "Single cell difference expression analysis ( TDP )",
    "section": "",
    "text": "Show table\n\n\n\n\n\n\n\nCode\nlibrary(readxl)\nlibrary(DT)\ncounter &lt;- 1\nfile &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RESULTS_ORDERED/5. CELL TYPE DEA/ALL_Pottier.xlsx\"\nsheets &lt;- excel_sheets(file)\n\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShow table\n\n\n\n\n\n\n\nCode\ndf &lt;- read_excel(file, sheet = sheets[counter])\n\n# Show filterable interactive table\ndatatable(\n  df,\n  filter = \"top\",      # adds filter boxes on top\n  options = list(\n    pageLength = 25,   # default number of rows per page\n    autoWidth = TRUE,\n    scrollX = TRUE     # horizontal scroll if wide\n  )\n)\n\n\n\n\n\n\nCode\ncounter &lt;- counter+1"
  }
]