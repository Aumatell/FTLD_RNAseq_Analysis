[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FTLD_RNAseq_Analysis",
    "section": "",
    "text": "This Project studies the effects of Frontotemporal lobule degeneration (FTLD) on it’s C9orf72 and sporadic TDP subtypes on transcriptomics."
  },
  {
    "objectID": "Validation/Sc_validation.html#tdp",
    "href": "Validation/Sc_validation.html#tdp",
    "title": "Validation: Single cell analysis",
    "section": "TDP",
    "text": "TDP\n\nSingle cell dea\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Validation/Bulk_validation.html#tdp",
    "href": "Validation/Bulk_validation.html#tdp",
    "title": "Validation: Bulk analysis",
    "section": "TDP",
    "text": "TDP\n\nDifferencial expression"
  },
  {
    "objectID": "Results/Sc_dea_results.html#tdp",
    "href": "Results/Sc_dea_results.html#tdp",
    "title": "Single cell difference expression analysis",
    "section": "TDP",
    "text": "TDP\n\nSant Pau\n\n\nPottier\n\ncell_type_dea &lt;- load_or_placeholder(\n  option_name = \"results_vis.cell_type_dea\",\n  pattern = \"cell.*type.*dea.*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    tibble::tibble(\n      Cluster = rep(paste(\"Cluster\", 1:8), each = 40),\n      Gene = paste0(\"Gene\", seq_len(320)),\n      avg_log2FC = rnorm(320, sd = 0.8),\n      pct_in = runif(320, min = 0, max = 1),\n      pct_out = runif(320, min = 0, max = 1),\n      p_val_adj = p.adjust(runif(320, min = 1e-5, max = 0.5), method = \"BH\")\n    )\n  }\n)\n\n\nrender_source_note(cell_type_dea, \"cell type DEA\")\nplot_ly(\n  cell_type_dea,\n  x = ~avg_log2FC,\n  y = ~-log10(p_val_adj + 1e-12),\n  color = ~Cluster,\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;pct_in:\", sprintf(\"%.1f%%\", pct_in * 100),\n    \"&lt;br&gt;pct_out:\", sprintf(\"%.1f%%\", pct_out * 100)\n  ),\n  type = \"scatter\",\n  mode = \"markers\",\n  hovertemplate = \"%{text}&lt;extra&gt;&lt;/extra&gt;\"\n) %&gt;%\n  layout(title = \"Cell-Type Differential Expression\",\n         xaxis = list(title = \"Average log2 Fold Change\"),\n         yaxis = list(title = \"-log10(adj p-value)\")) %&gt;%\n  annotate_placeholder(cell_type_dea)"
  },
  {
    "objectID": "Results/Hdwgcna_corelation.html",
    "href": "Results/Hdwgcna_corelation.html",
    "title": "Single-cell Gene modules correlation with neuropathology markers",
    "section": "",
    "text": "A &lt;-read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CELL_PROP/FTLD/TDP/significatives_nonparametric_with_means_cs.tsv\")\n\n\n\n# Defineix el directori on tens els fitxers\ndirectori &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS/TDP43\"  \n\n# Llista de fitxers (assumint que són .tsv o .csv, adapta segons calgui)\nfitxers &lt;- list.files(path = directori, pattern = \"\\\\.txt$|\\\\.tsv$|\\\\.csv$\", full.names = TRUE)\n\n# Inicialitza una llista per guardar els resultats\nresultats &lt;- data.frame(\n  fitxer = character(),\n  pvalue_significatius = integer(),\n  total_files = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera sobre cada fitxer\nfor (fitxer in fitxers) {\n  # Llegeix el fitxer (ajusta el separador si cal)\n  taula &lt;- read.csv(fitxer, header = TRUE)\n  \n  # Compta les files amb p.value &lt; 0.05\n  significatius &lt;- sum(taula$p.value &lt; 0.05, na.rm = TRUE)\n  \n  # Compta el total de files\n  total &lt;- nrow(taula)\n  \n  # Afegeix a la taula de resultats\n  resultats &lt;- rbind(resultats, data.frame(\n    fitxer = basename(fitxer),\n    pvalue_significatius = significatius,\n    total_files = total,\n    stringsAsFactors = FALSE\n  ))\n}\n\n# Mostra el resultat\nprint(resultats)\nwrite.csv(resultats, file = \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS/resum_resultats_TDP43.csv\", row.names = FALSE)\n\n\n\n# Defineix el directori on hi ha les carpetes de cell states\ndirectori_base &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS\"  # Canvia això per la teva ruta\n\n# Llista de subcarpetes (cell states)\ncell_states &lt;- list.dirs(path = directori_base, recursive = FALSE, full.names = TRUE)\n\n# Inicialitza la taula de resultats\nresultats &lt;- data.frame(\n  cell_state = character(),\n  pvalue_significatius = integer(),\n  total_moduls = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera per cada carpeta de cell state\nfor (carpeta in cell_states) {\n  fitxer &lt;- file.path(carpeta, \"MODULES/cor_summary.csv\")\n  \n  if (file.exists(fitxer)) {\n    # Llegeix l’arxiu\n    taula &lt;- read.csv(fitxer, header = TRUE)\n    \n    # Compta mòduls significatius\n    significatius &lt;- sum(taula$p.value &lt; 0.05, na.rm = TRUE)\n    \n    # Compta mòduls totals\n    total &lt;- nrow(taula)\n    \n    # Nom del cell state (nom de la carpeta)\n    cell_state_nom &lt;- basename(carpeta)\n    \n    # Afegeix-ho a la taula de resultats\n    resultats &lt;- rbind(resultats, data.frame(\n      cell_state = cell_state_nom,\n      pvalue_significatius = significatius,\n      total_moduls = total,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n# Guarda el resultat en un CSV\nwrite.csv(resultats, file = \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/resum_correlacio_moduls_Healthy_vs_ctrl_CS.csv\", row.names = FALSE)\n\n\n# Defineix el directori base amb les carpetes de tipus cel·lular\ndirectori_base &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS\"  # Substitueix amb la ruta correcta\n\n# Llista de subcarpetes (tipus cel·lular)\ncarpetes &lt;- list.dirs(path = directori_base, recursive = FALSE, full.names = TRUE)\n\n# Inicialitza la taula de resultats\nresultats &lt;- data.frame(\n  tipus_cellular = character(),\n  n_positius = integer(),\n  n_negatius = integer(),\n  stringsAsFactors = FALSE\n)\n\n# Itera per cada carpeta\nfor (carpeta in carpetes) {\n  fitxer &lt;- file.path(carpeta, \"FTLD/results_adj_h.csv\")\n  \n  if (file.exists(fitxer)) {\n    # Llegeix el fitxer\n    taula &lt;- read.csv(fitxer, header = TRUE)\n    \n    # Compta valors 1 i -1 en la columna \"X1.FTLD..1.Control\"\n    positius &lt;- sum(taula$X1.FTLD..1.Control == 1, na.rm = TRUE)\n    negatius &lt;- sum(taula$X1.FTLD..1.Control == -1, na.rm = TRUE)\n    \n    # Nom del tipus cel·lular (nom de la carpeta)\n    nom_cell &lt;- basename(carpeta)\n    \n    # Afegeix a la taula de resultats\n    resultats &lt;- rbind(resultats, data.frame(\n      tipus_cellular = nom_cell,\n      n_positius = positius,\n      n_negatius = negatius,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n# Guarda el resultat en un fitxer CSV\nwrite.csv(resultats, file = \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS/resum_resultats_up_down.csv\", row.names = FALSE)\n\n\n###### VOLCANOPLOTS\nlibrary(ggplot2)\nlibrary(EnhancedVolcano)\nlibrary(tidyverse)\n\nresults_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/CS\"\noutput_dir &lt;- file.path(results_dir, \"volcano_plots\")\ndir.create(output_dir, showWarnings = FALSE)\n\nfiles &lt;- list.files(results_dir, pattern = \"results_adj_h\\\\.csv$\", full.names = TRUE, recursive = TRUE)\n\nfor (file in files) {\n  file_base &lt;- basename(dirname(file))\n  df &lt;- tryCatch({\n    read_csv(file, show_col_types = FALSE)\n  }, error = function(e) {\n    warning(paste(\"Error reading\", file, \":\", e$message))\n    return(NULL)\n  })\n  if (is.null(df)) next\n  colnames(df) &lt;- c(\"Gene\", \"logFC\", \"logCPM\", \"LR\", \"PValue\", \"adj_pval\", \"TDP_vs_Healthy\")\n  required_cols &lt;- c(\"logFC\", \"PValue\", \"adj_pval\", \"Gene\")\n  if (!all(required_cols %in% colnames(df))) {\n    warning(paste(\"Skipping\", file, \"- missing required columns\"))\n    next\n  }\n  df$Gene &lt;- as.character(df$Gene)\n  p &lt;- EnhancedVolcano(df,\n                       lab = df$Gene,\n                       x = 'logFC',\n                       y = 'PValue',\n                       title = paste(\"Volcano Plot -\", file_base),\n                       pCutoff = 0.05,\n                       FCcutoff = 0,\n                       pointSize = 2.5,\n                       labSize = 3.5,\n                       selectLab = df$Gene)\n  ggsave(filename = file.path(output_dir, paste0(file_base, \"_volcano.png\")),\n         plot = p, width = 8, height = 6, dpi = 300)\n}\n\n\ncorrelation_modules &lt;- load_or_placeholder(\n  option_name = \"results_vis.correlation_modules\",\n  pattern = \"module.*correlation.*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    modules &lt;- paste0(\"Module\", seq_len(10))\n    expand_grid(Source = modules, Target = modules) %&gt;%\n      mutate(Correlation = if_else(Source == Target, 1, runif(n(), min = -1, max = 1)))\n  }\n)\n\n\nrender_source_note(correlation_modules, \"module correlations\")\ncorrelation_wide &lt;- correlation_modules %&gt;%\n  tidyr::pivot_wider(names_from = Target, values_from = Correlation)\ncorrelation_matrix &lt;- correlation_wide %&gt;%\n  column_to_rownames(\"Source\") %&gt;%\n  as.matrix()\ncorrelation_hover &lt;- correlation_modules %&gt;%\n  mutate(label = glue::glue(\"{Source} vs {Target}&lt;br&gt;Correlation: {round(Correlation, 2)}\")) %&gt;%\n  tidyr::pivot_wider(names_from = Target, values_from = label) %&gt;%\n  column_to_rownames(\"Source\") %&gt;%\n  as.matrix()\nplot_ly(\n  x = colnames(correlation_matrix),\n  y = rownames(correlation_matrix),\n  z = correlation_matrix,\n  type = \"heatmap\",\n  colors = \"RdBu\",\n  reversescale = TRUE,\n  text = correlation_hover,\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(title = \"Module-Module Correlation Matrix\") %&gt;%\n  annotate_placeholder(correlation_modules)"
  },
  {
    "objectID": "Results/Cell_composition.html#tdp",
    "href": "Results/Cell_composition.html#tdp",
    "title": "Differences in cell composition",
    "section": "TDP",
    "text": "TDP\n\nSant Pau\n\n\nPottier\n\ncell_prop_diff &lt;- load_or_placeholder(\n  option_name = \"results_vis.cell_prop_diff\",\n  pattern = \"cell.*prop.*(diff|difference).*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    tibble::tibble(\n      Group = rep(c(\"Control\", \"FTLD\"), each = 50),\n      CellType = rep(c(\"Astrocyte\", \"Neuron\", \"Microglia\", \"Oligodendrocyte\", \"Endothelial\"), each = 20),\n      Proportion = rbeta(100, shape1 = 2, shape2 = 5)\n    )\n  }\n)\n\n\nrender_source_note(cell_prop_diff, \"cell proportion differences\")\nplot_ly(\n  cell_prop_diff,\n  x = ~Group,\n  y = ~Proportion,\n  color = ~CellType,\n  type = \"box\"\n) %&gt;%\n  layout(title = \"Cell Proportion Differences by Group\",\n         yaxis = list(title = \"Estimated Proportion\")) %&gt;%\n  annotate_placeholder(cell_prop_diff)"
  },
  {
    "objectID": "References/References.html",
    "href": "References/References.html",
    "title": "References",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Methods/Hdwgcna.html",
    "href": "Methods/Hdwgcna.html",
    "title": "Gene modules",
    "section": "",
    "text": "While differential expression identifies gene-level changes associated with FTLD, it does not capture the higher-order organization of transcriptional programs or the coordinated dysregulation of functional gene networks. Neurodegenerative diseases—including FTLD-C9 and FTLD-TDP—are characterized by complex regulatory alterations affecting synaptic systems, glial and immune reactivity, metabolic rewiring, and RNA-processing machinery. These processes are best understood at the module (network) level rather than through isolated transcripts.\nTo resolve network-level biology at cell-state resolution, we applied hdWGCNA, a scalable adaptation of weighted gene co-expression network analysis (WGCNA) optimized for single-cell and pseudobulk data. By applying hdWGCNA to BayesPrism-derived expression matrices, we reconstructed cell-state–specific co-expression networks, enabling detection of modules associated with disease status, neuropathological markers, and lineage-specific vulnerability.\n\n\n\n\n\nFor each cohort (Sant Pau FTLD-C9, Sant Pau FTLD-TDP, Menden et al., Pottier et al.), hdWGCNA was performed independently for every cell state inferred by BayesPrism.\nThe input matrices consisted of:\n\nlog2-transformed counts per million (logCPM),\ngene expression estimates for each sample within each cell state,\nonly genes expressed in at least 5% of samples in that state (to reduce network noise and ensure connectivity).\n\nEach cell state was stored as a pseudobulk Seurat object, enabling hdWGCNA’s native functions for network construction and visualization.\n\n\n\nFollowing standard WGCNA principles, hdWGCNA constructs networks that approximate scale-free topology. For each cell state:\n\nSoft-thresholding power (β) was selected using the scale-free topology criterion (pickSoftThreshold), ensuring:\n\n-   high scale-free fit index,\n\n-   sufficient mean connectivity,\n\n-   biologically interpretable network structure.\n\nAn unsigned network was used for all analyses, allowing detection of both positively and negatively co-expressed gene relationships.\n\n\n\n\nFor each cell state:\n\nA topological overlap matrix quantified shared connectivity between genes.\nHierarchical clustering of TOM dissimilarity produced dendrograms representing gene trees.\nModules were identified using dynamic tree cutting with a merge height threshold of 0.15, enabling detection of:\n\nfine-grained modules in highly heterogeneous states,\nlarge modules in transcriptionally stable lineages.\n\n\nEach module received a unique color annotation.\n\n\n\nA module eigengene (ME)—the first principal component summarizing module expression—was computed for each module.\nFor each cell state and each module:\n\nMEs were compared between FTLD-C9 or FTLD-TDP and controls to identify disease-associated modules using linear models.\n\nMEs were correlated (Spearman) with:\n\n-   **neuropathological markers** (ACSL3, lncRNAs, RNA foci sense/antisense, polyGA, polyGP, polyGR, pTDP-43, STMN2)\n\n-   **diagnostic group**\n\n-   **cell-state proportions**.\nThis yielded marker-associated modules, capturing functional programs linked to pathological burden.\nModules were ranked by:\n\ncorrelation magnitude,\np-value,\nbiological coherence,\nnumber of hub genes.\n\n\n\n\nHub genes for each module were identified using:\n\nkME (module membership),\ncorrelation of each gene with the corresponding eigengene.\n\nGenes with kME ≥ 0.90 were classified as high-confidence hub genes.\nThese anchors define the regulatory core of each transcriptional module.\n\n\n\nFor each significantly disease-associated module:\n\nGene Ontology enrichment was performed using Metascape, restricted to:\n\n-   Biological Process\n\n-   Molecular Function\n\n-    Cellular Component\nBackground sets were defined as:\n\nAll genes expressed in that cell state (from Pineda et al. reference).\n\nThis ensured biologically appropriate enrichment interpretations.\nEnrichment pinpointed:\n\nsynaptic processes,\nimmune and inflammatory pathways,\nRNA metabolism,\napoptotic signaling,\nvascular remodeling,\nglial activation states.\n\n\n\n\nFor module validation:\n\nGene lists from modules identified in Sant Pau cohorts were compared with those obtained from Menden et al. (for FTLD-C9) or Pottier et al. (for FTLD-TDP).\nOverlap statistics were computed using:\n\nGeneOverlap tests,\nJaccard indices,\ndirectionality of eigengene changes.\n\n\nA module was considered validated if:\n\nit showed significant gene overlap (p &lt; 0.05), and\nthe eigengene change direction matched between cohorts.\n\n\n\n\n\nThe hdWGCNA pipeline was designed to:\n\nIdentify cell-state–specific transcriptional modules that distinguish FTLD-C9, FTLD-TDP, and healthy cortex.\nReveal convergent and divergent network-level changes between genetic and sporadic FTLD subtypes.\nMap disease-associated pathways (synaptic signaling, immune activation, metabolic programs) to their cellular origins.\nIntegrate pathology burden (e.g., pTDP-43, STMN2 loss, DPR accumulation, RNA foci density) with module activities.\nDetect hub genes representing potential mechanistic drivers or biomarkers.\nValidate transcriptional networks across independent external datasets.\nProvide a systems-level framework for interpreting FTLD pathophysiology beyond individual DEGs.\n\n\n# single-cell analysis package\nlibrary(Seurat)\n\n# plotting and data science packages\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(patchwork)\n\n# co-expression network analysis packages:\nlibrary(WGCNA)\nlibrary(hdWGCNA)\n\n# paralel processing\nlibrary(fs)\nlibrary(future.apply)\n\n# Configurar sessio\nplan(multisession, workers = parallel::detectCores() - 1)\ntheme_set(theme_cowplot())\nset.seed(12345)\nenableWGCNAThreads(nThreads = 8)\n\n# Directori d'entrada i sortida\ninput_dir &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/25_09/FC/Rimod_C9/CELL STATE/\"\noutput_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS/\"\n\nif (!dir_exists(output_dir)) dir_create(output_dir)\ncsv_files &lt;- dir_ls(input_dir, glob = \"*.csv\")\n\nWGCNA_pseudobulk &lt;- function(file) {\n  tryCatch({\n    \n    # Obtenir el nom base de l'arxiu sense extensió\n    sample_name &lt;- path_ext_remove(path_file(file))\n    sample_output_dir &lt;- file.path(output_dir, sample_name)\n    \n    if (!dir_exists(sample_output_dir)) dir_create(sample_output_dir)\n    \n    message(\"Processing sample: \", sample_name)\n    \n    # Carregar dades en format CSV\n    sc_data &lt;- read.csv(file, row.names = 1)\n    \n    # Convertir a objecte Seurat\n    seurat_obj &lt;- CreateSeuratObject(counts = t(sc_data))\n    seurat_obj &lt;- SeuratObject::UpdateSeuratObject(seurat_obj)\n    \n    seurat_obj@meta.data$Sample &lt;- rownames(sc_data)\n    seurat_obj@meta.data$cell_type &lt;- sample_name\n    \n    seurat_obj &lt;- SetupForWGCNA(\n      seurat_obj,\n      gene_select = \"fraction\",\n      fraction = 0.05,\n      wgcna_name = \"pseudobulk\"\n    )\n    \n    message(\"Selected genes: \", length(GetWGCNAGenes(seurat_obj)))\n    \n    # log2CPM normalization\n    cpm &lt;- t(apply(sc_data, 1, function(x) {\n      y &lt;- x / sum(x) * 1e6\n      log2(y + 1)\n    }))\n    \n    seurat_obj &lt;- SetDatExpr(seurat_obj, mat = cpm)\n    seurat_obj@assays$RNA$data &lt;- t(cpm)\n    \n    # Soft thresholding\n    seurat_obj &lt;- TestSoftPowers(seurat_obj)\n    \n    # Save power plot\n    png(file.path(sample_output_dir, \"soft_power.png\"), width = 1000, height = 800)\n    PlotSoftPowers(seurat_obj)\n    dev.off()\n    \n    # Construct network\n    seurat_obj &lt;- ConstructNetwork(\n      seurat_obj,\n      tom_name = \"pseudobulk\",\n      overwrite_tom = TRUE,\n      mergeCutHeight = 0.25\n    )\n    \n    # Dendrogram\n    png(file.path(sample_output_dir, \"dendrogram.png\"), width = 1000, height = 800)\n    PlotDendrogram(seurat_obj, main = \"pseudobulk dendrogram\")\n    dev.off()\n    \n    # Eigengenes and connectivity\n    seurat_obj &lt;- ModuleEigengenes(seurat_obj, npcs = 2)\n    seurat_obj &lt;- ModuleConnectivity(seurat_obj)\n    \n    # DotPlot of MEs\n    MEs &lt;- GetMEs(seurat_obj)\n    mods &lt;- setdiff(colnames(MEs), \"grey\")\n    meta &lt;- seurat_obj@meta.data\n    seurat_obj@meta.data &lt;- cbind(meta, MEs)\n    \n    p_dot &lt;- DotPlot(seurat_obj, features = mods, group.by = \"cell_type\") +\n      RotatedAxis() +\n      scale_color_gradient(high = \"red\", low = \"grey95\") +\n      xlab(\"\") + ylab(\"\")\n    \n    png(file.path(sample_output_dir, \"dotplot_MEs.png\"), width = 1000, height = 800)\n    print(p_dot)\n    dev.off()\n    \n    # Reset metadata\n    seurat_obj@meta.data &lt;- meta\n    \n    # UMAP\n    seurat_obj &lt;- RunModuleUMAP(\n      seurat_obj,\n      n_hubs = 5,\n      n_neighbors = 10,\n      min_dist = 0.4,\n      spread = 3,\n      supervised = TRUE,\n      target_weight = 0.3\n    )\n    \n    umap_df &lt;- GetModuleUMAP(seurat_obj)\n    centroid_df &lt;- umap_df %&gt;%\n      dplyr::group_by(module) %&gt;%\n      dplyr::summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))\n    \n    p_umap &lt;- ggplot(umap_df, aes(x = UMAP1, y = UMAP2)) +\n      geom_point(color = umap_df$color, size = umap_df$kME * 2) +\n      geom_label(data = centroid_df, label = as.character(centroid_df$module),\n                 fontface = \"bold\", size = 2) +\n      umap_theme() +\n      theme(panel.background = element_rect(fill = \"black\"))\n    \n    png(file.path(sample_output_dir, \"umap_modules.png\"), width = 1000, height = 800)\n    print(p_umap)\n    dev.off()\n    \n    # Save the final Seurat object\n    saveRDS(seurat_obj, file = file.path(sample_output_dir, paste0(sample_name, \"_seurat.rds\")))\n    \n    message(\"Finished processing: \", sample_name)\n    \n  }, error = function(e) {\n    message(\"⚠️ Error in sample: \", file)\n    message(\"Details: \", e$message)\n  })\n}\n\n\n\n\n#future_lapply(csv_files, WGCNA_pseudobulk, future.seed = TRUE)\nfor (file in csv_files){\n  WGCNA_pseudobulk(file)\n}\n\n\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load and prepare metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize and merge metadata\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    \n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Correlation of MEs with group.ID\n    cor_results &lt;- apply(MEs, 2, function(module) {\n      cor.test(module, as.numeric(as.factor(A@meta.data$group.ID)), \n               method = \"spearman\", exact = TRUE)\n    })\n    \n    cor_df &lt;- data.frame(\n      module = names(cor_results),\n      cor = sapply(cor_results, function(x) x$estimate),\n      p.value = sapply(cor_results, function(x) x$p.value)\n    )\n    \n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory if not exists\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    \n    sig_modules &lt;- cor_df_sorted$module[cor_df_sorted$p.value &lt; 0.05]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    print(paste0(\"Finished: \", CS))\n    \n  }) # end try\n}\n\n\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize sample names\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Ensure sample order matches between MEs and metadata\n    sample_order &lt;- rownames(MEs)\n    # Ensure consistent factor order: Healthy (control), TDP (case)\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, A@meta.data$Sample), \"group.ID\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and calculate fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir,mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(hdWGCNA)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\", \n                           row.names = 1, sep = \"\\t\")\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- gsub(\"-\", \"\\\\.\",rownames(metadata_df))\n    rownames(metadata_df) &lt;- metadata_df$Sample_clean \n    # Filter out FTLD-TDP-C and recode group labels\n    metadata_df &lt;- metadata_df[metadata_df$GROUP != \"FTLD-TDP-C\", ]\n    metadata_df$GROUP &lt;- ifelse(metadata_df$GROUP == \"Control\", \"Healthy\", \"TDP\")\n    \n    samples_to_keep &lt;- intersect(rownames(A@meta.data), metadata_df$Sample_clean)\n    A &lt;- subset(A,cells= samples_to_keep)\n                \n    # Harmonize and merge metadata\n    A@meta.data &lt;- metadata_df\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    samples_in_A &lt;- rownames(A@meta.data)\n    MEs &lt;- MEs[rownames(MEs) %in% samples_in_A, ]\n    sample_order &lt;- rownames(MEs)\n    \n    # Ensure correct group assignment order\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, rownames(A@meta.data)), \"GROUP\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and compute fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    # Compile and sort results\n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\n############################## Correlation MEs VS Covariables ###############################\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"long\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n\n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"7BLACK\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"TDP43b\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS_asin_moduletraitcorrelation_tdp43b_tdp/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n#      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n#      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}\n\n\n\n############################## Correlation MEs VS Covariables ###############################\n\n# C9 \n\n# Must change the covariable name for each case.\n\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"X\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n      \n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      # A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      # if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"pTDP43\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/C9/CS_Moduletraitcorrelations_Asin_pTDP43/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n      #      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n      #      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}"
  },
  {
    "objectID": "Methods/Hdwgcna.html#rationale",
    "href": "Methods/Hdwgcna.html#rationale",
    "title": "Gene modules",
    "section": "",
    "text": "While differential expression identifies gene-level changes associated with FTLD, it does not capture the higher-order organization of transcriptional programs or the coordinated dysregulation of functional gene networks. Neurodegenerative diseases—including FTLD-C9 and FTLD-TDP—are characterized by complex regulatory alterations affecting synaptic systems, glial and immune reactivity, metabolic rewiring, and RNA-processing machinery. These processes are best understood at the module (network) level rather than through isolated transcripts.\nTo resolve network-level biology at cell-state resolution, we applied hdWGCNA, a scalable adaptation of weighted gene co-expression network analysis (WGCNA) optimized for single-cell and pseudobulk data. By applying hdWGCNA to BayesPrism-derived expression matrices, we reconstructed cell-state–specific co-expression networks, enabling detection of modules associated with disease status, neuropathological markers, and lineage-specific vulnerability."
  },
  {
    "objectID": "Methods/Hdwgcna.html#analytical-strategy",
    "href": "Methods/Hdwgcna.html#analytical-strategy",
    "title": "Gene modules",
    "section": "",
    "text": "For each cohort (Sant Pau FTLD-C9, Sant Pau FTLD-TDP, Menden et al., Pottier et al.), hdWGCNA was performed independently for every cell state inferred by BayesPrism.\nThe input matrices consisted of:\n\nlog2-transformed counts per million (logCPM),\ngene expression estimates for each sample within each cell state,\nonly genes expressed in at least 5% of samples in that state (to reduce network noise and ensure connectivity).\n\nEach cell state was stored as a pseudobulk Seurat object, enabling hdWGCNA’s native functions for network construction and visualization.\n\n\n\nFollowing standard WGCNA principles, hdWGCNA constructs networks that approximate scale-free topology. For each cell state:\n\nSoft-thresholding power (β) was selected using the scale-free topology criterion (pickSoftThreshold), ensuring:\n\n-   high scale-free fit index,\n\n-   sufficient mean connectivity,\n\n-   biologically interpretable network structure.\n\nAn unsigned network was used for all analyses, allowing detection of both positively and negatively co-expressed gene relationships.\n\n\n\n\nFor each cell state:\n\nA topological overlap matrix quantified shared connectivity between genes.\nHierarchical clustering of TOM dissimilarity produced dendrograms representing gene trees.\nModules were identified using dynamic tree cutting with a merge height threshold of 0.15, enabling detection of:\n\nfine-grained modules in highly heterogeneous states,\nlarge modules in transcriptionally stable lineages.\n\n\nEach module received a unique color annotation.\n\n\n\nA module eigengene (ME)—the first principal component summarizing module expression—was computed for each module.\nFor each cell state and each module:\n\nMEs were compared between FTLD-C9 or FTLD-TDP and controls to identify disease-associated modules using linear models.\n\nMEs were correlated (Spearman) with:\n\n-   **neuropathological markers** (ACSL3, lncRNAs, RNA foci sense/antisense, polyGA, polyGP, polyGR, pTDP-43, STMN2)\n\n-   **diagnostic group**\n\n-   **cell-state proportions**.\nThis yielded marker-associated modules, capturing functional programs linked to pathological burden.\nModules were ranked by:\n\ncorrelation magnitude,\np-value,\nbiological coherence,\nnumber of hub genes.\n\n\n\n\nHub genes for each module were identified using:\n\nkME (module membership),\ncorrelation of each gene with the corresponding eigengene.\n\nGenes with kME ≥ 0.90 were classified as high-confidence hub genes.\nThese anchors define the regulatory core of each transcriptional module.\n\n\n\nFor each significantly disease-associated module:\n\nGene Ontology enrichment was performed using Metascape, restricted to:\n\n-   Biological Process\n\n-   Molecular Function\n\n-    Cellular Component\nBackground sets were defined as:\n\nAll genes expressed in that cell state (from Pineda et al. reference).\n\nThis ensured biologically appropriate enrichment interpretations.\nEnrichment pinpointed:\n\nsynaptic processes,\nimmune and inflammatory pathways,\nRNA metabolism,\napoptotic signaling,\nvascular remodeling,\nglial activation states.\n\n\n\n\nFor module validation:\n\nGene lists from modules identified in Sant Pau cohorts were compared with those obtained from Menden et al. (for FTLD-C9) or Pottier et al. (for FTLD-TDP).\nOverlap statistics were computed using:\n\nGeneOverlap tests,\nJaccard indices,\ndirectionality of eigengene changes.\n\n\nA module was considered validated if:\n\nit showed significant gene overlap (p &lt; 0.05), and\nthe eigengene change direction matched between cohorts."
  },
  {
    "objectID": "Methods/Hdwgcna.html#analytical-goals-of-the-hdwgcna-component",
    "href": "Methods/Hdwgcna.html#analytical-goals-of-the-hdwgcna-component",
    "title": "Gene modules",
    "section": "",
    "text": "The hdWGCNA pipeline was designed to:\n\nIdentify cell-state–specific transcriptional modules that distinguish FTLD-C9, FTLD-TDP, and healthy cortex.\nReveal convergent and divergent network-level changes between genetic and sporadic FTLD subtypes.\nMap disease-associated pathways (synaptic signaling, immune activation, metabolic programs) to their cellular origins.\nIntegrate pathology burden (e.g., pTDP-43, STMN2 loss, DPR accumulation, RNA foci density) with module activities.\nDetect hub genes representing potential mechanistic drivers or biomarkers.\nValidate transcriptional networks across independent external datasets.\nProvide a systems-level framework for interpreting FTLD pathophysiology beyond individual DEGs.\n\n\n# single-cell analysis package\nlibrary(Seurat)\n\n# plotting and data science packages\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(patchwork)\n\n# co-expression network analysis packages:\nlibrary(WGCNA)\nlibrary(hdWGCNA)\n\n# paralel processing\nlibrary(fs)\nlibrary(future.apply)\n\n# Configurar sessio\nplan(multisession, workers = parallel::detectCores() - 1)\ntheme_set(theme_cowplot())\nset.seed(12345)\nenableWGCNAThreads(nThreads = 8)\n\n# Directori d'entrada i sortida\ninput_dir &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/25_09/FC/Rimod_C9/CELL STATE/\"\noutput_dir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/Rimod/CS/\"\n\nif (!dir_exists(output_dir)) dir_create(output_dir)\ncsv_files &lt;- dir_ls(input_dir, glob = \"*.csv\")\n\nWGCNA_pseudobulk &lt;- function(file) {\n  tryCatch({\n    \n    # Obtenir el nom base de l'arxiu sense extensió\n    sample_name &lt;- path_ext_remove(path_file(file))\n    sample_output_dir &lt;- file.path(output_dir, sample_name)\n    \n    if (!dir_exists(sample_output_dir)) dir_create(sample_output_dir)\n    \n    message(\"Processing sample: \", sample_name)\n    \n    # Carregar dades en format CSV\n    sc_data &lt;- read.csv(file, row.names = 1)\n    \n    # Convertir a objecte Seurat\n    seurat_obj &lt;- CreateSeuratObject(counts = t(sc_data))\n    seurat_obj &lt;- SeuratObject::UpdateSeuratObject(seurat_obj)\n    \n    seurat_obj@meta.data$Sample &lt;- rownames(sc_data)\n    seurat_obj@meta.data$cell_type &lt;- sample_name\n    \n    seurat_obj &lt;- SetupForWGCNA(\n      seurat_obj,\n      gene_select = \"fraction\",\n      fraction = 0.05,\n      wgcna_name = \"pseudobulk\"\n    )\n    \n    message(\"Selected genes: \", length(GetWGCNAGenes(seurat_obj)))\n    \n    # log2CPM normalization\n    cpm &lt;- t(apply(sc_data, 1, function(x) {\n      y &lt;- x / sum(x) * 1e6\n      log2(y + 1)\n    }))\n    \n    seurat_obj &lt;- SetDatExpr(seurat_obj, mat = cpm)\n    seurat_obj@assays$RNA$data &lt;- t(cpm)\n    \n    # Soft thresholding\n    seurat_obj &lt;- TestSoftPowers(seurat_obj)\n    \n    # Save power plot\n    png(file.path(sample_output_dir, \"soft_power.png\"), width = 1000, height = 800)\n    PlotSoftPowers(seurat_obj)\n    dev.off()\n    \n    # Construct network\n    seurat_obj &lt;- ConstructNetwork(\n      seurat_obj,\n      tom_name = \"pseudobulk\",\n      overwrite_tom = TRUE,\n      mergeCutHeight = 0.25\n    )\n    \n    # Dendrogram\n    png(file.path(sample_output_dir, \"dendrogram.png\"), width = 1000, height = 800)\n    PlotDendrogram(seurat_obj, main = \"pseudobulk dendrogram\")\n    dev.off()\n    \n    # Eigengenes and connectivity\n    seurat_obj &lt;- ModuleEigengenes(seurat_obj, npcs = 2)\n    seurat_obj &lt;- ModuleConnectivity(seurat_obj)\n    \n    # DotPlot of MEs\n    MEs &lt;- GetMEs(seurat_obj)\n    mods &lt;- setdiff(colnames(MEs), \"grey\")\n    meta &lt;- seurat_obj@meta.data\n    seurat_obj@meta.data &lt;- cbind(meta, MEs)\n    \n    p_dot &lt;- DotPlot(seurat_obj, features = mods, group.by = \"cell_type\") +\n      RotatedAxis() +\n      scale_color_gradient(high = \"red\", low = \"grey95\") +\n      xlab(\"\") + ylab(\"\")\n    \n    png(file.path(sample_output_dir, \"dotplot_MEs.png\"), width = 1000, height = 800)\n    print(p_dot)\n    dev.off()\n    \n    # Reset metadata\n    seurat_obj@meta.data &lt;- meta\n    \n    # UMAP\n    seurat_obj &lt;- RunModuleUMAP(\n      seurat_obj,\n      n_hubs = 5,\n      n_neighbors = 10,\n      min_dist = 0.4,\n      spread = 3,\n      supervised = TRUE,\n      target_weight = 0.3\n    )\n    \n    umap_df &lt;- GetModuleUMAP(seurat_obj)\n    centroid_df &lt;- umap_df %&gt;%\n      dplyr::group_by(module) %&gt;%\n      dplyr::summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))\n    \n    p_umap &lt;- ggplot(umap_df, aes(x = UMAP1, y = UMAP2)) +\n      geom_point(color = umap_df$color, size = umap_df$kME * 2) +\n      geom_label(data = centroid_df, label = as.character(centroid_df$module),\n                 fontface = \"bold\", size = 2) +\n      umap_theme() +\n      theme(panel.background = element_rect(fill = \"black\"))\n    \n    png(file.path(sample_output_dir, \"umap_modules.png\"), width = 1000, height = 800)\n    print(p_umap)\n    dev.off()\n    \n    # Save the final Seurat object\n    saveRDS(seurat_obj, file = file.path(sample_output_dir, paste0(sample_name, \"_seurat.rds\")))\n    \n    message(\"Finished processing: \", sample_name)\n    \n  }, error = function(e) {\n    message(\"⚠️ Error in sample: \", file)\n    message(\"Details: \", e$message)\n  })\n}\n\n\n\n\n#future_lapply(csv_files, WGCNA_pseudobulk, future.seed = TRUE)\nfor (file in csv_files){\n  WGCNA_pseudobulk(file)\n}\n\n\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load and prepare metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize and merge metadata\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    \n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Correlation of MEs with group.ID\n    cor_results &lt;- apply(MEs, 2, function(module) {\n      cor.test(module, as.numeric(as.factor(A@meta.data$group.ID)), \n               method = \"spearman\", exact = TRUE)\n    })\n    \n    cor_df &lt;- data.frame(\n      module = names(cor_results),\n      cor = sapply(cor_results, function(x) x$estimate),\n      p.value = sapply(cor_results, function(x) x$p.value)\n    )\n    \n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory if not exists\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_0.25_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    \n    sig_modules &lt;- cor_df_sorted$module[cor_df_sorted$p.value &lt; 0.05]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    print(paste0(\"Finished: \", CS))\n    \n  }) # end try\n}\n\n\nlibrary(dplyr)\nlibrary(hdWGCNA)\nlibrary(xlsx)\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                row.names = 1, sheetIndex = 1)\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- rownames(metadata_df)\n    \n    # Harmonize sample names\n    A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n    meta_joined &lt;- A@meta.data %&gt;%\n      mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n      left_join(metadata_df, by = \"Sample_clean\")\n    A@meta.data &lt;- meta_joined\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    \n    # Ensure sample order matches between MEs and metadata\n    sample_order &lt;- rownames(MEs)\n    # Ensure consistent factor order: Healthy (control), TDP (case)\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, A@meta.data$Sample), \"group.ID\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and calculate fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir,mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(hdWGCNA)\n\n# Loop over directories\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", full.names = FALSE, recursive = FALSE)) {\n  try({\n    \n    # Load Seurat object\n    A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/\", CS, \"_seurat.rds\"))\n    \n    # Load metadata\n    metadata &lt;- read.delim(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\", \n                           row.names = 1, sep = \"\\t\")\n    metadata_df &lt;- as.data.frame(metadata)\n    metadata_df$Sample_clean &lt;- gsub(\"-\", \"\\\\.\",rownames(metadata_df))\n    rownames(metadata_df) &lt;- metadata_df$Sample_clean \n    # Filter out FTLD-TDP-C and recode group labels\n    metadata_df &lt;- metadata_df[metadata_df$GROUP != \"FTLD-TDP-C\", ]\n    metadata_df$GROUP &lt;- ifelse(metadata_df$GROUP == \"Control\", \"Healthy\", \"TDP\")\n    \n    samples_to_keep &lt;- intersect(rownames(A@meta.data), metadata_df$Sample_clean)\n    A &lt;- subset(A,cells= samples_to_keep)\n                \n    # Harmonize and merge metadata\n    A@meta.data &lt;- metadata_df\n    \n    # Get Module Eigengenes\n    MEs &lt;- hdWGCNA::GetMEs(A)\n    samples_in_A &lt;- rownames(A@meta.data)\n    MEs &lt;- MEs[rownames(MEs) %in% samples_in_A, ]\n    sample_order &lt;- rownames(MEs)\n    \n    # Ensure correct group assignment order\n    group_vector &lt;- factor(\n      A@meta.data[match(sample_order, rownames(A@meta.data)), \"GROUP\"],\n      levels = c(\"Healthy\", \"TDP\")\n    )\n    \n    # Apply Wilcoxon test and compute fold change\n    test_results &lt;- lapply(1:ncol(MEs), function(i) {\n      vec &lt;- MEs[, i]\n      group1 &lt;- vec[group_vector == \"Healthy\"]\n      group2 &lt;- vec[group_vector == \"TDP\"]\n      fc &lt;- mean(group2, na.rm = TRUE) - mean(group1, na.rm = TRUE)  # TDP - Healthy\n      test &lt;- wilcox.test(group1, group2)\n      \n      list(\n        module = colnames(MEs)[i],\n        fold_change = fc,\n        p.value = test$p.value\n      )\n    })\n    \n    # Compile and sort results\n    cor_df &lt;- do.call(rbind, lapply(test_results, as.data.frame))\n    cor_df_sorted &lt;- cor_df[order(cor_df$p.value), ]\n    \n    # Create output directory\n    outdir &lt;- paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/NEW/CS_bo/\", CS, \"/MODULES/\")\n    dir.create(outdir, showWarnings = FALSE, recursive = TRUE)\n    \n    # Write gene lists for significant modules\n    module_colors &lt;- A@misc$pseudobulk$wgcna_degrees\n    sig_modules &lt;- cor_df_sorted$module[!is.na(cor_df_sorted$module)]\n    \n    for (mod in sig_modules) {\n      genes &lt;- module_colors$gene_name[module_colors$module == mod]\n      write.csv(genes, file = paste0(outdir, mod, \".csv\"), row.names = FALSE)\n    }\n    \n    # Write summary and hub genes\n    Hubs &lt;- GetHubGenes(A, n_hubs = 10, mods = NULL, wgcna_name = NULL)\n    write.csv(cor_df_sorted, file = paste0(outdir, \"/cor_summary.csv\"), row.names = FALSE)\n    write.csv(as.data.frame(Hubs), file = paste0(outdir, \"/hubs.csv\"), row.names = FALSE)\n    \n    print(paste0(\"Finished: \", CS))\n  })\n}\n\n\n############################## Correlation MEs VS Covariables ###############################\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/TDP/CS_bo_ambhubs/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/TDP/ArcSin_FTD_TDP_neuropath_SOM\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"long\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n\n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"7BLACK\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"TDP43b\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/TDP/CS_asin_moduletraitcorrelation_tdp43b_tdp/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n#      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n#      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n#      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}\n\n\n\n############################## Correlation MEs VS Covariables ###############################\n\n# C9 \n\n# Must change the covariable name for each case.\n\nlibrary(hdWGCNA)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(xlsx)\n\nCS &lt;- list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", full.names = FALSE, recursive = FALSE)[1]\n\nfor (CS in list.dirs(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", \n                     full.names = FALSE, recursive = FALSE)) {\n  if (file.exists(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))) {\n    \n    tryCatch({\n      \n      message(\"Processing CS: \", CS)\n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Processing: \", CS, \"\\n\"); sink()\n      \n      # Load Seurat object\n      A &lt;- readRDS(paste0(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/hdWGCNA/FTLD/c9/CS_0.25_npcs2/\", CS, \"/\", CS, \"_seurat.rds\"))\n      \n      # Load metadata\n      metadata &lt;- xlsx::read.xlsx(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\", \n                                  row.names = 1, sheetIndex = 1)\n      covariables &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/COVARIABLES/TRANSFORMED_COVARIABLES/ArcSin/C9/ArcSin_FTD_C9_neuropath_SOM.csv\")\n      \n      # Merge metadata\n      covariables$X &lt;- gsub(\"X\", \"\", covariables$X)\n      A$Sample_clean &lt;- gsub(\"^X\", \"\", A@meta.data$Sample)\n      metadata_df &lt;- as.data.frame(metadata)\n      metadata_df$Sample_clean &lt;- rownames(metadata_df)\n      \n      meta_joined &lt;- A@meta.data %&gt;%\n        mutate(Sample_clean = gsub(\"^X\", \"\", Sample)) %&gt;%\n        left_join(metadata_df, by = \"Sample_clean\") %&gt;%\n        left_join(covariables, by = c(\"Sample_clean\" = \"X\"))\n      \n      rownames(meta_joined) &lt;- colnames(A)\n      A@meta.data &lt;- meta_joined\n      \n      # Align rownames\n      if (!all(rownames(A@meta.data) == colnames(A))) {\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure WGCNA results are present\n      if (!\"pseudobulk\" %in% names(A@misc)) stop(\"WGCNA results not found in @misc$pseudobulk for \", CS)\n      \n      # Remove outlier\n      outlier &lt;- \"\"\n      if (outlier %in% colnames(A)) {\n        A &lt;- subset(A, cells = setdiff(colnames(A), outlier))\n        rownames(A@meta.data) &lt;- colnames(A)\n      }\n      \n      # Ensure numeric trait\n      # A@meta.data$TDP43b &lt;- as.numeric(as.character(A@meta.data$TDP43b))\n      # if (all(is.na(A@meta.data$TDP43b))) stop(\"TDP43b column is all NA for \", CS)\n      \n      # Calculate module eigengenes inside Seurat object\n      MEs &lt;- hdWGCNA::GetMEs(A, wgcna_name = \"pseudobulk\")\n      A@misc$pseudobulk$MEs &lt;- MEs\n      \n      # Check MEs exist\n      if (is.null(A@misc$pseudobulk$MEs)) stop(\"No MEs found in object for \", CS)\n      \n      # Run Module-Trait correlation\n      cor_results &lt;- hdWGCNA::ModuleTraitCorrelation(\n        seurat_obj = A,\n        traits = \"pTDP43\",\n        wgcna_name = \"pseudobulk\"\n      )\n      \n      # Extract correlation dataframe safely\n      cor_df &lt;- GetModuleTraitCorrelation(cor_results)\n      \n      # Sort correlations\n      # Extract correlations for 'all_cells'\n      cor_vec &lt;- cor_df$cor$all_cells\n      pval_vec &lt;- cor_df$pval$all_cells\n      fdr_vec &lt;- cor_df$fdr$all_cells\n      \n      # Convert to data frame\n      cor_df_clean &lt;- data.frame(\n        module = names(cor_vec),\n        cor = as.numeric(cor_vec),\n        p.value = as.numeric(pval_vec),\n        fdr = as.numeric(fdr_vec)\n      )\n      \n      # Sort by absolute correlation and then p-value\n      library(dplyr)\n      cor_df_sorted &lt;- cor_df_clean %&gt;%\n        arrange(desc(abs(cor)), p.value)\n      \n      # Save results\n      outdir &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/CORRELATION/EGG_VS_COV/FTLD/C9/CS_Moduletraitcorrelations_Asin_pTDP43/\"\n      if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)\n      write.csv(cor_df_sorted, file = paste0(outdir, CS, \".csv\"), row.names = FALSE)      \n      # Cleanup\n      rm(A, metadata, covariables, \n         cor_vec, pval_vec, fdr_vec,\n         cor_df_sorted, cor_results, cor_df, cor_df_clean); gc()\n      message(\"Finished processing CS: \", CS)\n      \n      #      sink(log_file, append = TRUE); cat(Sys.time(), \" - Finished: \", CS, \"\\n\"); sink()\n      \n    }, error = function(e) {\n      #      sink(log_file, append = TRUE)\n      cat(Sys.time(), \"ERROR in \", CS, \": \", conditionMessage(e), \"\\n\")\n      #      sink()\n      message(\"Error in CS: \", CS, \" → \", conditionMessage(e))\n    })\n  }\n}"
  },
  {
    "objectID": "Methods/Bayesprism.html",
    "href": "Methods/Bayesprism.html",
    "title": "Bayesprism",
    "section": "",
    "text": "Bulk RNA-sequencing provides a high-throughput snapshot of gene expression in brain tissue but masks the substantial cellular heterogeneity of the human cortex. FTLD pathology affects specific neuronal populations—particularly RORB-expressing excitatory neurons—as well as diverse non-neuronal cell classes including astrocytes, microglia, oligodendrocytes, vascular cells, and infiltrating immune cells. As a result, interpreting bulk transcriptomic changes requires methods capable of deconvolving mixed-cell signals into cell-type–specific expression profiles and cell-state proportions.\nBayesian deconvolution methods, such as BayesPrism, offer major advantages over traditional regression or matrix factorization approaches by explicitly modeling biological variability and uncertainty. Using a high-resolution single-nucleus RNA-seq reference—such as the dataset from Pineda et al. (Synapse ID: syn51105515)—BayesPrism integrates single-cell information with bulk counts to infer, for each sample:\n\nCell-type and cell-state fractions, representing the estimated proportion of each transcriptional state in the tissue.\nCell-type–specific expression estimates, reconstructing a matrix of gene expression for each cell state within each patient.\n\nThis dual output allows downstream cell-state–resolved differential expression, co-expression network analysis (hdWGCNA), and correlations with neuropathological markers.\n\n\n\nThe Bayesian deconvolution approach consisted of the following steps:\n\n\nThe reference atlas from Pineda et al. contained 19 major cell classes and 44 transcriptionally distinct cell states derived from human frontal cortex single-nucleus RNA-seq. The reference was preprocessed to:\n\nexclude genes with low expression,\nremove mitochondrial, ribosomal, and sex-chromosome transcripts,\nretain only protein-coding genes expressed in ≥5 nuclei.\n\nThis produced a biologically curated transcriptional reference ideal for Bayesian modeling of cortical cell populations.\n\n\n\nBulk RNA-seq counts from all four cohorts (two Sant Pau, Menden et al., Pottier et al.) were matched to the gene identifiers in the reference.\nCounts were log-transformed where appropriate, and samples were retained only if sequencing quality and pathological classification were robust.\n\n\n\nA BayesPrism object was created using the filtered single-cell matrix as the reference component and the raw bulk count matrix as the mixture component. The algorithm:\n\nidentifies outlier genes (cutoff = 0.01),\nperforms Gibbs sampling to estimate posterior distributions for each sample,\ninfers cell-type fractions (θ) and cell-type–specific expression matrices (φ) simultaneously.\n\nPosterior estimates were extracted after convergence diagnostics ensured stable sampling across chains.\n\n\n\nFor each sample, BayesPrism returned:\n\nPosterior-estimated cell-state proportions, enabling comparisons between FTLD-C9, FTLD-TDP, and controls.\nCell-state–specific expression matrices, which served as the basis for:\n\nedgeR-based cell-state differential expression.\nconstruction of pseudobulk Seurat objects,\nhdWGCNA module detection,\ncorrelation analysis with neuropathology (ACSL3, lncRNAs, RNA foci, DPRs, pTDP-43, STMN2).\n\n\n\n\n\nAll steps—from reference alignment, through BayesPrism modeling, to extraction of posterior values—were performed identically in:\n\nSant Pau FTLD-C9\nSant Pau FTLD-TDP\nMenden et al. FTLD-C9\nPottier et al. FTLD-TDP\n\nThis standardized pipeline enabled robust cross-cohort comparison of:\n\ncell-state proportions,\ncell-type–specific differential expression.\nco-expression networks,\npathological-marker correlations.\n\n\n\n\n\nBayesPrism was employed to achieve the following methodological goals:\n\nResolve bulk RNA-seq into cell-type and cell-state contributions to uncover FTLD-associated alterations hidden in tissue-level averages.\nEnable differential expression analysis at single-cell resolution, identifying the precise neuronal and glial subtypes driving FTLD-C9 and FTLD-TDP transcriptional changes.\nQuantify disease-related changes in cell-state composition, including excitatory/inhibitory neuron loss and reactive glial expansion.\nMap neuropathological burden (RNA foci, DPRs, pTDP-43, STMN2) to transcriptional changes within specific cell states.\nGenerate high-dimensional transcriptional networks (hdWGCNA) to identify disease-relevant modules that would otherwise be unresolvable in bulk data.\nValidate findings across independent datasets using a unified Bayesian framework to ensure reproducibility and generalizability.\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\ngc()\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nrm(sc.dat)\ngc()\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nrm(sc.dat.filtered)\ngc()\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n#bp.res.update &lt;- update.theta (bp = bp.res.initial)\n#save(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\n#save(bp.res.initial, file = \"bp.res.initial.RData\")\n#bp.res.update &lt;- update.theta (bp = bp.res.initial)\n#save(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_original.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\")\n###############################################################################\n#Set colnames and rownames\nbk.dat&lt;-bk.dat[, -c(1,2,3,4,5,7)]\nbk.dat &lt;- aggregate(. ~ GeneName, data = bk.dat, FUN = sum) # Aggregate rows with same gene\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n# El matrix es el que dona problemes!!!!!!\n#sc.dat &lt;- t(as.matrix(merged@assays$Assay_name$counts))\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n\n# Update metadata to take into account DGE groups.\n\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50,)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\nbp.res.update &lt;- update.theta (bp = bp.res.initial)\nsave(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n#bp.res.update &lt;- update.theta (bp = bp.res.initial)\n#save(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}"
  },
  {
    "objectID": "Methods/Bayesprism.html#rationale",
    "href": "Methods/Bayesprism.html#rationale",
    "title": "Bayesprism",
    "section": "",
    "text": "Bulk RNA-sequencing provides a high-throughput snapshot of gene expression in brain tissue but masks the substantial cellular heterogeneity of the human cortex. FTLD pathology affects specific neuronal populations—particularly RORB-expressing excitatory neurons—as well as diverse non-neuronal cell classes including astrocytes, microglia, oligodendrocytes, vascular cells, and infiltrating immune cells. As a result, interpreting bulk transcriptomic changes requires methods capable of deconvolving mixed-cell signals into cell-type–specific expression profiles and cell-state proportions.\nBayesian deconvolution methods, such as BayesPrism, offer major advantages over traditional regression or matrix factorization approaches by explicitly modeling biological variability and uncertainty. Using a high-resolution single-nucleus RNA-seq reference—such as the dataset from Pineda et al. (Synapse ID: syn51105515)—BayesPrism integrates single-cell information with bulk counts to infer, for each sample:\n\nCell-type and cell-state fractions, representing the estimated proportion of each transcriptional state in the tissue.\nCell-type–specific expression estimates, reconstructing a matrix of gene expression for each cell state within each patient.\n\nThis dual output allows downstream cell-state–resolved differential expression, co-expression network analysis (hdWGCNA), and correlations with neuropathological markers."
  },
  {
    "objectID": "Methods/Bayesprism.html#analytical-strategy",
    "href": "Methods/Bayesprism.html#analytical-strategy",
    "title": "Bayesprism",
    "section": "",
    "text": "The Bayesian deconvolution approach consisted of the following steps:\n\n\nThe reference atlas from Pineda et al. contained 19 major cell classes and 44 transcriptionally distinct cell states derived from human frontal cortex single-nucleus RNA-seq. The reference was preprocessed to:\n\nexclude genes with low expression,\nremove mitochondrial, ribosomal, and sex-chromosome transcripts,\nretain only protein-coding genes expressed in ≥5 nuclei.\n\nThis produced a biologically curated transcriptional reference ideal for Bayesian modeling of cortical cell populations.\n\n\n\nBulk RNA-seq counts from all four cohorts (two Sant Pau, Menden et al., Pottier et al.) were matched to the gene identifiers in the reference.\nCounts were log-transformed where appropriate, and samples were retained only if sequencing quality and pathological classification were robust.\n\n\n\nA BayesPrism object was created using the filtered single-cell matrix as the reference component and the raw bulk count matrix as the mixture component. The algorithm:\n\nidentifies outlier genes (cutoff = 0.01),\nperforms Gibbs sampling to estimate posterior distributions for each sample,\ninfers cell-type fractions (θ) and cell-type–specific expression matrices (φ) simultaneously.\n\nPosterior estimates were extracted after convergence diagnostics ensured stable sampling across chains.\n\n\n\nFor each sample, BayesPrism returned:\n\nPosterior-estimated cell-state proportions, enabling comparisons between FTLD-C9, FTLD-TDP, and controls.\nCell-state–specific expression matrices, which served as the basis for:\n\nedgeR-based cell-state differential expression.\nconstruction of pseudobulk Seurat objects,\nhdWGCNA module detection,\ncorrelation analysis with neuropathology (ACSL3, lncRNAs, RNA foci, DPRs, pTDP-43, STMN2).\n\n\n\n\n\nAll steps—from reference alignment, through BayesPrism modeling, to extraction of posterior values—were performed identically in:\n\nSant Pau FTLD-C9\nSant Pau FTLD-TDP\nMenden et al. FTLD-C9\nPottier et al. FTLD-TDP\n\nThis standardized pipeline enabled robust cross-cohort comparison of:\n\ncell-state proportions,\ncell-type–specific differential expression.\nco-expression networks,\npathological-marker correlations."
  },
  {
    "objectID": "Methods/Bayesprism.html#objectives-of-applying-bayesprism",
    "href": "Methods/Bayesprism.html#objectives-of-applying-bayesprism",
    "title": "Bayesprism",
    "section": "",
    "text": "BayesPrism was employed to achieve the following methodological goals:\n\nResolve bulk RNA-seq into cell-type and cell-state contributions to uncover FTLD-associated alterations hidden in tissue-level averages.\nEnable differential expression analysis at single-cell resolution, identifying the precise neuronal and glial subtypes driving FTLD-C9 and FTLD-TDP transcriptional changes.\nQuantify disease-related changes in cell-state composition, including excitatory/inhibitory neuron loss and reactive glial expansion.\nMap neuropathological burden (RNA foci, DPRs, pTDP-43, STMN2) to transcriptional changes within specific cell states.\nGenerate high-dimensional transcriptional networks (hdWGCNA) to identify disease-relevant modules that would otherwise be unresolvable in bulk data.\nValidate findings across independent datasets using a unified Bayesian framework to ensure reproducibility and generalizability.\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\ngc()\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nrm(sc.dat)\ngc()\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nrm(sc.dat.filtered)\ngc()\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n#bp.res.update &lt;- update.theta (bp = bp.res.initial)\n#save(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\n#save(bp.res.initial, file = \"bp.res.initial.RData\")\n#bp.res.update &lt;- update.theta (bp = bp.res.initial)\n#save(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_original.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\")\n###############################################################################\n#Set colnames and rownames\nbk.dat&lt;-bk.dat[, -c(1,2,3,4,5,7)]\nbk.dat &lt;- aggregate(. ~ GeneName, data = bk.dat, FUN = sum) # Aggregate rows with same gene\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n# El matrix es el que dona problemes!!!!!!\n#sc.dat &lt;- t(as.matrix(merged@assays$Assay_name$counts))\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n\n# Update metadata to take into account DGE groups.\n\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50,)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\nbp.res.update &lt;- update.theta (bp = bp.res.initial)\nsave(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}\n\n\nlibrary(\"ggplot2\")\nlibrary(\"openxlsx\")\nlibrary(\"dplyr\")\nlibrary(\"coin\")\nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\nlibrary(\"edgeR\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\nsuppressWarnings(library(\"BayesPrism\"))\nsuppressWarnings(library(org.Hs.eg.db))\nlibrary(dplyr) \nlibrary(\"AnnotationDbi\")\nlibrary(\"org.Hs.eg.db\")\nlibrary('EnsDb.Hsapiens.v86')\nlibrary(\"Seurat\")\n\n\n\n\n################################################################################\n# Single cell data\nload(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/DATA/Merge_FC_complete.RData\")\n# Bulk data\nbk.dat &lt;-  read.csv(\"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\")\n###############################################################################\n#Set colnames and rownames\nrownames(bk.dat)&lt;-bk.dat[,1]\nbk.dat &lt;- bk.dat[,-1]\nbk.dat &lt;- t(bk.dat)\n\nsc.dat &lt;- t(merged@assays$Assay_name$counts)\n\nA &lt;- read.csv(\"/media/jaumatell/datos/URI/BAYESPRISM_12_3/SINGLE_CELL/METADATA/S03_annotation_mapping.csv\")\nA[44,\"SubType\" ] &lt;- \"T_Cell\"\nA[20,\"SubType\" ] &lt;- \"OPC\"\nA[19,\"SubType\" ] &lt;- \"Oligo\"\nA[18,\"SubType\" ] &lt;- \"Micro\"\n\n# Update metadata to take into account DGE groups.\nmerged@meta.data &lt;- merged@meta.data %&gt;%\n  left_join(A, by = c(\"cellstate\" = \"SubType\"))\n\n# Cell type and state\ncell.state.labels &lt;- merged@meta.data$cellstate\ncell.type.labels &lt;- merged@meta.data$CellType\nrm(merged)\n\n# Pre-processing\nplot.cor.phi (input=sc.dat, \n              input.labels=as.factor(cell.state.labels),\n              title=\"cell state correlation\",\n              pdf.prefix=\"gbm.cor.cs\",\n              cexRow=0.2, \n              cexCol=0.2,\n              margins=c(2,2)\n)\n\nplot.cor.phi (input=sc.dat,\n              input.labels=as.factor(cell.type.labels),\n              title=\"cell type correlation\",\n              pdf.prefix=\"gbm.cor.ct\",\n              cexRow=0.5, \n              cexCol=0.5,\n)\n\nsc.stat &lt;- plot.scRNA.outlier(\n  input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID\n  cell.type.labels=as.factor(cell.type.labels),\n  species=\"hs\", #currently only human(hs) and mouse(mm) annotations are supported\n  return.raw=TRUE, #return the data used for plotting.\n  pdf.prefix=\"SC_stats\"\n)\nwrite.csv(sc.stat, \"sc.stat.csv\")\n\nprint(\"bk.stat\")\nbk.stat &lt;- plot.bulk.outlier(\n  bulk.input = bk.dat,\n  sc.input = sc.dat,\n  cell.type.labels = cell.type.labels,\n  species = \"hs\",\n  return.raw = TRUE,\n  pdf.prefix = \"BK_stats\"\n)\nwrite.csv(bk.dat, \"bk.stat.csv\")\n\n\nprint(\"sc.stat.filtered\")\nsc.dat.filtered &lt;- cleanup.genes (input=sc.dat,\n                                  input.type=\"count.matrix\",\n                                  species=\"hs\",\n                                  gene.group=c( \"Rb\",\"Mrp\",\"other_Rb\",\"chrM\",\"MALAT1\",\"chrX\",\"chrY\") ,\n                                  exp.cells=5\n)\nwrite.csv(sc.dat.filtered, \"sc.dat.filtered.csv\")\n\nprint(\"bk.stat.filtered\")\nplot.bulk.vs.sc (sc.input = sc.dat.filtered,\n                 bulk.input = bk.dat,\n                 pdf.prefix=\"Bulk_vs_Sc\"\n)\n\nprint(\"sc.dat.filtered.pc\")\nsc.dat.filtered.pc &lt;- select.gene.type (sc.dat.filtered,\n                                        gene.type = \"protein_coding\")\nwrite.csv(sc.dat.filtered.pc, \"sc.dat.filtered.pc.csv\")\n\n# SORT bk.dat so the colnames are sorted equaly in both tables. \ncommon_columns &lt;- intersect(colnames(bk.dat), colnames(sc.dat.filtered.pc))\nbk.dat &lt;- bk.dat[, common_columns]\nsc.dat.filtered.pc &lt;- sc.dat.filtered.pc[, common_columns]\n\nrm(sc.dat)\nrm(sc.dat.filtered)\nrm(bk.stat)\nrm(sc.stat)\n\nmyPrism &lt;- new.prism(\n  reference=sc.dat.filtered.pc,\n  mixture=as.matrix(bk.dat[,2:ncol(bk.dat)]),\n  input.type=\"count.matrix\",\n  cell.type.labels = cell.type.labels,\n  cell.state.labels = cell.state.labels,\n  key=NULL,\n  outlier.cut=0.01,\n  outlier.fraction=0.1,\n)\nsave(myPrism, file = \"myPrism.RData\")\n\nbp.res &lt;- run.prism(prism = myPrism, n.cores=50)\nsave(bp.res, file = \"bp.res.RData\")\n\ntheta &lt;- get.fraction (bp=bp.res,\n                       which.theta=\"final\",\n                       state.or.type=\"type\")\nwrite.csv(theta, \"theta.csv\")\n\ntheta.cv &lt;- bp.res@posterior.theta_f@theta.cv\nwrite.csv(theta.cv, \"theta.cv.csv\")\n\nbp.res.initial &lt;- run.prism(prism = myPrism, \n                            n.cores=50, \n                            update.gibbs=FALSE)\nsave(bp.res.initial, file = \"bp.res.initial.RData\")\n#bp.res.update &lt;- update.theta (bp = bp.res.initial)\n#save(bp.res.update, file = \"bp.res.update.RData\")\n\ntheta.state &lt;- get.fraction (bp=bp.res.initial,\n                             which.theta=\"first\",\n                             state.or.type=\"state\")\nwrite.csv(theta.state, \"theta.state_cellstate.csv\")\n\n# Make new directories\nnew_dir_name &lt;- \"CELL TYPE\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nnew_dir_name &lt;- \"CELL STATE ORIGINAL\"\nif (file.exists(new_dir_name)){\n  print(\"\", end = \"\")\n} else {\n  dir.create(new_dir_name)\n}\n\nfor (cell_type in levels(as.factor(cell.type.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"type\", \n                      cell.name = cell_type)\n  write.csv(exp_type, paste0(\"CELL TYPE/\", cell_type, \".csv\"))\n}\n\n\nfor (cell_state in levels(as.factor(cell.state.labels))){\n  exp_type &lt;- get.exp(bp = bp.res, \n                      state.or.type = \"state\", \n                      cell.name = cell_state)\n  write.csv(exp_type, paste0(\"CELL STATE ORIGINAL/\", cell_state, \".csv\"))\n}"
  },
  {
    "objectID": "Introduction/Cohort.html",
    "href": "Introduction/Cohort.html",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "Our analysis integrated transcriptomic data from four independent bulk RNA-sequencing cohorts, comprising two newly generated datasets from Hospital de la Santa Creu i Sant Pau and two publicly available external datasets used for validation. All datasets consisted of post-mortem frontal cortex samples from individuals diagnosed with FTLD and cognitively healthy controls. Collectively, these cohorts enabled robust, cross-cohort evaluation of cell-type–resolved transcriptional alterations and disease-associated gene expression programs.\n\n\nThe first primary dataset was generated at Hospital de la Santa Creu i Sant Pau and included 11 individuals with FTLD due to a C9orf72 hexanucleotide repeat expansion (FTLD-C9) and 7 cognitively healthy controls. Diagnoses were neuropathologically verified, and all samples were sequenced from the frontal cortex. This cohort served as the discovery dataset for identifying disease-associated transcriptional changes, alterations in inferred cell-state composition, and correlations with C9orf72-specific neuropathological markers, including RNA foci, dipeptide repeat proteins (polyGA, polyGP, polyGR), and TDP-43–related measures.\n\n\n\nA second independent dataset from Sant Pau included 9 individuals with sporadic FTLD-TDP and 7 controls from the same anatomical region and processed using equivalent library preparation and sequencing pipelines. This cohort provided complementary transcriptomic profiling for FTLD-TDP, enabling direct comparison between genetic (C9orf72-associated) and sporadic TDP-43 proteinopathies within a harmonized experimental framework. Neuropathological quantification of pTDP-43 and STMN2 levels allowed integration of transcriptional changes with molecular markers of TDP-43 dysfunction.\n\n\n\nTo evaluate the reproducibility of FTLD-C9 transcriptional signatures, we used the bulk RNA-seq dataset published by Menden et al. (2023) and available through the European Genome-Phenome Archive (EGAC00001001879). From this study, we selected 13 C9orf72-expansion FTLD cases and 16 controls, restricting analyses to neuropathologically confirmed FTLD-C9 samples. This dataset served as an external validation cohort for differential expression, Bayesian deconvolution, and co-expression network findings from the Sant Pau FTLD-C9 dataset.\n\n\n\nValidation of FTLD-TDP results was performed using the dataset published by Pottier et al. [1], which includes frontal cortex RNA-sequencing data from 44 FTLD-TDP cases and 24 controls. Only individuals with neuropathologically verified FTLD-TDP type A or B pathology were retained for analysis. This dataset provided an independent, high-powered external resource to assess the robustness of the Sant Pau FTLD-TDP differential expression, cell-state–specific transcriptional shifts, and co-expression modules."
  },
  {
    "objectID": "Introduction/Cohort.html#sant-pau-ftld-c9",
    "href": "Introduction/Cohort.html#sant-pau-ftld-c9",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "The first primary dataset was generated at Hospital de la Santa Creu i Sant Pau and included 11 individuals with FTLD due to a C9orf72 hexanucleotide repeat expansion (FTLD-C9) and 7 cognitively healthy controls. Diagnoses were neuropathologically verified, and all samples were sequenced from the frontal cortex. This cohort served as the discovery dataset for identifying disease-associated transcriptional changes, alterations in inferred cell-state composition, and correlations with C9orf72-specific neuropathological markers, including RNA foci, dipeptide repeat proteins (polyGA, polyGP, polyGR), and TDP-43–related measures."
  },
  {
    "objectID": "Introduction/Cohort.html#sant-pau-ftld-tdp",
    "href": "Introduction/Cohort.html#sant-pau-ftld-tdp",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "A second independent dataset from Sant Pau included 9 individuals with sporadic FTLD-TDP and 7 controls from the same anatomical region and processed using equivalent library preparation and sequencing pipelines. This cohort provided complementary transcriptomic profiling for FTLD-TDP, enabling direct comparison between genetic (C9orf72-associated) and sporadic TDP-43 proteinopathies within a harmonized experimental framework. Neuropathological quantification of pTDP-43 and STMN2 levels allowed integration of transcriptional changes with molecular markers of TDP-43 dysfunction."
  },
  {
    "objectID": "Introduction/Cohort.html#menden-et-al.-validation-cohort-ega",
    "href": "Introduction/Cohort.html#menden-et-al.-validation-cohort-ega",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "To evaluate the reproducibility of FTLD-C9 transcriptional signatures, we used the bulk RNA-seq dataset published by Menden et al. (2023) and available through the European Genome-Phenome Archive (EGAC00001001879). From this study, we selected 13 C9orf72-expansion FTLD cases and 16 controls, restricting analyses to neuropathologically confirmed FTLD-C9 samples. This dataset served as an external validation cohort for differential expression, Bayesian deconvolution, and co-expression network findings from the Sant Pau FTLD-C9 dataset."
  },
  {
    "objectID": "Introduction/Cohort.html#pottier-et-al.-validation-cohort",
    "href": "Introduction/Cohort.html#pottier-et-al.-validation-cohort",
    "title": "Cohorts and Reference Dataset",
    "section": "",
    "text": "Validation of FTLD-TDP results was performed using the dataset published by Pottier et al. [1], which includes frontal cortex RNA-sequencing data from 44 FTLD-TDP cases and 24 controls. Only individuals with neuropathologically verified FTLD-TDP type A or B pathology were retained for analysis. This dataset provided an independent, high-powered external resource to assess the robustness of the Sant Pau FTLD-TDP differential expression, cell-state–specific transcriptional shifts, and co-expression modules."
  },
  {
    "objectID": "Discussion/Discussion.html#discussion-2",
    "href": "Discussion/Discussion.html#discussion-2",
    "title": "Discussion",
    "section": "Discussion 2",
    "text": "Discussion 2"
  },
  {
    "objectID": "Discussion/Discussion.html#discussion-3",
    "href": "Discussion/Discussion.html#discussion-3",
    "title": "Discussion",
    "section": "Discussion 3",
    "text": "Discussion 3"
  },
  {
    "objectID": "Discussion/Discussion.html#discussion-4",
    "href": "Discussion/Discussion.html#discussion-4",
    "title": "Discussion",
    "section": "Discussion 4",
    "text": "Discussion 4"
  },
  {
    "objectID": "Introduction/Background.html",
    "href": "Introduction/Background.html",
    "title": "Background",
    "section": "",
    "text": "Frontotemporal lobar degeneration (FTLD) comprises a group of neurodegenerative disorders characterized by progressive atrophy of the frontal and temporal lobes, leading to profound changes in personality, behaviour, language, and executive function. It represents the most common cause of dementia under 65 years of age and exhibits substantial clinical, genetic, and neuropathological heterogeneity. From a pathological standpoint, FTLD is primarily classified according to the molecular identity of the protein aggregates present in neurons and glia, most commonly TDP-43, tau, or FUS. Among these, FTLD-TDP accounts for ~50% of cases and represents the major pathological subtype associated with both sporadic disease and several genetic forms.\nAt the molecular level, FTLD is increasingly understood as a disorder of RNA metabolism, proteostasis, synaptic function, and neuroimmune interactions, with convergent disruptions across multiple cell types. Early transcriptomic studies in bulk cortical tissue identified dysregulation in synaptic signalling, immune activation, vesicle trafficking, and RNA-processing pathways. More recently, single-nucleus RNA sequencing has shown that FTLD pathology arises through cell-type–specific vulnerabilities, affecting both excitatory and inhibitory neurons, glial populations, vascular cells, and immune-infiltrating populations. This cell-type specificity is essential to understanding how different FTLD subtypes converge or diverge in pathophysiology, particularly in the most prevalent forms: FTLD due to C9orf72 repeat expansion (FTLD-C9) and sporadic FTLD-TDP.\n\n\nThe C9orf72 hexanucleotide repeat expansion (HRE) is the most common genetic cause of both FTLD and amyotrophic lateral sclerosis (ALS). The pathogenic expansion of GGGGCC (G4C2) repeats leads to at least three convergent mechanisms:\n\nHaploinsufficiency of C9orf72, reducing levels of a protein involved in autophagy–lysosomal function and endosomal trafficking.\nReferences: PMC3430713; Nature 2019 reviews.\nRNA toxicity, where expanded sense and antisense repeat-containing transcripts accumulate in the nucleus, forming RNA foci that sequester numerous RNA-binding proteins and disrupt splicing and RNA homeostasis.\nReferences: Nature Neuroscience; Acta Neuropathologica 2018.\nDipeptide repeat proteins (DPRs) produced by repeat-associated non-AUG (RAN) translation, including poly-GA, poly-GP, poly-GR, poly-PA, and poly-PR, which accumulate in cytoplasmic inclusions and disrupt nucleocytoplasmic transport, ribosomal function, and proteostasis.\nReferences: Cell 2015; Nature Genetics 2013; Acta Neuropathol 2018.\n\nNeuropathologically, FTLD-C9 is characterized by:\n\nAbundant DPR inclusions (poly-GA &gt; poly-GP &gt; poly-GR),\nWidespread RNA foci (sense and antisense),\nVariable TDP-43 pathology (usually FTLD-TDP type B),\nMarked vulnerability of extratelencephalic pathways, including corticospinal tracts and cerebellum,\nPronounced neuroinflammation and glial activation.\n\nTranscriptomic studies reveal a consistent pattern of synaptic dysfunction, altered neuronal excitability, astrocytic and microglial activation, vesicular trafficking deficits, and downregulation of STMN2 due to TDP-43 dysfunction. Single-cell analyses demonstrate that specific excitatory neuron populations (e.g., RORB-positive L4/5 neurons) are highly vulnerable, while glial populations show diverse inflammatory signatures.\nThe combination of RNA foci, DPR toxicity, and TDP-43 dyshomeostasis creates a multifactorial, cell-type-dependent cascade culminating in widespread cortical degeneration.\n\n\n\nSporadic FTLD-TDP comprises the largest cluster of FTLD cases and is defined by the intracellular accumulation of phosphorylated, ubiquitinated, and cleaved forms of TDP-43, a ubiquitously expressed RNA-binding protein essential for splicing repression, cryptic exon suppression, stress-granule dynamics, and mRNA transport.\nLoss of nuclear TDP-43 function leads to:\n\nCryptic exon inclusion in critical neuronal genes (e.g., STMN2, UNC13A)\nReferences: Brown et al., 2022; Pasquini et al., 2024.\nImpaired RNA metabolism across thousands of transcripts\nDisruption of synaptic vesicle cycling and axonal maintenance\nWidespread transcriptional deregulation in vulnerable neurons\n\nConcomitantly, cytoplasmic gain-of-function mechanisms contribute to toxicity:\n\nAberrant TDP-43 aggregation\nDysregulated stress granules\nSequestration of RNA-binding proteins\nImpairment of nucleocytoplasmic transport\nReferences: Sirkis et al., 2019; Grossman et al., 2023.\n\nNeuropathologically, FTLD-TDP is subdivided into four major patterns (types A–D) based on laminar distribution and morphology of TDP-43 inclusions. The type B pattern is the most common in sporadic disease and in C9orf72 expansion carriers.\nTranscriptomic studies consistently show:\n\nDownregulation of neuronal and synaptic programs\nUpregulation of immune and inflammatory pathways (CHI3L1/CHI3L2, SPP1, complement)\nSelective vulnerability of excitatory neurons and layer-specific cortical circuits\nAstroglial and microglial activation\nAltered oligodendrocyte function\n\nRecent single-nucleus studies have identified STMN2 loss as a central molecular hallmark linked directly to TDP-43 nuclear depletion, with strong correlation to disease severity.\n\n\n\nBelow is a concise table summarizing the key FTLD neuropathological markers relevant for your study (ACSL3, lncRNA, DPRs, RNA foci, pTDP-43, STMN2), their origin, and pathological impact.\n\n\n\n\n\n\n\n\nMarker\nOrigin / Biological Basis\nPathological Impact\n\n\n\n\nACSL3\nEnzyme involved in long-chain fatty-acid metabolism; upregulated in C9orf72 HRE brains.\nReflects metabolic reprogramming; associated with glial activation and neuronal stress.\n\n\nlncRNAs\nLong non-coding RNAs transcribed from expanded sense/antisense C9orf72 repeat sequences.\nContribute to RNA toxicity; sequester splicing factors; correlate with disease severity.\n\n\nRNA foci (sense & antisense)\nNuclear aggregates of expanded G4C2/G2C4 transcripts.\nSequester RBPs; disrupt splicing and RNA metabolism; correlate with neuronal vulnerability.\n\n\npolyGA\nDipeptide repeat protein generated by RAN translation (sense transcript).\nMost abundant DPR; impairs proteostasis and protein clearance pathways; forms large cytoplasmic inclusions.\n\n\npolyGP\nDPR generated from both sense and antisense RAN translation.\nLess toxic; strong biofluid biomarker of repeat expansion activity.\n\n\npolyGR\nArginine-rich DPR with high nucleolar and ribosomal toxicity.\nHighly toxic; disrupts ribosomes, translation, stress granules, and nucleocytoplasmic transport.\n\n\npTDP-43\nPhosphorylated, cleaved, cytoplasmic TDP-43 aggregates.\nHallmark of FTLD-TDP; indicates nuclear TDP-43 loss-of-function and cytoplasmic gain-of-function toxicity.\n\n\nSTMN2\nAxonal maintenance gene aberrantly spliced due to TDP-43 nuclear depletion.\nSensitive marker of TDP-43 dysfunction; its reduction correlates with disease severity and neuronal loss."
  },
  {
    "objectID": "Introduction/Background.html#c9",
    "href": "Introduction/Background.html#c9",
    "title": "Background",
    "section": "",
    "text": "The C9orf72 hexanucleotide repeat expansion (HRE) is the most common genetic cause of both FTLD and amyotrophic lateral sclerosis (ALS). The pathogenic expansion of GGGGCC (G4C2) repeats leads to at least three convergent mechanisms:\n\nHaploinsufficiency of C9orf72, reducing levels of a protein involved in autophagy–lysosomal function and endosomal trafficking.\nReferences: PMC3430713; Nature 2019 reviews.\nRNA toxicity, where expanded sense and antisense repeat-containing transcripts accumulate in the nucleus, forming RNA foci that sequester numerous RNA-binding proteins and disrupt splicing and RNA homeostasis.\nReferences: Nature Neuroscience; Acta Neuropathologica 2018.\nDipeptide repeat proteins (DPRs) produced by repeat-associated non-AUG (RAN) translation, including poly-GA, poly-GP, poly-GR, poly-PA, and poly-PR, which accumulate in cytoplasmic inclusions and disrupt nucleocytoplasmic transport, ribosomal function, and proteostasis.\nReferences: Cell 2015; Nature Genetics 2013; Acta Neuropathol 2018.\n\nNeuropathologically, FTLD-C9 is characterized by:\n\nAbundant DPR inclusions (poly-GA &gt; poly-GP &gt; poly-GR),\nWidespread RNA foci (sense and antisense),\nVariable TDP-43 pathology (usually FTLD-TDP type B),\nMarked vulnerability of extratelencephalic pathways, including corticospinal tracts and cerebellum,\nPronounced neuroinflammation and glial activation.\n\nTranscriptomic studies reveal a consistent pattern of synaptic dysfunction, altered neuronal excitability, astrocytic and microglial activation, vesicular trafficking deficits, and downregulation of STMN2 due to TDP-43 dysfunction. Single-cell analyses demonstrate that specific excitatory neuron populations (e.g., RORB-positive L4/5 neurons) are highly vulnerable, while glial populations show diverse inflammatory signatures.\nThe combination of RNA foci, DPR toxicity, and TDP-43 dyshomeostasis creates a multifactorial, cell-type-dependent cascade culminating in widespread cortical degeneration."
  },
  {
    "objectID": "Introduction/Background.html#sporadic-tdp",
    "href": "Introduction/Background.html#sporadic-tdp",
    "title": "Background",
    "section": "",
    "text": "Sporadic FTLD-TDP comprises the largest cluster of FTLD cases and is defined by the intracellular accumulation of phosphorylated, ubiquitinated, and cleaved forms of TDP-43, a ubiquitously expressed RNA-binding protein essential for splicing repression, cryptic exon suppression, stress-granule dynamics, and mRNA transport.\nLoss of nuclear TDP-43 function leads to:\n\nCryptic exon inclusion in critical neuronal genes (e.g., STMN2, UNC13A)\nReferences: Brown et al., 2022; Pasquini et al., 2024.\nImpaired RNA metabolism across thousands of transcripts\nDisruption of synaptic vesicle cycling and axonal maintenance\nWidespread transcriptional deregulation in vulnerable neurons\n\nConcomitantly, cytoplasmic gain-of-function mechanisms contribute to toxicity:\n\nAberrant TDP-43 aggregation\nDysregulated stress granules\nSequestration of RNA-binding proteins\nImpairment of nucleocytoplasmic transport\nReferences: Sirkis et al., 2019; Grossman et al., 2023.\n\nNeuropathologically, FTLD-TDP is subdivided into four major patterns (types A–D) based on laminar distribution and morphology of TDP-43 inclusions. The type B pattern is the most common in sporadic disease and in C9orf72 expansion carriers.\nTranscriptomic studies consistently show:\n\nDownregulation of neuronal and synaptic programs\nUpregulation of immune and inflammatory pathways (CHI3L1/CHI3L2, SPP1, complement)\nSelective vulnerability of excitatory neurons and layer-specific cortical circuits\nAstroglial and microglial activation\nAltered oligodendrocyte function\n\nRecent single-nucleus studies have identified STMN2 loss as a central molecular hallmark linked directly to TDP-43 nuclear depletion, with strong correlation to disease severity."
  },
  {
    "objectID": "Introduction/Background.html#neuropathologycal-markers",
    "href": "Introduction/Background.html#neuropathologycal-markers",
    "title": "Background",
    "section": "",
    "text": "Below is a concise table summarizing the key FTLD neuropathological markers relevant for your study (ACSL3, lncRNA, DPRs, RNA foci, pTDP-43, STMN2), their origin, and pathological impact.\n\n\n\n\n\n\n\n\nMarker\nOrigin / Biological Basis\nPathological Impact\n\n\n\n\nACSL3\nEnzyme involved in long-chain fatty-acid metabolism; upregulated in C9orf72 HRE brains.\nReflects metabolic reprogramming; associated with glial activation and neuronal stress.\n\n\nlncRNAs\nLong non-coding RNAs transcribed from expanded sense/antisense C9orf72 repeat sequences.\nContribute to RNA toxicity; sequester splicing factors; correlate with disease severity.\n\n\nRNA foci (sense & antisense)\nNuclear aggregates of expanded G4C2/G2C4 transcripts.\nSequester RBPs; disrupt splicing and RNA metabolism; correlate with neuronal vulnerability.\n\n\npolyGA\nDipeptide repeat protein generated by RAN translation (sense transcript).\nMost abundant DPR; impairs proteostasis and protein clearance pathways; forms large cytoplasmic inclusions.\n\n\npolyGP\nDPR generated from both sense and antisense RAN translation.\nLess toxic; strong biofluid biomarker of repeat expansion activity.\n\n\npolyGR\nArginine-rich DPR with high nucleolar and ribosomal toxicity.\nHighly toxic; disrupts ribosomes, translation, stress granules, and nucleocytoplasmic transport.\n\n\npTDP-43\nPhosphorylated, cleaved, cytoplasmic TDP-43 aggregates.\nHallmark of FTLD-TDP; indicates nuclear TDP-43 loss-of-function and cytoplasmic gain-of-function toxicity.\n\n\nSTMN2\nAxonal maintenance gene aberrantly spliced due to TDP-43 nuclear depletion.\nSensitive marker of TDP-43 dysfunction; its reduction correlates with disease severity and neuronal loss."
  },
  {
    "objectID": "Introduction/Introduction.html",
    "href": "Introduction/Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Frontotemporal lobar degeneration (FTLD) comprises a heterogeneous group of neurodegenerative disorders marked by progressive impairment in behaviour, language, and executive functions. Among its molecular subtypes, FTLD with TDP-43 pathology (FTLD-TDP) and FTLD caused by C9orf72 hexanucleotide repeat expansions (FTLD-C9) represent the most frequent forms. Although these subtypes share TDP-43 dysregulation as a pathological hallmark, they differ substantially in their upstream disease mechanisms: RNA foci and dipeptide repeat (DPR) toxicity in FTLD-C9 versus primary TDP-43 mislocalization and aggregation in sporadic FTLD-TDP.\nBulk RNA-seq studies have shown broad alterations in synaptic, inflammatory, metabolic, and RNA-processing pathways in FTLD. Yet, bulk tissue obscures the cell-type specificity of these changes—an essential dimension given the layer-specific vulnerability of excitatory neurons, the selective involvement of interneurons, and the diverse responses of astrocytes, microglia, oligodendrocytes, and vascular cells. Recent single-nucleus sequencing studies underscore the importance of cell-type and cell-state–specific transcriptional programs, but comprehensive integrative analyses across disease subtypes and neuropathological markers remain lacking.\nThe emergence of Bayesian deconvolution frameworks, combined with high-resolution snRNA-seq references such as Pineda et al. (Synapse ID: syn51105515), now enables cell-state–resolved inference from bulk data. Such approaches provide an unprecedented opportunity to map FTLD-associated transcriptional dysregulation to specific neuronal and non-neuronal compartments, and to integrate these changes with quantitative neuropathological measures such as pTDP-43 burden, STMN2 loss, RNA foci density, and DPR pathology.\nBy leveraging four independent bulk RNA-seq cohorts—including two newly generated datasets from Sant Pau and two large external datasets—it becomes possible to identify reproducible, cell-type–specific features of FTLD-C9 and FTLD-TDP, and to uncover convergent and divergent disease mechanisms across subtypes."
  },
  {
    "objectID": "Introduction/Introduction.html#hypothesis",
    "href": "Introduction/Introduction.html#hypothesis",
    "title": "Introduction",
    "section": "Hypothesis",
    "text": "Hypothesis\nWe hypothesized that:\n\nFTLD-C9 and sporadic FTLD-TDP exhibit distinct and cell-type–specific transcriptional alterations, particularly within excitatory neurons and glial populations, reflecting their divergent upstream mechanisms (repeat-associated toxicity vs. primary TDP-43 dysfunction).\nBayesian deconvolution using the Pineda et al. single-nucleus reference can resolve these subtype-specific differences at both cell type and cell state resolution, revealing transcriptional programs obscured in bulk analyses.\nNeuropathological markers—including RNA foci (sense/antisense), dipeptide repeat proteins (polyGA, polyGP, polyGR), ACSL3, lncRNAs, pTDP-43, and STMN2 levels—correlate with discrete transcriptional signatures within specific cell states, reflecting coordinated pathological processes rather than global tissue-level effects.\nThese cell-type–specific signatures and their associated co-expression modules are reproducible across independent external datasets (Menden et al. and Pottier et al.), supporting their generality as molecular hallmarks of FTLD-C9 and FTLD-TDP."
  },
  {
    "objectID": "Introduction/Introduction.html#objectives",
    "href": "Introduction/Introduction.html#objectives",
    "title": "Introduction",
    "section": "Objectives",
    "text": "Objectives\nTo test these hypotheses, we pursued the following objectives:\n\n1. Characterize cell-type–specific transcriptional alterations in FTLD-C9 and FTLD-TDP\n\nPerform bulk differential gene expression analyses in newly sequenced Sant Pau FTLD-C9 and FTLD-TDP cohorts.\nApply BayesPrism deconvolution using the Pineda et al. single-cell reference to derive cell-type– and cell-state–specific expression matrices.\n\n\n\n2. Quantify disease-associated alterations in inferred cell-state composition\n\nCompare arcsin-transformed cellular proportions between FTLD cases and healthy controls.\nIdentify specific neuronal, glial, vascular, and immune cell states enriched or depleted in each FTLD subtype.\n\n\n\n3. Link transcriptional changes and cell-state proportions to neuropathological markers\n\nCorrelate cell-state proportions and gene expression with ACSL3, lncRNAs, DPR burden (polyGA, polyGP, polyGR), RNA foci, pTDP-43 levels, and STMN2 expression.\nDetermine subtype-specific molecular markers of disease progression and vulnerability.\n\n\n\n4. Identify and functionally annotate cell-state–specific co-expression modules\n\nConstruct hdWGCNA networks from deconvolved expression profiles.\nIdentify modules associated with disease status and neuropathological markers.\nCharacterize enriched GO pathways across excitatory, inhibitory, glial, vascular, and immune cell states.\n\n\n\n5. Validate findings across two independent external datasets\n\nReplicate differential expression, cell-state composition alterations, and module-level changes in the Menden et al. and Pottier et al. cohorts.\nAssess reproducibility using overlap statistics (Jaccard index, GeneOverlap) and module gene preservation.\n\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Methods/Bulk_dea.html",
    "href": "Methods/Bulk_dea.html",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "Bulk RNA-sequencing provides a comprehensive measurement of transcriptional activity at the tissue level and remains the foundation for molecular characterization in neurodegenerative disease. In FTLD, bulk analyses have repeatedly identified widespread alterations in synaptic signaling, immune activation, vesicle trafficking, lipid metabolism, and RNA-processing pathways. However, reproducibly detecting these signatures requires rigorous statistical modeling due to subtle but biologically meaningful differences in gene expression, limited sample sizes typical of post-mortem cohorts, and technical variability between sequencing libraries.\nTo ensure robust inference across the four cohorts studied, differential expression was performed using edgeR, a negative binomial framework specifically designed for RNA-seq count data. The quasi-likelihood (QL) pipeline implemented in edgeR provides improved control of false positives and greater stability in small cohorts, making it an appropriate choice for FTLD studies where subtle expression changes may reflect early or cell-type–specific pathological processes.\n\n\n\n\n\nRaw gene-level count matrices were generated from poly(A)-selected bulk RNA-sequencing of frontal cortex tissue. Analyses were performed independently for:\n\nSant Pau FTLD-C9 vs. controls\nSant Pau FTLD-TDP vs. control.\nMenden et al. FTLD-C9 vs. controls\nPottier et al. FTLD-TDP vs. controls\n\nTo harmonize analyses, each dataset underwent identical preprocessing:\n\nRemoval of low-quality samples or ambiguous diagnostic classifications.\nFiltering of genes using filterByExpr(), retaining only transcripts with sufficient expression to yield reliable tests.\n\n-   Typical retained genes: **\\~21k** per cohort\n\nConstruction of DGEList objects for each comparison.\n\n\n\n\nSequencing depth and composition biases were corrected using:\n\nTrimmed Mean of M-values (TMM) normalization, generating effective library sizes.\nConversion to log2-counts per million (logCPM) for exploratory diagnostics (PCA, MDS).\n\nTo account for biological and technical variability:\n\nDispersion estimates were obtained using estimateDisp(),\nFollowed by glmQLFit() to fit quasi-likelihood negative binomial generalized linear models.\n\nWhere available, surrogate variables (SVs) estimated from the bulk data were included as covariates to control for latent confounders.\n\n\n\nFor each dataset, a design matrix modeled diagnostic group as the primary variable of interest:\n\nFTLD-C9 vs. Healthy\nFTLD-TDP vs. Healthy\n\nControls were defined as the reference level.\nContrast vectors were constructed to explicitly test for group differences.\nThis yielded gene-wise quasi-likelihood F-tests or likelihood ratio tests (glmQLFTest or glmLRT).\n\n\n\nAll p-values were adjusted using the Benjamini–Hochberg FDR procedure.\nGenes were considered significantly differentially expressed when:\n\nFDR &lt; 0.05\n\nFor interpretability, the following statistics were extracted:\n\nFold change (FC)\nlog2 fold change (logFC)\nRaw and adjusted p-values\nMean expression per group\n\n\n\n\nTo assess robustness:\n\nDifferential expression results from the Sant Pau FTLD-C9 cohort were compared with the Menden et al. FTLD-C9 dataset.\nFTLD-TDP results were compared to Pottier et al.\nOverlap significance was evaluated using GeneOverlap tests and Jaccard indices.\n\nThis approach enabled identification of cell-type–agnostic signatures that are reproducible across cohorts and subtype-specific signatures that distinguish FTLD-C9 from FTLD-TDP.\n\n\n\n\nThe bulk RNA-seq analyses were designed to:\n\nIdentify transcriptional signatures distinguishing FTLD-C9, FTLD-TDP, and healthy controls, providing a global overview of disease-associated dysregulation.\nEstablish baseline transcriptomic differences prior to deconvolution, enabling direct comparison with cell-state–resolved results obtained using BayesPrism.\nServe as a foundation for validation, enabling cross-cohort consistency checks with large, published datasets (Menden et al., Pottier et al.).\nGenerate disease-relevant gene lists for downstream functional enrichment, co-expression network analyses (hdWGCNA), and neuropathology correlation analyses.\nProvide independent evidence for known FTLD mechanisms, including:\n\nsynaptic deficits,\nglial and immune activation,\nmetabolic and mitochondrial disruption,\nTDP-43 target dysregulation (e.g., STMN2, UNC13A).\n\n\nBy integrating these bulk findings with cell-type–resolved analyses, we were able to map global transcriptomic alterations to their cellular origins and characterize convergent and divergent molecular pathways across FTLD-C9 and FTLD-TDP.\n\n# EDGER on Bulk RNASEQ LRT\n\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\n################################################################################\n# Paths and parameters\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\"  # Path to bulk RNA-seq count matrix CSV\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD/TDP_LRT\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"  # Same condition(s) you want to test\n\n################################################################################\n\n# Load sample metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, sheetIndex = 1)\ncase_legend$sample.ID &lt;- paste0(\"X\", case_legend$sample.ID)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Load bulk count data\nbulk_data &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\n# Make sure rownames (sample IDs) match those in case_legend\nbulk_data &lt;- t(bulk_data)\n\n# Keep only samples in both case_legend and bulk_data\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\n\n# Create output directory\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Process each condition (here just one condition \"TDP\")\nfor (condition in CONDITIONS) {\n  \n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    # Subset metadata for groups of interest\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    # Select bulk samples present in metadata\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    \n    # Replace missing values with small value (if any)\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)  # transpose counts\n    \n    # Filter low expression genes\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes=FALSE]\n    \n    # Normalize\n    y &lt;- calcNormFactors(y)\n    \n    # Plot average log CPM\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    # MD plot\n    plot_filename &lt;- file.path(condition_folder, \"MD_plot.png\")\n    png(file = plot_filename)\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    # Design matrix\n    design &lt;- model.matrix(~ 0 + group)\n    colnames(design) &lt;- levels(group)\n    \n    # Estimate dispersion\n    y &lt;- estimateDisp(y, design)\n    \n    # Fit model\n    fit &lt;- glmFit(y, design)\n    \n    # Contrast\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    \n    # Decide DE\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    # Add adjusted p-values and results\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    \n    # Save results\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    # Histogram plot of AveLogCPM\n    plot_filename &lt;- file.path(condition_folder, \"histogram_plot.png\")\n    png(file = plot_filename)\n    hist(AveLogCPM)\n    dev.off()\n    \n    # BCV plot\n    plot_filename &lt;- file.path(condition_folder, \"BCV_plot.png\")\n    png(file = plot_filename)\n    plotBCV(y)\n    dev.off()\n    \n    # MD plot with DE status (volcano-like)\n    plot_filename &lt;- file.path(condition_folder, \"MD_res_plot.png\")\n    png(file = plot_filename)\n    plotMD(res, status = is.de)\n    dev.off()\n    \n    # Heatmap top DE genes\n    logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n    tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n    o &lt;- order(tr$table$PValue)\n    top_genes &lt;- head(o, 30)\n    logCPM_top &lt;- logCPM[top_genes, ]\n    \n    plot_filename &lt;- file.path(condition_folder, \"Heatmap.png\")\n    png(file = plot_filename)\n    coolmap(logCPM_top, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n################################################################################\n# NEW LRTFIT\n\n# EDGER on Bulk RNASEQ\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/NEW_LRT_SVAcorrect/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- gsub(\"-\", \"\\\\.\", rownames(case_legend))\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\", ]\ncase_legend$GROUP[case_legend$GROUP == \"Control\"] &lt;- \"Healthy\"\ncase_legend$GROUP[case_legend$GROUP != \"Healthy\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- factor(case_legend$GROUP)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n\n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n\n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n\n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n\n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n\n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n\n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n\n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n\n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n################################################################################\n# FTLD C9\n\n# EDGER on Bulk RNASEQ\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD_C9_sv\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, row.names = 1, sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \",\")\ncase_legend$rn &lt;- rownames(case_legend)\nrownames(surrogate_variables) &lt;- gsub(\"long\", \"\", rownames(surrogate_variables))\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$sample.ID &lt;- case_legend$rn \nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\nrownames(bulk_raw) &lt;- gsub(\"X\", \"\", rownames(bulk_raw))\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n################################################################################\n# Rimmod\n\n# EDGER on Bulk RNASEQ\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/Rimmod_LRT_SV_2/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- rownames(case_legend)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-GRN\", ]\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-MAPT\", ]\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode != \"Healthy\"] &lt;- \"C9orf72\"\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \n\nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1, sep = \",\")\nbulk_raw &lt;-t(bulk_raw)\n#colnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\n\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}"
  },
  {
    "objectID": "Methods/Bulk_dea.html#rationale",
    "href": "Methods/Bulk_dea.html#rationale",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "Bulk RNA-sequencing provides a comprehensive measurement of transcriptional activity at the tissue level and remains the foundation for molecular characterization in neurodegenerative disease. In FTLD, bulk analyses have repeatedly identified widespread alterations in synaptic signaling, immune activation, vesicle trafficking, lipid metabolism, and RNA-processing pathways. However, reproducibly detecting these signatures requires rigorous statistical modeling due to subtle but biologically meaningful differences in gene expression, limited sample sizes typical of post-mortem cohorts, and technical variability between sequencing libraries.\nTo ensure robust inference across the four cohorts studied, differential expression was performed using edgeR, a negative binomial framework specifically designed for RNA-seq count data. The quasi-likelihood (QL) pipeline implemented in edgeR provides improved control of false positives and greater stability in small cohorts, making it an appropriate choice for FTLD studies where subtle expression changes may reflect early or cell-type–specific pathological processes."
  },
  {
    "objectID": "Methods/Bulk_dea.html#analytical-strategy",
    "href": "Methods/Bulk_dea.html#analytical-strategy",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "Raw gene-level count matrices were generated from poly(A)-selected bulk RNA-sequencing of frontal cortex tissue. Analyses were performed independently for:\n\nSant Pau FTLD-C9 vs. controls\nSant Pau FTLD-TDP vs. control.\nMenden et al. FTLD-C9 vs. controls\nPottier et al. FTLD-TDP vs. controls\n\nTo harmonize analyses, each dataset underwent identical preprocessing:\n\nRemoval of low-quality samples or ambiguous diagnostic classifications.\nFiltering of genes using filterByExpr(), retaining only transcripts with sufficient expression to yield reliable tests.\n\n-   Typical retained genes: **\\~21k** per cohort\n\nConstruction of DGEList objects for each comparison.\n\n\n\n\nSequencing depth and composition biases were corrected using:\n\nTrimmed Mean of M-values (TMM) normalization, generating effective library sizes.\nConversion to log2-counts per million (logCPM) for exploratory diagnostics (PCA, MDS).\n\nTo account for biological and technical variability:\n\nDispersion estimates were obtained using estimateDisp(),\nFollowed by glmQLFit() to fit quasi-likelihood negative binomial generalized linear models.\n\nWhere available, surrogate variables (SVs) estimated from the bulk data were included as covariates to control for latent confounders.\n\n\n\nFor each dataset, a design matrix modeled diagnostic group as the primary variable of interest:\n\nFTLD-C9 vs. Healthy\nFTLD-TDP vs. Healthy\n\nControls were defined as the reference level.\nContrast vectors were constructed to explicitly test for group differences.\nThis yielded gene-wise quasi-likelihood F-tests or likelihood ratio tests (glmQLFTest or glmLRT).\n\n\n\nAll p-values were adjusted using the Benjamini–Hochberg FDR procedure.\nGenes were considered significantly differentially expressed when:\n\nFDR &lt; 0.05\n\nFor interpretability, the following statistics were extracted:\n\nFold change (FC)\nlog2 fold change (logFC)\nRaw and adjusted p-values\nMean expression per group\n\n\n\n\nTo assess robustness:\n\nDifferential expression results from the Sant Pau FTLD-C9 cohort were compared with the Menden et al. FTLD-C9 dataset.\nFTLD-TDP results were compared to Pottier et al.\nOverlap significance was evaluated using GeneOverlap tests and Jaccard indices.\n\nThis approach enabled identification of cell-type–agnostic signatures that are reproducible across cohorts and subtype-specific signatures that distinguish FTLD-C9 from FTLD-TDP."
  },
  {
    "objectID": "Methods/Bulk_dea.html#analytical-goals-of-the-bulk-differential-expression-component",
    "href": "Methods/Bulk_dea.html#analytical-goals-of-the-bulk-differential-expression-component",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "The bulk RNA-seq analyses were designed to:\n\nIdentify transcriptional signatures distinguishing FTLD-C9, FTLD-TDP, and healthy controls, providing a global overview of disease-associated dysregulation.\nEstablish baseline transcriptomic differences prior to deconvolution, enabling direct comparison with cell-state–resolved results obtained using BayesPrism.\nServe as a foundation for validation, enabling cross-cohort consistency checks with large, published datasets (Menden et al., Pottier et al.).\nGenerate disease-relevant gene lists for downstream functional enrichment, co-expression network analyses (hdWGCNA), and neuropathology correlation analyses.\nProvide independent evidence for known FTLD mechanisms, including:\n\nsynaptic deficits,\nglial and immune activation,\nmetabolic and mitochondrial disruption,\nTDP-43 target dysregulation (e.g., STMN2, UNC13A).\n\n\nBy integrating these bulk findings with cell-type–resolved analyses, we were able to map global transcriptomic alterations to their cellular origins and characterize convergent and divergent molecular pathways across FTLD-C9 and FTLD-TDP.\n\n# EDGER on Bulk RNASEQ LRT\n\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\n################################################################################\n# Paths and parameters\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/TDP.csv\"  # Path to bulk RNA-seq count matrix CSV\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD/TDP_LRT\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"  # Same condition(s) you want to test\n\n################################################################################\n\n# Load sample metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, sheetIndex = 1)\ncase_legend$sample.ID &lt;- paste0(\"X\", case_legend$sample.ID)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Load bulk count data\nbulk_data &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\n# Make sure rownames (sample IDs) match those in case_legend\nbulk_data &lt;- t(bulk_data)\n\n# Keep only samples in both case_legend and bulk_data\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\n\n# Create output directory\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Process each condition (here just one condition \"TDP\")\nfor (condition in CONDITIONS) {\n  \n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    # Subset metadata for groups of interest\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    # Select bulk samples present in metadata\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    \n    # Replace missing values with small value (if any)\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)  # transpose counts\n    \n    # Filter low expression genes\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes=FALSE]\n    \n    # Normalize\n    y &lt;- calcNormFactors(y)\n    \n    # Plot average log CPM\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    # MD plot\n    plot_filename &lt;- file.path(condition_folder, \"MD_plot.png\")\n    png(file = plot_filename)\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    # Design matrix\n    design &lt;- model.matrix(~ 0 + group)\n    colnames(design) &lt;- levels(group)\n    \n    # Estimate dispersion\n    y &lt;- estimateDisp(y, design)\n    \n    # Fit model\n    fit &lt;- glmFit(y, design)\n    \n    # Contrast\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    \n    # Decide DE\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    # Add adjusted p-values and results\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    \n    # Save results\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    # Histogram plot of AveLogCPM\n    plot_filename &lt;- file.path(condition_folder, \"histogram_plot.png\")\n    png(file = plot_filename)\n    hist(AveLogCPM)\n    dev.off()\n    \n    # BCV plot\n    plot_filename &lt;- file.path(condition_folder, \"BCV_plot.png\")\n    png(file = plot_filename)\n    plotBCV(y)\n    dev.off()\n    \n    # MD plot with DE status (volcano-like)\n    plot_filename &lt;- file.path(condition_folder, \"MD_res_plot.png\")\n    png(file = plot_filename)\n    plotMD(res, status = is.de)\n    dev.off()\n    \n    # Heatmap top DE genes\n    logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n    tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n    o &lt;- order(tr$table$PValue)\n    top_genes &lt;- head(o, 30)\n    logCPM_top &lt;- logCPM[top_genes, ]\n    \n    plot_filename &lt;- file.path(condition_folder, \"Heatmap.png\")\n    png(file = plot_filename)\n    coolmap(logCPM_top, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n################################################################################\n# NEW LRTFIT\n\n# EDGER on Bulk RNASEQ\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/DATA/merged_gene_count_FCX.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/NEW_LRT_SVAcorrect/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"TDP\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- gsub(\"-\", \"\\\\.\", rownames(case_legend))\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\", ]\ncase_legend$GROUP[case_legend$GROUP == \"Control\"] &lt;- \"Healthy\"\ncase_legend$GROUP[case_legend$GROUP != \"Healthy\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- factor(case_legend$GROUP)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n\n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n\n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n\n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n\n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n\n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n\n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n\n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n\n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n\n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n\n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n\n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n################################################################################\n# FTLD C9\n\n# EDGER on Bulk RNASEQ\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/DATA/C9orf72.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/METADATA/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/FTLD_C9_sv\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.xlsx(CASE_LEGEND, row.names = 1, sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \",\")\ncase_legend$rn &lt;- rownames(case_legend)\nrownames(surrogate_variables) &lt;- gsub(\"long\", \"\", rownames(surrogate_variables))\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$sample.ID &lt;- case_legend$rn \nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1)\nbulk_raw &lt;-t(bulk_raw)\nrownames(bulk_raw) &lt;- gsub(\"X\", \"\", rownames(bulk_raw))\ncolnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\nrownames(bulk_data) &lt;- gsub(\"-\", \".\", rownames(bulk_data))\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}\n\n\n################################################################################\n# Rimmod\n\n# EDGER on Bulk RNASEQ\nlibrary(edgeR)\nlibrary(dplyr)\nlibrary(GO.db)\nlibrary(xlsx)\n\nBULK_COUNTS_PATH &lt;- \"/media/jaumatell/datos/URI/PROJECTE_SEURAT_BP/RiMod/rnaseq_salmon_results/counts.csv\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/BULK_DEA/Rimmod_LRT_SV_2/\"\nSURROGATE_VARIABLES &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\nREFERENCE_GROUP &lt;- \"Healthy\"\nCONDITIONS &lt;- \"C9orf72\"\n\n# Load metadata\ncase_legend &lt;- read.delim(CASE_LEGEND, row.names = 1, sep = \"\\t\")\ncase_legend$sample.ID &lt;- rownames(case_legend)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-GRN\", ]\ncase_legend &lt;- case_legend[case_legend$DiseaseCode != \"FTD-MAPT\", ]\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode != \"Healthy\"] &lt;- \"C9orf72\"\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\n\n\n# Load surrogate variables \nsurrogate_variables &lt;- read.csv(SURROGATE_VARIABLES, row.names = 1, sep = \"\\t\")\ncase_legend$rn &lt;- rownames(case_legend)\nsurrogate_variables$rn &lt;- rownames(surrogate_variables)\n\ncase_legend &lt;- merge(case_legend, surrogate_variables, by.x = \"rn\", by.y = \"rn\")\ncase_legend$rn &lt;- NULL\nsurrogate_variables$rn &lt;- NULL\n\n# Load bulk \n\nbulk_raw &lt;- read.csv(BULK_COUNTS_PATH, row.names = 1, sep = \",\")\nbulk_raw &lt;-t(bulk_raw)\n#colnames(bulk_raw) &lt;- bulk_raw[\"GeneName\", ]\nbulk_data &lt;- bulk_raw[!(rownames(bulk_raw) %in% c(\"Chromosome\", \"Start\", \"End\", \"Length\", \"GeneName\", \"GeneBiotype\")), ]\n\n\ncommon_samples &lt;- intersect(case_legend$sample.ID, rownames(bulk_data))\ncase_legend &lt;- case_legend[match(common_samples, case_legend$sample.ID), ]\nbulk_data &lt;- bulk_data[common_samples, ]\nrownames(bulk_data) &lt;- common_samples\ncolnames_bulk &lt;- colnames(bulk_data)\nrownames_bulk &lt;- rownames(bulk_data)\nbulk_data &lt;- as.data.frame(apply(bulk_data, 2, function(x) as.numeric(trimws(x))))\n\ncolnames(bulk_data) &lt;-colnames_bulk\nrownames(bulk_data) &lt;- rownames_bulk\n\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nfor (condition in CONDITIONS) {\n  condition_folder &lt;- file.path(OUTPUT_DIRECTORY, condition)\n  if (!file.exists(condition_folder)) {\n    dir.create(condition_folder, recursive = TRUE)\n  }\n  \n  tryCatch({\n    comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n    comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n    comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n    \n    common_ids &lt;- intersect(comparison_data$sample.ID, rownames(bulk_data))\n    bulk_subset &lt;- bulk_data[common_ids, ]\n    bulk_ordered &lt;- bulk_subset[match(comparison_data$sample.ID, rownames(bulk_subset)), ]\n    bulk_ordered[is.na(bulk_ordered)] &lt;- 1e-8\n    \n    group &lt;- factor(comparison_data$group_ID)\n    y &lt;- DGEList(counts = t(bulk_ordered), group = group)\n    \n    keep &lt;- filterByExpr(y, group = group)\n    y &lt;- y[keep, , keep.lib.sizes = FALSE]\n    y &lt;- calcNormFactors(y)\n    AveLogCPM &lt;- aveLogCPM(y)\n    y &lt;- normLibSizes(y)\n    \n    png(file.path(condition_folder, \"MD_plot.png\"))\n    plotMD(y, column = 1)\n    abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n    dev.off()\n    \n    design &lt;- model.matrix(~ 0 + group + comparison_data$SV1, data = comparison_data)\n    colnames(design) &lt;- c(levels(group),\"SV1\")\n    y &lt;- estimateDisp(y, design)\n    fit &lt;- glmFit(y, design)\n    contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n    res &lt;- glmLRT(fit, contrast = contrast, coef = 2)\n    is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n    \n    results_table &lt;- res$table\n    results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n    results_table &lt;- cbind(results_table, data.frame(is.de))\n    write.csv(results_table, file = file.path(condition_folder, \"results_adj_bulk.csv\"))\n    \n    png(file.path(condition_folder, \"histogram_plot.png\"))\n    hist(AveLogCPM)\n    dev.off()\n    \n    png(file.path(condition_folder, \"BCV_plot.png\"))\n    plotBCV(y)\n    dev.off()\n    \n    png(file.path(condition_folder, \"MD_res_plot.png\"))\n    plotMD(res, status = is.de)\n    dev.off()\n    \n  }, error = function(e) {\n    print(paste(\"Error processing condition:\", condition))\n    print(e)\n  })\n}"
  },
  {
    "objectID": "Methods/Sc_dea.html",
    "href": "Methods/Sc_dea.html",
    "title": "Single cell differencial expression analysis",
    "section": "",
    "text": "Bulk RNA-seq differential expression identifies tissue-level transcriptional changes but cannot distinguish whether these alterations originate from specific neuronal subclasses, glial populations, or vascular/immune lineages. Because FTLD pathology is known to selectively affect distinct cortical cell populations—such as RORB-expressing excitatory neurons, subsets of inhibitory neurons, and diverse astroglial and microglial states—bulk analysis alone provides limited biological resolution.\nTo overcome this limitation, we leveraged the cell-state–specific expression matrices generated by BayesPrism, which infer gene-level expression for each of the 44 transcriptional states defined in the Pineda et al. single-nucleus reference. These matrices represent “pseudobulk” expression profiles for each cell state within each sample, enabling differential gene expression analysis at single-cell resolution using bulk RNA-seq.\nApplying edgeR to these deconvolved matrices allows rigorous detection of transcriptional alterations within individual cell states, thereby identifying the precise cellular compartments responsible for disease-associated dysregulation in FTLD-C9 and FTLD-TDP.\n\n\n\n\nFor each sample, BayesPrism returned cell-state–specific gene expression estimates for all 43–44 states in the Pineda et al. reference. These matrices were:\n\naggregated per cell state across samples,\ntreated as pseudobulk counts,\n\nused as direct input to edgeR differential expression workflows.\nOnly cell states with sufficient expression and non-zero counts across samples were retained for statistical modeling.\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  # Handle other cases or file types\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\n\n\nFor each cell state:\n\nGenes with zero or near-zero counts were removed.\nOnly transcripts expressed in ≥1 sample were kept.\nMitochondrial, ribosomal, and sex-chromosome genes had already been removed at the BayesPrism stage.\naverage CPM\nnormalization\n\nThis ensured that differential expression reflected biologically meaningful changes rather than sparsity-related artifacts.\n\ncomparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n\n\n\n\nTo account for unwanted technical and biological variability:\n\nSurrogate variables (SVs) estimated from the bulk RNA-seq data were included as covariates in the design matrix, controlling for batch-like or hidden confounders.\n\nThis approach improves statistical robustness, especially in modest sample sizes typical of post-mortem FTLD cohorts.\n\n   group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n\n\n\n\nFor each of the 43–44 cell states:\n\nA design matrix modeled diagnostic status (FTLD-C9 or FTLD-TDP) with Healthy as the reference level.\nA single contrast per cell state tested the effect of disease.\nThe glmLRT() framework was applied.\n\nMultiple-testing correction within each cell state was performed using Benjamini–Hochberg FDR, with significance defined as:\n\nFDR &lt; 0.05\n\nFor each significant gene, the following metrics were extracted:\n\nlog2 fold change\nraw p-value and FDR-adjusted p-value\naverage CPM per condition\n\n\n     # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n\n\n\n\nTo assess reproducibility:\n\nCell-state DEGs from the Sant Pau FTLD-C9 dataset were compared with those from the Menden et al. dataset.\nCell-state DEGs from the Sant Pau FTLD-TDP dataset were compared with the Pottier et al. cohort.\n\nOverlap significance was quantified using:\n\nGeneOverlap statistics\nJaccard indices\n\nThis allowed identification of robust cell-state–specific signatures conserved across cohorts.\n\n# JACCARD \nlibrary(\"openxlsx\")\nlibrary(\"GeneOverlap\")\nlibrary(\"VennDiagram\")\nlibrary(\"grid\")\n\n# Define functions\n# Jaccard similarity index\njaccard_similarity &lt;- function(list1, list2) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  union_size &lt;- length(union(list1, list2))\n  return(intersection_size / union_size)\n}\n\n# Perform permutation test for p-value\npermutation_test &lt;- function(list1, list2, n_permutations = 10000) {\n  observed_jaccard &lt;- jaccard_similarity(list1, list2)\n  \n  permuted_jaccards &lt;- replicate(n_permutations, {\n    permuted_list1 &lt;- sample(list1)\n    permuted_list2 &lt;- sample(list2)\n    jaccard_similarity(permuted_list1, permuted_list2)\n  })\n  p_value &lt;- mean(permuted_jaccards &gt;= observed_jaccard)\n  return(p_value)\n}\n\nhypergeometric_test &lt;- function(list1, list2, total_population_size) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  total_genes &lt;- total_population_size  # Total number of possible genes\n  \n  # Number of DEGs in list1 and list2\n  K1 &lt;- length(list1)\n  K2 &lt;- length(list2)\n  \n  # Hypergeometric test to calculate p-value\n  p_value &lt;- phyper(intersection_size - 1, K1, total_genes - K1, K2, lower.tail = FALSE)\n  \n  return(p_value)\n}\n\n\n# TDP43\n\n# Define variables\nCStates &lt;- c(\n  \"Arterial\", \"DISC1_RELN\", \"Pericyte\", \"SMC\", \"TLE4_CCBE1\",\n  \"Capillary\", \"GFAP-neg\", \"PVALB_CEMIP\", \"SST_ADAMTS19\", \"TLE4_MEGF11\",\n  \"CDH4_CCK\", \"GFAP-pos\", \"PVALB_MYBPC1\", \"SST_BRINP3\", \"TLE4_SEMA3D\",\n  \"CDH4_SCGN\", \"LAMP5_CA3\", \"PVALB_PTHLH\", \"SST_GALNT14\", \"VAT1L_EYA4\",\n  \"CLMP_KCNMA1\", \"LAMP5_PMEPA1\", \"RORB_ADGRL4\", \"SST_NPY\", \"Venous\",\n  \"CLMP_PDGFRA\", \"Micro\", \"RORB_FOXO1\", \"VIP_CLSTN2\",\n  \"CUX2_RASGRF2\", \"Oligo\", \"RORB_LRRK1\", \"T_Cell\", \"VIP_HTR2C\",\n  \"CUX2_RORB\", \"OPC\", \"RORB_POU3F2\", \"THEMIS_NR4A2\", \"VIP_LAMA3\",\n  \"DISC1_CCK\", \"PCP4_NXPH2\", \"SCN4B_NEFH\", \"THEMIS_TMEM233\"\n)\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/CS_LRT/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/TDP_NEW/CS_Correcte\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Nou\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Nou\",\n  \"CU FTLD – Nou\", \"CD FTLD – Nou\", \n  \"JU FTLD – Nou\", \"JD FTLD – Nou\",\n  \"GU FTLD – Nou\", \"GD FTLD – Nou\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n    # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n\n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Control.1.TDP == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Control.1.TDP == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n\n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n\n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n\n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n\n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Nou\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Nou\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Nou\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Nou\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Nou\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Nou\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Nou\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Nou\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\n\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/TDP43_Validation_results_cs.csv\"))\n\n\n# C9\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/C9_NEW/CS\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Rimod\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Rimod\",\n  \"CU FTLD – Rimod\", \"CD FTLD – Rimod\", \n  \"JU FTLD – Rimod\", \"JD FTLD – Rimod\",\n  \"GU FTLD – Rimod\", \"GD FTLD – Rimod\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n  # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n  \n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.C9orf72 == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.c9orf72 == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n  \n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n  \n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n  \n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n  \n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Rimod\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Rimod\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Rimod\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Rimod\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Rimod\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Rimod\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Rimod\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Rimod\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/C9_Validation_results_cs.csv\"))\n\n\n\n\n\nThe single-cell differential expression module was designed to:\n\nIdentify the precise cell states driving disease-specific transcriptional alterations in FTLD-C9 and FTLD-TDP.\nDistinguish neuronal and glial subtypes with high DEG burden, pointing to selective cellular vulnerability.\nCharacterize lineage-specific pathways, such as synaptic dysfunction in RORB neurons or inflammatory activation in GFAP+ astrocytes.\nLink transcriptional changes to neuropathological markers, including STMN2 loss, pTDP-43 burden, and DPR/RNA foci density.\nEnable functional enrichment (GO/Metascape) for each cell state, revealing discrete biological processes altered in disease.\nProvide a unified cellular framework for comparing FTLD-C9 and FTLD-TDP, facilitating identification of shared and divergent mechanisms.\nSupport robust cross-validation with independent datasets, increasing confidence in the generalizability of cell-state transcriptional signatures.\n\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  conditions &lt;- \"C9orf72\"\n  for (condition in conditions){\n    \n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\nlibrary(edgeR, lib.loc = \"/home/jaumatell/R/x86_64-pc-linux-gnu-library/4.4/edgeR_4\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/DEG\"\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.xlsx(CASE_LEGEND,sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"TDP\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  rownames(data) &lt;-gsub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      \n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      data_ordered[is.na(data_ordered)] &lt;- 10e-8\n      \n      group &lt;- factor(comparison_data$group_ID)\n      y &lt;- DGEList(counts = t(data_ordered), group = group)\n      \n      # Plot average log CPM\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(y, column = 1)\n      abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n      dev.off()\n      \n      # Create design matrix\n      design &lt;- model.matrix(~ 0 + group)\n      colnames(design) &lt;- levels(group)\n      \n      # Estimate dispersion\n      y &lt;- estimateDisp(y, design)\n      fit &lt;- glmFit(y, design)\n      \n      #Differential expression analysis\n      contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n      res &lt;- glmLRT(fit, contrast = contrast)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      \n      # Save results\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      # Histogram\n      plot_filename &lt;- file.path(condition_folder, \"histogram_plot_h.png\")\n      png(file = plot_filename)\n      hist(AveLogCPM)\n      dev.off()\n      \n      # BCV plot\n      plot_filename &lt;- file.path(condition_folder, \"BCV_plot_h.png\")\n      png(file = plot_filename)\n      plotBCV(y)\n      dev.off()\n      \n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status = is.de)\n      dev.off()\n      \n      # Heatmap clustering\n      logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep = \"-\")\n      tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30], ]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n      dev.off()\n      \n      # Update summary DataFrame\n      df[condition, filename] &lt;- nrow(results_table[results_table$adj_pval &lt; 0.05, ])\n      \n    }, error = function(e) {\n      print(e)\n      df[condition, filename] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/CELL STATE ORIGINAL/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncovariate_data &lt;- read.csv(SV_COVARIATE, sep = \"\\t\")\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode %in% c(\"control\", \"FTD-C9\"), ]\n\n# 2. Renombrar valores dentro de DiseaseCode\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"FTD-C9\"] &lt;- \"C9orf72\"\n\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"C9orf72\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$RimodID, covariate_data$ID)]\n\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      common_ids &lt;- intersect(comparison_data$RimodID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$RimodID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$RimodID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$RimodID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# FTD\n#CT\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/NEW/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect\"\n\nREFERENCE_GROUP &lt;- \"Control\"\n\ncovariate_data &lt;- read.delim(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\",]\ncase_legend$GROUP[case_legend$GROUP != \"Control\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- as.factor(case_legend$GROUP)\n\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  \n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions){\n    condition &lt;- \"TDP\"\n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$FCX_ID, covariate_data$ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      comparison_data$FCX_ID &lt;- gsub(\"-\", \".\", comparison_data$FCX_ID)\n      common_ids &lt;- intersect(comparison_data$FCX_ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$FCX_ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$FCX_ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$FCX_ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))"
  },
  {
    "objectID": "Methods/Sc_dea.html#analytical-strategy",
    "href": "Methods/Sc_dea.html#analytical-strategy",
    "title": "Single cell differencial expression analysis",
    "section": "",
    "text": "For each sample, BayesPrism returned cell-state–specific gene expression estimates for all 43–44 states in the Pineda et al. reference. These matrices were:\n\naggregated per cell state across samples,\ntreated as pseudobulk counts,\n\nused as direct input to edgeR differential expression workflows.\nOnly cell states with sufficient expression and non-zero counts across samples were retained for statistical modeling.\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  # Handle other cases or file types\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\n\n\nFor each cell state:\n\nGenes with zero or near-zero counts were removed.\nOnly transcripts expressed in ≥1 sample were kept.\nMitochondrial, ribosomal, and sex-chromosome genes had already been removed at the BayesPrism stage.\naverage CPM\nnormalization\n\nThis ensured that differential expression reflected biologically meaningful changes rather than sparsity-related artifacts.\n\ncomparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n\n\n\n\nTo account for unwanted technical and biological variability:\n\nSurrogate variables (SVs) estimated from the bulk RNA-seq data were included as covariates in the design matrix, controlling for batch-like or hidden confounders.\n\nThis approach improves statistical robustness, especially in modest sample sizes typical of post-mortem FTLD cohorts.\n\n   group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n\n\n\n\nFor each of the 43–44 cell states:\n\nA design matrix modeled diagnostic status (FTLD-C9 or FTLD-TDP) with Healthy as the reference level.\nA single contrast per cell state tested the effect of disease.\nThe glmLRT() framework was applied.\n\nMultiple-testing correction within each cell state was performed using Benjamini–Hochberg FDR, with significance defined as:\n\nFDR &lt; 0.05\n\nFor each significant gene, the following metrics were extracted:\n\nlog2 fold change\nraw p-value and FDR-adjusted p-value\naverage CPM per condition\n\n\n     # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n\n\n\n\nTo assess reproducibility:\n\nCell-state DEGs from the Sant Pau FTLD-C9 dataset were compared with those from the Menden et al. dataset.\nCell-state DEGs from the Sant Pau FTLD-TDP dataset were compared with the Pottier et al. cohort.\n\nOverlap significance was quantified using:\n\nGeneOverlap statistics\nJaccard indices\n\nThis allowed identification of robust cell-state–specific signatures conserved across cohorts.\n\n# JACCARD \nlibrary(\"openxlsx\")\nlibrary(\"GeneOverlap\")\nlibrary(\"VennDiagram\")\nlibrary(\"grid\")\n\n# Define functions\n# Jaccard similarity index\njaccard_similarity &lt;- function(list1, list2) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  union_size &lt;- length(union(list1, list2))\n  return(intersection_size / union_size)\n}\n\n# Perform permutation test for p-value\npermutation_test &lt;- function(list1, list2, n_permutations = 10000) {\n  observed_jaccard &lt;- jaccard_similarity(list1, list2)\n  \n  permuted_jaccards &lt;- replicate(n_permutations, {\n    permuted_list1 &lt;- sample(list1)\n    permuted_list2 &lt;- sample(list2)\n    jaccard_similarity(permuted_list1, permuted_list2)\n  })\n  p_value &lt;- mean(permuted_jaccards &gt;= observed_jaccard)\n  return(p_value)\n}\n\nhypergeometric_test &lt;- function(list1, list2, total_population_size) {\n  intersection_size &lt;- length(intersect(list1, list2))\n  total_genes &lt;- total_population_size  # Total number of possible genes\n  \n  # Number of DEGs in list1 and list2\n  K1 &lt;- length(list1)\n  K2 &lt;- length(list2)\n  \n  # Hypergeometric test to calculate p-value\n  p_value &lt;- phyper(intersection_size - 1, K1, total_genes - K1, K2, lower.tail = FALSE)\n  \n  return(p_value)\n}\n\n\n# TDP43\n\n# Define variables\nCStates &lt;- c(\n  \"Arterial\", \"DISC1_RELN\", \"Pericyte\", \"SMC\", \"TLE4_CCBE1\",\n  \"Capillary\", \"GFAP-neg\", \"PVALB_CEMIP\", \"SST_ADAMTS19\", \"TLE4_MEGF11\",\n  \"CDH4_CCK\", \"GFAP-pos\", \"PVALB_MYBPC1\", \"SST_BRINP3\", \"TLE4_SEMA3D\",\n  \"CDH4_SCGN\", \"LAMP5_CA3\", \"PVALB_PTHLH\", \"SST_GALNT14\", \"VAT1L_EYA4\",\n  \"CLMP_KCNMA1\", \"LAMP5_PMEPA1\", \"RORB_ADGRL4\", \"SST_NPY\", \"Venous\",\n  \"CLMP_PDGFRA\", \"Micro\", \"RORB_FOXO1\", \"VIP_CLSTN2\",\n  \"CUX2_RASGRF2\", \"Oligo\", \"RORB_LRRK1\", \"T_Cell\", \"VIP_HTR2C\",\n  \"CUX2_RORB\", \"OPC\", \"RORB_POU3F2\", \"THEMIS_NR4A2\", \"VIP_LAMA3\",\n  \"DISC1_CCK\", \"PCP4_NXPH2\", \"SCN4B_NEFH\", \"THEMIS_TMEM233\"\n)\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/CS_LRT/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/TDP_NEW/CS_Correcte\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Nou\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Nou\",\n  \"CU FTLD – Nou\", \"CD FTLD – Nou\", \n  \"JU FTLD – Nou\", \"JD FTLD – Nou\",\n  \"GU FTLD – Nou\", \"GD FTLD – Nou\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n    # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"TDP/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"TDP/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n\n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Control.1.TDP == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X1.TDP..1.Healthy == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Control.1.TDP == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Control.1.TDP == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n\n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n\n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n\n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n\n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Nou\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Nou\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Nou\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Nou\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Nou\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Nou\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Nou\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Nou\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\n\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/TDP43_Validation_results_cs.csv\"))\n\n\n# C9\n\nFTLD_TDP &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV/\"\nNOU &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV/\"\nRESULTS_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/OVERLAP/C9_NEW/CS\"\n\n# Generate output dataframe\nResults &lt;- data.frame(matrix(ncol = length(CStates), nrow = 10))\ncolnames(Results) &lt;- CStates\nrownames(Results) &lt;- c(\n  \"Upregulated FTLD_TDP\", \"Upregulated Rimod\", \n  \"Downregulated FTLD_TDP\", \"Downregulated Rimod\",\n  \"CU FTLD – Rimod\", \"CD FTLD – Rimod\", \n  \"JU FTLD – Rimod\", \"JD FTLD – Rimod\",\n  \"GU FTLD – Rimod\", \"GD FTLD – Rimod\")\n\n# Iterate to obtain the results for each case.\nfor (i in seq_along(CStates)) {\n  CS &lt;- CStates[i]\n  # Read data\n  if (file.exists(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))){\n    ftld_tdp &lt;- read.csv(paste0(FTLD_TDP, CS ,\"/\", \"C9orf72/results_adj_h.csv\"))\n  } else {\n    ftld_tdp &lt;- c()\n  }\n  \n  if (file.exists(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))){\n    nou &lt;- read.csv(paste0(NOU,CS,\"/\" ,\"C9orf72/results_adj_h.csv\"))\n  } else {\n    nou &lt;- c()\n  }\n  \n  # Extract DEG\n  \n  # For U_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1])) {\n    U_ftld &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For U_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.C9orf72 == 1])) {\n    U_nou &lt;- character(0)  # Assign an empty vector if NULL\n  } else {\n    U_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == 1]\n  }\n  \n  # For D_ftld\n  if (is.null(ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1])) {\n    D_ftld &lt;-character(0)  # Assign an empty vector if NULL\n  } else {\n    D_ftld &lt;- ftld_tdp$X[ftld_tdp$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # For D_nou\n  if (is.null(nou$X[nou$X.1.Healthy.1.c9orf72 == -1])) {\n    D_nou &lt;-character(0) # Assign an empty vector if NULL\n  } else {\n    D_nou &lt;- nou$X[nou$X.1.Healthy.1.C9orf72 == -1]\n  }\n  \n  # OVERLAP GENES\n  C_U_ftld_nou &lt;- intersect(U_ftld, U_nou)\n  C_D_ftld_nou &lt;- intersect(D_ftld, D_nou)\n  \n  # SIMILARITY INDEX\n  Ujaccard13 &lt;- jaccard_similarity(U_ftld, U_nou)\n  Djaccard13 &lt;- jaccard_similarity(D_ftld, D_nou)\n  \n  # HIPERGEOMETRIC TESTS\n  total_genes_FN &lt;- length(unique(c(ftld_tdp$X, nou$X)))\n  \n  # Gene Overlap\n  GU_13 = testGeneOverlap(newGeneOverlap(U_ftld, U_nou, total_genes_FN))@pval\n  GD_13 = testGeneOverlap(newGeneOverlap(D_ftld, D_nou, total_genes_FN))@pval\n  \n  # UPDATE RESULTS TABLE WITH THE CALCULATED VALUES.\n  Results[\"Upregulated FTLD_TDP\", CS] &lt;- length(U_ftld)\n  Results[\"Upregulated Rimod\", CS] &lt;- length(U_nou)\n  Results[\"Downregulated FTLD_TDP\", CS] &lt;- length(D_ftld)\n  Results[\"Downregulated Rimod\", CS] &lt;- length(D_nou)\n  Results[\"CU FTLD – Rimod\", CS] &lt;- length(C_U_ftld_nou)\n  Results[\"CD FTLD – Rimod\", CS] &lt;- length(C_D_ftld_nou)\n  Results[\"JU FTLD – Rimod\", CS] &lt;- Ujaccard13\n  Results[\"JD FTLD – Rimod\", CS] &lt;- Djaccard13\n  Results[\"GU FTLD – Rimod\", CS] &lt;- GU_13\n  Results[\"GD FTLD – Rimod\", CS] &lt;- GD_13\n  \n}\nResults &lt;- t(Results)\nView(Results)\nView(Results[rowSums(Results[, 1:4]) &gt; 0, ])\nwrite.csv(Results, file = paste0(RESULTS_PATH, \"/C9_Validation_results_cs.csv\"))"
  },
  {
    "objectID": "Methods/Sc_dea.html#analytical-goals-of-the-single-cellresolved-differential-expression-analysis",
    "href": "Methods/Sc_dea.html#analytical-goals-of-the-single-cellresolved-differential-expression-analysis",
    "title": "Single cell differencial expression analysis",
    "section": "",
    "text": "The single-cell differential expression module was designed to:\n\nIdentify the precise cell states driving disease-specific transcriptional alterations in FTLD-C9 and FTLD-TDP.\nDistinguish neuronal and glial subtypes with high DEG burden, pointing to selective cellular vulnerability.\nCharacterize lineage-specific pathways, such as synaptic dysfunction in RORB neurons or inflammatory activation in GFAP+ astrocytes.\nLink transcriptional changes to neuropathological markers, including STMN2 loss, pTDP-43 burden, and DPR/RNA foci density.\nEnable functional enrichment (GO/Metascape) for each cell state, revealing discrete biological processes altered in disease.\nProvide a unified cellular framework for comparing FTLD-C9 and FTLD-TDP, facilitating identification of shared and divergent mechanisms.\nSupport robust cross-validation with independent datasets, increasing confidence in the generalizability of cell-state transcriptional signatures.\n\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# c9\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/C9/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/FTLD_BULK/SURROGATED_VARIABLES/SV1_C9_HC_QUIM.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/C9/CS_SV\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n\ncovariate_data &lt;- read.csv(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$sample.ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\nif (endsWith(CASE_LEGEND, \".csv\")) {\n  case_legend &lt;- read.csv(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group.ID &lt;- NULL\n} else if (endsWith(CASE_LEGEND, \".xlsx\")) {\n  case_legend &lt;- readxl::read_xlsx(CASE_LEGEND)\n  case_legend$group_ID &lt;- as.factor(case_legend$group.ID)\n  case_legend$group2_ID &lt;- as.factor(case_legend$group2.ID)\n  case_legend$group2.ID &lt;- NULL\n  case_legend$group.ID &lt;- NULL\n} else {\n  print(\"File type not recognized.\")\n}\n\ncase_legend$group2_ID &lt;- droplevels(case_legend$group2_ID)\ncase_legend$group_ID &lt;- as.character(case_legend$group_ID)\ncase_legend$group_ID &lt;- as.factor(case_legend$group_ID)\ncase_legend$group_ID &lt;- droplevels(case_legend$group_ID)\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  conditions &lt;- \"C9orf72\"\n  for (condition in conditions){\n    \n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$sample.ID, covariate_data$sample.ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$sample.ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$sample.ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\nlibrary(edgeR, lib.loc = \"/home/jaumatell/R/x86_64-pc-linux-gnu-library/4.4/edgeR_4\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/FTLD/TDP/CELL STATE/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BayesPrism/FTD/DATASETS/FTD_QUIM/decoder_DeSeq2_FTD_FINAL.xlsx\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/FTLD/TDP/DEG\"\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.xlsx(CASE_LEGEND,sheetIndex = 1)\ncase_legend$group_ID &lt;- factor(case_legend$group.ID)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"TDP\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  rownames(data) &lt;-gsub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      \n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- relevel(factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition)), ref = condition)\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      \n      common_ids &lt;- intersect(comparison_data$sample.ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$sample.ID, rownames(data_subset)), ]\n      data_ordered[is.na(data_ordered)] &lt;- 10e-8\n      \n      group &lt;- factor(comparison_data$group_ID)\n      y &lt;- DGEList(counts = t(data_ordered), group = group)\n      \n      # Plot average log CPM\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(y, column = 1)\n      abline(h = 0, col = \"red\", lty = 2, lwd = 2)\n      dev.off()\n      \n      # Create design matrix\n      design &lt;- model.matrix(~ 0 + group)\n      colnames(design) &lt;- levels(group)\n      \n      # Estimate dispersion\n      y &lt;- estimateDisp(y, design)\n      fit &lt;- glmFit(y, design)\n      \n      #Differential expression analysis\n      contrast &lt;- makeContrasts(contrasts = paste0(make.names(condition), \" - \", make.names(REFERENCE_GROUP)), levels = design)\n      res &lt;- glmLRT(fit, contrast = contrast)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc = 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\")\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      \n      # Save results\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      \n      # Histogram\n      plot_filename &lt;- file.path(condition_folder, \"histogram_plot_h.png\")\n      png(file = plot_filename)\n      hist(AveLogCPM)\n      dev.off()\n      \n      # BCV plot\n      plot_filename &lt;- file.path(condition_folder, \"BCV_plot_h.png\")\n      png(file = plot_filename)\n      plotBCV(y)\n      dev.off()\n      \n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status = is.de)\n      dev.off()\n      \n      # Heatmap clustering\n      logCPM &lt;- cpm(y, prior.count = 2, log = TRUE)\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep = \"-\")\n      tr &lt;- glmTreat(fit, contrast = contrast, lfc = log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30], ]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins = c(7, 7), lhei = c(1, 6), lwid = c(1, 3))\n      dev.off()\n      \n      # Update summary DataFrame\n      df[condition, filename] &lt;- nrow(results_table[results_table$adj_pval &lt; 0.05, ])\n      \n    }, error = function(e) {\n      print(e)\n      df[condition, filename] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\nlibrary(\"xlsx\")\n################################################################################\n# Paths and parameters\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/RIMOD/CELL STATE ORIGINAL/\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/DATA/rimod_ftd_dataset_table_v3.txt\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/RIMOD/CS_SV\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/RIMOD_BULK/METADATA/SVA.csv\"\n\nREFERENCE_GROUP &lt;- \"Healthy\"\n################################################################################\n\ncovariate_data &lt;- read.csv(SV_COVARIATE, sep = \"\\t\")\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Read case legend and prepare group IDs\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$DiseaseCode %in% c(\"control\", \"FTD-C9\"), ]\n\n# 2. Renombrar valores dentro de DiseaseCode\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"control\"] &lt;- \"Healthy\"\ncase_legend$DiseaseCode[case_legend$DiseaseCode == \"FTD-C9\"] &lt;- \"C9orf72\"\n\ncase_legend$group_ID &lt;- factor(case_legend$DiseaseCode)\ncase_legend$group.ID &lt;- NULL\n\n# Ensure levels are consistent and drop unused levels\nconditions &lt;- levels(as.factor(case_legend$group_ID))\nconditions &lt;- \"C9orf72\"\n\n# Create output directory if it doesn't exist\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\n# Initialize summary matrix\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- sapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n# Process each CSV file\nfor (file in csv_files) {\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names = 1)\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions) {\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$RimodID, covariate_data$ID)]\n\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      common_ids &lt;- intersect(comparison_data$RimodID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$RimodID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$RimodID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$RimodID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\n# Save summary DataFrame\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))\n\n\nlibrary(\"edgeR\")\nlibrary(\"dplyr\")\nlibrary(\"GO.db\")\n\n# FTD\n#CT\nCSV_DECONVOLDED_PATH &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/BAYESPRISM/NEW/CELL STATE ORIGINAL\"\nCASE_LEGEND &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/Sample_info.txt\"\nSV_COVARIATE &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/NEW_BULK/METADATA/SVA_correcte.csv\"\nOUTPUT_DIRECTORY &lt;- \"/media/jaumatell/datos/URI/BAYESPRISM_12_3/EDGER/NEW/CS_SVcorrect\"\n\nREFERENCE_GROUP &lt;- \"Control\"\n\ncovariate_data &lt;- read.delim(SV_COVARIATE)\ncovariate_data$sample.ID &lt;- sub(\"^long\", \"\", covariate_data$ID)\n\n\ncsv_files &lt;- list.files(CSV_DECONVOLDED_PATH, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n\ncase_legend &lt;- read.delim(CASE_LEGEND)\ncase_legend &lt;- case_legend[case_legend$GROUP != \"FTLD-TDP-C\",]\ncase_legend$GROUP[case_legend$GROUP != \"Control\"] &lt;- \"TDP\"\ncase_legend$group_ID &lt;- as.factor(case_legend$GROUP)\n\n\nconditions &lt;- levels(case_legend$group_ID)\nif (REFERENCE_GROUP %in% conditions) {\n  conditions &lt;- conditions[conditions != REFERENCE_GROUP]\n}\nif (!file.exists(OUTPUT_DIRECTORY)) {\n  dir.create(OUTPUT_DIRECTORY, recursive = TRUE)\n}\n\nmatrix_data &lt;- matrix(1:length(conditions)*length(csv_files), nrow = length(conditions), ncol = length(csv_files))\n\n# Create a DataFrame with the matrix data, specifying column and row names\ndf &lt;- data.frame(matrix_data, row.names = conditions)\ncolnames(df) &lt;- lapply(csv_files, function(file) tools::file_path_sans_ext(basename(file)))\n\n\nfor (file in csv_files){\n  filename &lt;- tools::file_path_sans_ext(basename(file))\n  print(filename)\n  \n  data &lt;- read.csv(file, row.names=1)\n  rownames(data) &lt;- sub(\"^long\", \"\", rownames(data))\n  rownames(data) &lt;- sub(\"X\", \"\", rownames(data))\n  celltype_folder &lt;- file.path(OUTPUT_DIRECTORY, filename)\n  \n  if (!file.exists(celltype_folder)) {\n    dir.create(celltype_folder, recursive = TRUE)\n  }\n  \n  for (condition in conditions){\n    condition &lt;- \"TDP\"\n    print(condition)\n    condition_folder &lt;- file.path(celltype_folder, condition)\n    if (!file.exists(condition_folder)) {\n      dir.create(condition_folder, recursive = TRUE)\n    }\n    \n    tryCatch({\n      results_table &lt;- NULL\n      res &lt;- NULL\n      comparison_data &lt;- case_legend[case_legend$group_ID %in% c(REFERENCE_GROUP, condition), ]\n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID)\n      \n      comparison_data$SV1 &lt;- covariate_data$SV1[match(comparison_data$FCX_ID, covariate_data$ID)]\n      \n      comparison_data$group_ID &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data &lt;- comparison_data[order(comparison_data$group_ID), ]\n      comparison_data$FCX_ID &lt;- gsub(\"-\", \".\", comparison_data$FCX_ID)\n      common_ids &lt;- intersect(comparison_data$FCX_ID, rownames(data))\n      data_subset &lt;- data[rownames(data) %in% common_ids, ]\n      data_ordered &lt;- data_subset[match(comparison_data$FCX_ID, rownames(data_subset)), ]\n      # CLEAN NA\n      data_ordered[!is.finite(as.matrix(data_ordered))] &lt;- 0\n      data_ordered &lt;- data_ordered[complete.cases(data_ordered), ]\n      comparison_data &lt;- comparison_data[match(rownames(data_ordered), comparison_data$FCX_ID), ]\n      \n      group &lt;- factor(comparison_data$group_ID[comparison_data$group_ID %in% c(REFERENCE_GROUP, condition)])\n      y &lt;- DGEList(counts=t(data_ordered),group=group)\n      y &lt;- y[, colSums(y$counts) &gt; 0]\n      # Keep only samples in comparison_data that are in y\n      comparison_data &lt;- comparison_data[match(colnames(y), comparison_data$FCX_ID), ]\n      \n      # Average Log CPM histogram\n      AveLogCPM &lt;- aveLogCPM(y)\n      y &lt;- normLibSizes(y)\n      \n      # MD plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_plot_h.png\")\n      png(file = plot_filename)\n      MD_plot &lt;- plotMD(y, column=1) +\n        abline(h=0, col=\"red\", lty=2, lwd=2)\n      dev.off()\n      \n      # DESIGN MATRIX\n      group &lt;- factor(comparison_data$group_ID, levels = c(REFERENCE_GROUP, condition))\n      comparison_data$group_ID &lt;- relevel(comparison_data$group_ID, ref = REFERENCE_GROUP)\n      design &lt;- model.matrix(~ 0 + comparison_data$group_ID + comparison_data$SV1, data = comparison_data)\n      colnames(design) &lt;- c(REFERENCE_GROUP, condition, \"SV1\")\n      nrow(design) == ncol(y)\n      \n      # DISPERSION ESTIMATION\n      y &lt;- estimateDisp(y,design)\n      fit &lt;- glmFit(y,design)\n      \n      # Diferential expression analysis\n      B.LvsP &lt;- makeContrasts(paste0(condition, \" - \", REFERENCE_GROUP), levels=design)\n      res &lt;- glmLRT(fit, contrast=B.LvsP)\n      is.de &lt;- decideTests(res, adjust.method = \"fdr\", p.value = 0.05, lfc= 0)\n      results_table &lt;- res$table\n      results_table$adj_pval &lt;- p.adjust(results_table$PValue, method = \"fdr\", n = length(results_table$PValue))\n      results_table &lt;- cbind(results_table, data.frame(is.de))\n      # SAVING CSV RESULTS\n      write.csv(res$table, file = file.path(condition_folder, \"res_h.csv\"))\n      write.csv(results_table, file = file.path(condition_folder, \"results_adj_h.csv\"))\n      ## Visualizations\n      # \"Volcano like\" plot\n      plot_filename &lt;- file.path(condition_folder, \"MD_res_plot_h.png\")\n      png(file = plot_filename)\n      plotMD(res, status=is.de)\n      dev.off()\n      \n      # Heatmap clustering \n      logCPM &lt;- cpm(y, prior.count=2, log=TRUE)\n      rownames(logCPM) &lt;- y$genes$Symbol\n      colnames(logCPM) &lt;- paste(y$samples$group, 1:2, sep=\"-\")\n      tr &lt;- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))\n      o &lt;- order(tr$table$PValue)\n      logCPM &lt;- logCPM[o[1:30],]\n      \n      plot_filename &lt;- file.path(condition_folder, \"Heatmap_h.png\")\n      png(file = plot_filename)\n      coolmap(logCPM, margins=c(7,7), lhei=c(1,6), lwid=c(1,3))\n      dev.off()\n      \n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- nrow(results_table[results_table$adj_pval&lt;0.05,])\n      \n    }, error = function(e){\n      df[condition, tools::file_path_sans_ext(basename(file))] &lt;- 0\n    })\n  }\n}\n\nwrite.csv(df, file = file.path(OUTPUT_DIRECTORY, \"summary_h.csv\"))"
  },
  {
    "objectID": "Results/Bulk_dea_results.html",
    "href": "Results/Bulk_dea_results.html",
    "title": "Bulk differencial expression analysis",
    "section": "",
    "text": "The results on bulk differencial expression analysis showed…."
  },
  {
    "objectID": "Results/Bulk_dea_results.html#c9",
    "href": "Results/Bulk_dea_results.html#c9",
    "title": "Bulk differencial expression analysis",
    "section": "C9",
    "text": "C9\nIn the case of C9 our dataset shown ……\nRimmod in the other hand was ……\n\nSant Pau\n\n\nRimmod"
  },
  {
    "objectID": "Results/Bulk_dea_results.html#tdp",
    "href": "Results/Bulk_dea_results.html#tdp",
    "title": "Bulk differencial expression analysis",
    "section": "TDP",
    "text": "TDP\nIn the case of TDP our dataset shown ……\nPineda in the other hand was ……\n\nSant Pau\n\n\nPottier\n\ncell_type_dea &lt;- load_or_placeholder(\n  option_name = \"results_vis.cell_type_dea\",\n  pattern = \"cell.*type.*dea.*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    tibble::tibble(\n      Cluster = rep(paste(\"Cluster\", 1:8), each = 40),\n      Gene = paste0(\"Gene\", seq_len(320)),\n      avg_log2FC = rnorm(320, sd = 0.8),\n      pct_in = runif(320, min = 0, max = 1),\n      pct_out = runif(320, min = 0, max = 1),\n      p_val_adj = p.adjust(runif(320, min = 1e-5, max = 0.5), method = \"BH\")\n    )\n  }\n)\n\n\nrender_source_note(cell_type_dea, \"cell type DEA\")\nplot_ly(\n  cell_type_dea,\n  x = ~avg_log2FC,\n  y = ~-log10(p_val_adj + 1e-12),\n  color = ~Cluster,\n  text = ~paste(\n    \"Gene:\", Gene,\n    \"&lt;br&gt;pct_in:\", sprintf(\"%.1f%%\", pct_in * 100),\n    \"&lt;br&gt;pct_out:\", sprintf(\"%.1f%%\", pct_out * 100)\n  ),\n  type = \"scatter\",\n  mode = \"markers\",\n  hovertemplate = \"%{text}&lt;extra&gt;&lt;/extra&gt;\"\n) %&gt;%\n  layout(title = \"Cell-Type Differential Expression\",\n         xaxis = list(title = \"Average log2 Fold Change\"),\n         yaxis = list(title = \"-log10(adj p-value)\")) %&gt;%\n  annotate_placeholder(cell_type_dea)"
  },
  {
    "objectID": "Results/Cell_correlation.html#tdp-sant-pau",
    "href": "Results/Cell_correlation.html#tdp-sant-pau",
    "title": "Cell composition correlation with neuropathology",
    "section": "TDP Sant Pau",
    "text": "TDP Sant Pau\n\npTDP43\n\n\nSTMN2\n\ncell_prop_corr &lt;- load_or_placeholder(\n  option_name = \"results_vis.cell_prop_corr\",\n  pattern = \"cell.*prop.*(corr|correlation).*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    cell_types &lt;- c(\"Astrocyte\", \"Neuron\", \"Microglia\", \"Oligodendrocyte\", \"Endothelial\")\n    metrics &lt;- c(\"Age\", \"DiseaseDuration\", \"MMSE\", \"Module1\", \"Module2\")\n    expand_grid(CellType = cell_types, Metric = metrics) %&gt;%\n      mutate(Correlation = runif(n(), min = -1, max = 1))\n  }\n)\n\n\nrender_source_note(cell_prop_corr, \"cell proportion correlations\")\ncell_prop_corr_wide &lt;- cell_prop_corr %&gt;%\n  tidyr::pivot_wider(names_from = Metric, values_from = Correlation)\ncell_prop_corr_matrix &lt;- cell_prop_corr_wide %&gt;%\n  column_to_rownames(\"CellType\") %&gt;%\n  as.matrix()\ncell_prop_corr_hover &lt;- cell_prop_corr %&gt;%\n  mutate(label = glue::glue(\"{CellType} vs {Metric}&lt;br&gt;Correlation: {round(Correlation, 2)}\")) %&gt;%\n  tidyr::pivot_wider(names_from = Metric, values_from = label) %&gt;%\n  column_to_rownames(\"CellType\") %&gt;%\n  as.matrix()\nplot_ly(\n  x = colnames(cell_prop_corr_matrix),\n  y = rownames(cell_prop_corr_matrix),\n  z = cell_prop_corr_matrix,\n  type = \"heatmap\",\n  colors = \"RdBu\",\n  reversescale = TRUE,\n  text = cell_prop_corr_hover,\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(title = \"Correlation of Cell Proportions with Metadata\") %&gt;%\n  annotate_placeholder(cell_prop_corr)"
  },
  {
    "objectID": "Results/Hdwgcna_differences.html#tdp",
    "href": "Results/Hdwgcna_differences.html#tdp",
    "title": "Gene modules differences",
    "section": "TDP",
    "text": "TDP\n\nSant Pau\n\n\n\n\n\nPottier\n\nmodule_diff &lt;- load_or_placeholder(\n  option_name = \"results_vis.module_diff\",\n  pattern = \"module.*(difference|activity).*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    tibble::tibble(\n      Module = paste0(\"Module\", seq_len(12)),\n      Group = rep(c(\"Control\", \"FTLD\"), each = 12),\n      Score = rnorm(24, mean = rep(c(0, 1), each = 12), sd = 0.5)\n    )\n  }\n)\n\n\nrender_source_note(module_diff, \"module differences\")\nplot_ly(\n  module_diff,\n  x = ~Module,\n  y = ~Score,\n  color = ~Group,\n  type = \"bar\"\n) %&gt;%\n  layout(barmode = \"group\",\n         title = \"Module Activity Differences\",\n         xaxis = list(title = \"Module\"),\n         yaxis = list(title = \"Score\")) %&gt;%\n  annotate_placeholder(module_diff)"
  },
  {
    "objectID": "Results/Sc_gene_correlation.html#tdp",
    "href": "Results/Sc_gene_correlation.html#tdp",
    "title": "Single cell gene correlation with neuropathology markers",
    "section": "TDP",
    "text": "TDP\n\npTDP43\n\n\nSTMN2\n\n\n\n\ngoi_corr &lt;- load_or_placeholder(\n  option_name = \"results_vis.goi_corr\",\n  pattern = \"genes.*(interest|goi).*corr.*\\\\.(csv|tsv|txt|rds|rda|RData|xlsx)$\",\n  generator = function() {\n    genes &lt;- paste0(\"Gene\", LETTERS[1:10])\n    metrics &lt;- paste0(\"Metric\", 1:10)\n    expand_grid(Gene = genes, Metric = metrics) %&gt;%\n      mutate(Correlation = runif(n(), min = -1, max = 1))\n  }\n)\n\n\nrender_source_note(goi_corr, \"genes of interest correlation\")\ngoi_wide &lt;- goi_corr %&gt;%\n  tidyr::pivot_wider(names_from = Metric, values_from = Correlation)\ngoi_matrix &lt;- goi_wide %&gt;%\n  column_to_rownames(\"Gene\") %&gt;%\n  as.matrix()\ngoi_hover &lt;- goi_corr %&gt;%\n  mutate(label = glue::glue(\"{Gene} vs {Metric}&lt;br&gt;Correlation: {round(Correlation, 2)}\")) %&gt;%\n  tidyr::pivot_wider(names_from = Metric, values_from = label) %&gt;%\n  column_to_rownames(\"Gene\") %&gt;%\n  as.matrix()\nplot_ly(\n  x = colnames(goi_matrix),\n  y = rownames(goi_matrix),\n  z = goi_matrix,\n  type = \"heatmap\",\n  colors = \"RdBu\",\n  reversescale = TRUE,\n  text = goi_hover,\n  hoverinfo = \"text\"\n) %&gt;%\n  layout(title = \"Genes of Interest Correlation Matrix\") %&gt;%\n  annotate_placeholder(goi_corr)"
  },
  {
    "objectID": "Validation/Hdwgcna_validation.html#tdp",
    "href": "Validation/Hdwgcna_validation.html#tdp",
    "title": "Validation: Gene modules analysis",
    "section": "TDP",
    "text": "TDP\n\nHDWGCNA CORRESPONDANCE\n\n\nHDWGCNA DIFFERENCES"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the project analysis of FTLD"
  }
]